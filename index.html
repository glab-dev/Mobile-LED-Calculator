<!DOCTYPE html>
<!--
  ============================================================================
  LED Wall Calculator - Mobile v2
  Â© 2025 Gabriel Labrecque
  Fearless Wanderer Productions

  All rights reserved. This software and its source code are the property of
  Gabriel Labrecque / Fearless Wanderer Productions. Unauthorized copying,
  modification, distribution, or use of this software is strictly prohibited.
  ============================================================================
-->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="LED Calc">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0a0a0a">
  <meta name="description" content="LED Wall Calculator - Professional LED panel configuration tool">
  <title>LED Wall Calculator â€“ Mobile v2</title>

  <!-- PWA Manifest (inline base64) -->
  <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIkxFRCBXYWxsIENhbGN1bGF0b3IiLAogICJzaG9ydF9uYW1lIjogIkxFRCBDYWxjIiwKICAiZGVzY3JpcHRpb24iOiAiUHJvZmVzc2lvbmFsIExFRCBwYW5lbCBjb25maWd1cmF0aW9uIHRvb2wiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzBhMGEwYSIsCiAgInRoZW1lX2NvbG9yIjogIiMwYTBhMGEiLAogICJvcmllbnRhdGlvbiI6ICJhbnkiCn0=">

  <!-- iOS Icons (inline SVG) -->
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect fill='%230a0a0a' width='180' height='180' rx='40'/%3E%3Ctext x='90' y='115' font-size='70' text-anchor='middle' fill='%237eb8a6'%3ELED%3C/text%3E%3C/svg%3E">

  <!-- Comic book style fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Permanent+Marker&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0; padding: 0; }

    /* ==================== MOBILE-FIRST BASE STYLES ==================== */
    :root {
      --safe-area-top: env(safe-area-inset-top, 0px);
      --safe-area-bottom: env(safe-area-inset-bottom, 0px);
      --safe-area-left: env(safe-area-inset-left, 0px);
      --safe-area-right: env(safe-area-inset-right, 0px);
      --bottom-nav-height: 70px;
      --header-height: 56px;
      --primary: #10b981;
      --primary-hover: #059669;
      --accent-color: #10b981;
      --bg-color: #111827;
      --comic-dark: #1a1a1a;
      --comic-panel: #262626;
      --card-bg: #262626;
      --border-color: #000000;
      --text-color: #e0e0e0;
      --muted-color: #9ca3af;
    }

    body {
      font-family: 'Roboto Condensed', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      padding: 12px;
      padding-top: calc(var(--header-height) + var(--safe-area-top) + 12px);
      padding-bottom: calc(var(--bottom-nav-height) + var(--safe-area-bottom) + 24px);
      padding-left: calc(var(--safe-area-left) + 12px);
      padding-right: calc(var(--safe-area-right) + 12px);
      color: var(--text-color);
      background: var(--bg-color);
      -webkit-text-size-adjust: 100%;
      min-height: 100vh;
      font-size: 16px;
      line-height: 1.5;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-y: contain;
      position: relative;
    }

    /* Halftone pattern overlay */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      opacity: 0.15;
      background-image: radial-gradient(circle, #333 1px, transparent 1px);
      background-size: 20px 20px;
    }

    /* Gradient overlay at bottom */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
      background: linear-gradient(to bottom, transparent 0%, transparent 60%, rgba(0,0,0,0.4) 100%);
    }

    /* Comic text outline utility */
    .text-outline-black {
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    /* Comic box shadows */
    .shadow-comic {
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1);
    }
    .shadow-comic-sm {
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    /* Mobile Header - Comic Style */
    .mobile-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: calc(var(--header-height) + var(--safe-area-top));
      padding-top: var(--safe-area-top);
      background: var(--comic-dark);
      border-bottom: 4px solid #000;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-left: calc(var(--safe-area-left) + 16px);
      padding-right: calc(var(--safe-area-right) + 16px);
      z-index: 1000;
    }

    .mobile-header h1 {
      font-size: 26px;
      margin: 0;
      font-family: 'Bangers', cursive;
      color: var(--primary);
      letter-spacing: 3px;
      text-shadow:
        2px 2px 0 #000,
        -1px -1px 0 #000,
        1px -1px 0 #000,
        -1px 1px 0 #000;
      -webkit-text-stroke: 1px black;
    }

    .mobile-header-actions {
      display: flex;
      gap: 12px;
    }

    .mobile-header-btn {
      width: 40px;
      height: 40px;
      border: none;
      background: transparent;
      color: var(--primary);
      font-size: 22px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      transition: color 0.2s;
    }

    .mobile-header-btn .material-symbols-outlined {
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 0 rgba(0,0,0,1);
    }

    .mobile-header-btn:hover {
      color: #34d399;
    }

    .mobile-header-btn:active {
      color: #34d399;
    }

    /* Bottom Navigation - Comic Style */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: calc(var(--bottom-nav-height) + var(--safe-area-bottom));
      padding-bottom: var(--safe-area-bottom);
      background: var(--comic-dark);
      border-top: 4px solid #000;
      display: flex;
      z-index: 1000;
      padding: 8px;
      padding-bottom: calc(8px + var(--safe-area-bottom));
      gap: 8px;
    }

    .nav-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      text-decoration: none;
      font-size: 11px;
      font-family: 'Bangers', cursive;
      font-weight: normal;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 8px 4px;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      border: 2px solid #000;
      background: var(--primary);
      border-radius: 4px;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      transition: all 0.1s;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .nav-item:hover {
      background: var(--primary-hover);
    }

    .nav-item:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .nav-item.active {
      background: var(--primary);
      color: white;
    }

    .nav-item-icon {
      font-size: 16px;
      margin-bottom: 2px;
      display: none;
    }

    .nav-item-label {
      font-size: 12px;
      line-height: 1;
    }

    /* Layouts Toggle Container (for switching between Standard/Power/Data/Structure) */
    .layouts-toggle-container {
      position: sticky;
      top: calc(var(--header-height) + var(--safe-area-top));
      background: #222;
      padding: 12px;
      z-index: 100;
      border-bottom: 4px solid #000;
      margin: -12px -12px 12px -12px;
    }

    .layouts-toggle-container .toggle-group {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .layouts-toggle-container .toggle-btn {
      flex: 1;
      min-width: 70px;
      padding: 10px 12px;
      font-size: 12px;
    }

    /* Comic title style */
    h1 {
      margin-bottom: 6px;
      color: var(--primary);
      font-size: 24px;
      font-family: 'Bangers', cursive;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 2px 2px 0px rgba(0,0,0,1);
    }

    .muted { color: var(--muted-color); font-size: 14px; line-height: 1.4; margin-bottom: 16px; }

    .main-container {
      border: none;
      padding: 0;
      border-radius: 2px;
      background: #222;
      border: 4px solid #000;
      border-top: 0;
      position: relative;
      z-index: 1;
      padding: 12px;
    }

    /* Single column layout for mobile */
    .two-column-layout {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    /* Comic Style Section Boxes */
    .section-box {
      background: var(--comic-panel);
      border: 4px solid #000;
      border-radius: 2px;
      padding: 16px;
      padding-top: 28px;
      margin-bottom: 16px;
      margin-top: 12px;
      overflow: visible;
      position: relative;
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1);
    }

    .section-title {
      position: absolute;
      top: -12px;
      left: 16px;
      background: #222;
      border: 1px solid var(--primary);
      padding: 4px 10px;
      margin: 0;
      font-family: 'Bangers', cursive;
      font-size: 16px;
      font-weight: normal;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: var(--primary);
      transform: rotate(-2deg);
      cursor: default;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .section-title::after {
      content: none;
    }

    .section-box.collapsed .section-title::after {
      transform: none;
    }

    .section-content {
      padding: 0;
      transition: none;
      overflow: visible;
    }

    .section-box.collapsed .section-content {
      max-height: none;
      padding-top: 0;
      padding-bottom: 0;
    }

    label {
      display: block;
      color: #d1d5db;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      margin-bottom: 12px;
    }

    label span {
      display: block;
      margin-bottom: 4px;
      margin-left: 2px;
      font-weight: 700;
      font-size: 11px;
      color: #d1d5db;
      text-transform: uppercase;
    }
    
    /* Comic style inputs */
    input[type="number"], input[type="text"], select {
      width: 100%;
      padding: 12px 14px;
      font-size: 16px; /* Prevents iOS zoom on focus */
      font-family: 'Permanent Marker', cursive;
      background: #333;
      color: #fff;
      border: 2px solid #000;
      border-radius: 0;
      -webkit-appearance: none;
      appearance: none;
      min-height: 48px; /* Touch-friendly */
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    select {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%2310b981'%3E%3Cpath d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 36px;
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3), 2px 2px 0px 0px rgba(0,0,0,1);
    }

    /* Hide number input spinners by default */
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type=number] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Compact input fields - still touch friendly */
    .compact-input {
      width: 90px !important;
    }

    .compact-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-end;
    }

    .compact-row label {
      margin-bottom: 0;
      flex: 1;
      min-width: 80px;
    }

    .compact-row-tight {
      display: flex;
      gap: 10px;
      align-items: flex-end;
    }

    .compact-row-tight label {
      margin-bottom: 0;
    }

    .three-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }

    .three-inputs label {
      margin-bottom: 0;
    }

    input[type="checkbox"], input[type="radio"] {
      width: 24px;
      height: 24px;
      margin: 0;
      cursor: pointer;
    }

    .inline-group {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .inline-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      font-size: 14px;
      min-height: 44px; /* Touch target */
    }

    .two-inputs {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .two-inputs label {
      margin-bottom: 0;
    }

    /* Mobile-optimized buttons - Comic Style */
    button {
      padding: 12px 20px;
      font-size: 14px;
      font-family: 'Permanent Marker', cursive;
      cursor: pointer;
      border-radius: 0;
      border: 2px solid #000;
      background: var(--primary);
      color: white;
      width: 100%;
      margin-bottom: 10px;
      min-height: 48px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      transition: all 0.1s;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    button:hover {
      background: var(--primary-hover);
    }

    button:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    @media (min-width: 640px) {
      button {
        width: auto;
        margin-right: 8px;
        margin-bottom: 0;
      }
    }
    
    .button-row {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .result {
      margin-top: 20px;
      background: var(--comic-panel);
      padding: 16px;
      border: 4px solid #000;
      border-radius: 2px;
      color: #e0e0e0;
      font-size: 13px;
      overflow-x: auto;
      font-family: 'Roboto Condensed', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      line-height: 1.6;
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1);
    }

    .result-section {
      margin-bottom: 16px;
    }

    .result-section-title {
      font-family: 'Permanent Marker', cursive;
      font-weight: normal;
      text-decoration: underline;
      margin-bottom: 4px;
      margin-top: 12px;
      color: var(--primary);
    }

    .result-row {
      margin: 2px 0;
    }

    .result-row strong {
      font-weight: 600;
      color: #ffffff;
    }

    .result-indent {
      margin-left: 20px;
    }

    canvas {
      border: 2px solid #000;
      margin-top: 12px;
      display: block;
      background: #fff;
    }

    /* Layout canvases should not be scaled by CSS */
    #standardCanvas, #structureCanvas, #powerCanvas, #dataCanvas {
      max-width: none;
      height: auto;
    }

    /* Canvas view can be responsive */
    #canvasView {
      max-width: 100%;
      height: auto;
    }

    canvas:focus {
      outline: 3px solid var(--primary);
      outline-offset: 2px;
    }

    .layout-container {
      margin-top: 20px;
      padding: 16px;
      background: var(--comic-panel);
      border: 4px solid #000;
      border-radius: 2px;
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1);
    }

    .layout-title {
      color: #fff;
      font-family: 'Permanent Marker', cursive;
      font-weight: normal;
      margin-bottom: 12px;
      font-size: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: 'Permanent Marker', cursive;
      letter-spacing: 1px;
    }
    
    .undo-redo-buttons {
      display: flex;
      gap: 8px;
    }
    
    .undo-redo-btn {
      padding: 6px 12px;
      font-size: 11px;
      font-family: 'Permanent Marker', cursive;
      background: #333;
      color: #e0e0e0;
      border: 2px solid #000;
      border-radius: 0;
      cursor: pointer;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .undo-redo-btn:hover:not(:disabled) {
      background: #444;
    }

    .undo-redo-btn:active:not(:disabled) {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .undo-redo-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .canvas-zoom-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-right: 16px;
    }

    .zoom-btn {
      padding: 6px 12px;
      font-size: 14px;
      font-weight: bold;
      font-family: 'Roboto Condensed', sans-serif;
      background: #333;
      color: #e0e0e0;
      border: 2px solid #000;
      border-radius: 0;
      cursor: pointer;
      transition: all 0.1s;
      min-width: 32px;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .zoom-btn:hover {
      background: #444;
    }

    .zoom-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    #canvasZoomInput {
      width: 55px;
      padding: 6px;
      font-size: 12px;
      text-align: center;
      background: #333;
      color: #fff;
      border: 2px solid #000;
      border-radius: 0;
      font-family: 'Permanent Marker', cursive;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    #canvasZoomInput:focus {
      outline: none;
      border-color: var(--primary);
    }

    .zoom-percent {
      font-size: 12px;
      color: #ccc;
    }
    
    .warn {
      color: #ff6b6b;
      font-weight: bold;
      font-size: 13px;
      margin-top: 12px;
    }
    
    .hint {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
    }
    
    .secondary-button {
      width: 100%;
      padding: 10px;
      background: #333;
      color: var(--primary);
      border: 2px solid #000;
      border-radius: 0;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Permanent Marker', cursive;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .secondary-button:hover {
      background: #444;
    }

    .secondary-button:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .secondary-button.active {
      background: var(--primary);
      color: #fff;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }
    
    .canvas-with-options {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 20px;
      align-items: start;
    }
    
    @media (max-width: 1200px) {
      .canvas-with-options {
        grid-template-columns: 1fr;
      }
    }
    
    .bumper-controls {
      margin-top: 10px;
      padding: 10px;
      background: #333;
      border-radius: 4px;
    }
    
    .bumper-column-input {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }
    
    .bumper-column-input input {
      width: 80px;
    }
    
    .weight-display {
      margin-top: 12px;
      padding: 10px;
      background: #1a1a1a;
      border-radius: 4px;
      font-size: 12px;
    }
    
    .weight-item {
      padding: 4px 0;
      border-bottom: 1px solid #333;
    }
    
    .weight-item:last-child {
      border-bottom: none;
    }
    
    /* Structure Manual Mode Toggle */
    .structure-mode-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      padding: 8px 12px;
      background: #333;
      border-radius: 6px;
    }
    
    .structure-mode-hint {
      font-size: 12px;
      color: #888;
      margin-left: auto;
    }
    
    .structure-selection-info {
      padding: 8px 12px;
      background: #2a3a4a;
      border: 1px solid #3a5a7a;
      border-radius: 4px;
      margin-bottom: 12px;
      font-size: 12px;
      color: #8ac;
      display: none;
    }
    
    .structure-selection-info.visible {
      display: block;
    }
    
    /* Structure Layout with info panel below */
    .structure-layout-wrapper {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .structure-canvas-area {
      width: 100%;
    }
    
    .structure-info-panel {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    
    .structure-info-box {
      background: #1a1a1a;
      border-radius: 6px;
      padding: 12px;
      font-size: 12px;
    }
    
    .structure-info-box.weights {
      border-left: 3px solid #4a9eff;
    }
    
    .structure-info-box.plates {
      border-left: 3px solid #6fc276;
    }
    
    .structure-info-box.ground-support {
      border-left: 3px solid #00CED1;
    }
    
    .structure-info-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .structure-info-title.weights { color: #4a9eff; }
    .structure-info-title.plates { color: #6fc276; }
    .structure-info-title.ground-support { color: #00CED1; }
    
    .weight-row {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #333;
    }
    
    .weight-row:last-child {
      border-bottom: none;
    }
    
    .weight-label {
      color: #aaa;
    }
    
    .weight-value {
      font-weight: 600;
      color: #fff;
    }
    
    .plates-row {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
    }
    
    .plates-label {
      color: #aaa;
    }
    
    .plates-value {
      font-weight: 600;
      color: #fff;
    }
    
    .plates-total {
      border-top: 1px solid #3a5a3a;
      margin-top: 6px;
      padding-top: 6px;
    }
    
    @media (max-width: 600px) {
      .structure-info-panel {
        grid-template-columns: 1fr;
      }
    }
    
    /* Toggle Buttons - Comic Style */
    .toggle-group, .unit-toggle-group {
      display: flex;
      gap: 8px;
    }

    /* Comic-style toggle buttons */
    .toggle-btn, .unit-toggle-btn {
      padding: 10px 16px;
      font-size: 13px;
      font-family: 'Permanent Marker', cursive;
      font-weight: normal;
      background: #333;
      color: #9ca3af;
      border: 2px solid #000;
      border-radius: 0;
      cursor: pointer;
      transition: all 0.1s;
      min-width: 44px;
      min-height: 44px;
      text-align: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .toggle-btn:hover, .unit-toggle-btn:hover {
      color: #fff;
      background: #444;
    }

    .toggle-btn:active, .unit-toggle-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .toggle-btn.active, .unit-toggle-btn.active {
      background: var(--primary);
      color: #fff;
      border-color: #000;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .toggle-btn.active:hover, .unit-toggle-btn.active:hover {
      background: var(--primary-hover);
    }

    .unit-toggles-row {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .toggle-label, .unit-toggle-label {
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      color: #9ca3af;
      margin-right: 6px;
    }

    /* Modal Dialog Styles - Comic Style */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-dialog {
      background: var(--comic-panel);
      border: 4px solid #000;
      border-radius: 2px;
      padding: 16px;
      max-width: 420px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid #000;
    }

    .modal-title {
      font-size: 18px;
      font-family: 'Bangers', cursive;
      font-weight: normal;
      letter-spacing: 1px;
      color: var(--primary);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .modal-close {
      background: none;
      border: 2px solid #000;
      color: #ff6b6b;
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      line-height: 28px;
      text-align: center;
      border-radius: 2px;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .modal-close:hover {
      background: #ff6b6b;
      color: #fff;
    }

    .modal-close:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .modal-body {
      margin-bottom: 12px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding-top: 10px;
      border-top: 1px solid #444;
    }
    
    .modal-input-group {
      margin-bottom: 8px;
    }
    
    .modal-input-group label {
      display: block;
      margin-bottom: 3px;
      color: #e0e0e0;
      font-size: 11px;
      font-weight: 500;
    }
    
    .modal-input-group input[type="text"],
    .modal-input-group input[type="number"] {
      width: 100%;
      padding: 5px 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
    }
    
    .modal-input-group input:focus {
      outline: none;
      border-color: #0a66c2;
    }
    
    .modal-input-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    
    .modal-input-group .hint {
      font-size: 10px;
      color: #888;
      margin-top: 2px;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 8px;
      font-size: 12px;
    }
    
    .checkbox-group input[type="checkbox"] {
      width: 14px;
      height: 14px;
    }
    
    .checkbox-group label {
      color: #e0e0e0;
      font-size: 12px;
    }
    
    .btn-primary {
      background: var(--primary);
      color: white;
      border: 2px solid #000;
      padding: 8px 16px;
      border-radius: 0;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Permanent Marker', cursive;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .btn-primary:hover {
      background: var(--primary-hover);
    }

    .btn-primary:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .btn-secondary {
      background: #333;
      color: #e0e0e0;
      border: 2px solid #000;
      padding: 8px 16px;
      border-radius: 0;
      cursor: pointer;
      font-size: 13px;
      font-family: 'Permanent Marker', cursive;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .btn-secondary:hover {
      background: #444;
    }

    .btn-secondary:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .btn-danger {
      background: #dc2626;
      color: white;
      border: 2px solid #000;
      padding: 10px 20px;
      border-radius: 0;
      cursor: pointer;
      font-size: 14px;
      font-family: 'Permanent Marker', cursive;
      transition: all 0.1s;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .btn-danger:hover {
      background: #b91c1c;
    }

    .btn-danger:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }
    
    .custom-item-list {
      margin-top: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .custom-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #333;
      border: 1px solid #444;
      border-radius: 4px;
      margin-bottom: 8px;
    }
    
    .custom-item:hover {
      background: #3a3a3a;
    }
    
    .custom-item-name {
      flex: 1;
      color: #e0e0e0;
      font-size: 14px;
    }
    
    .custom-item-actions {
      display: flex;
      gap: 8px;
    }
    
    .btn-small {
      padding: 4px 12px;
      font-size: 12px;
      border-radius: 4px;
      cursor: pointer;
      border: 1px solid #555;
      background: #444;
      color: #e0e0e0;
      transition: all 0.2s;
    }
    
    .btn-small:hover {
      background: #555;
    }
    
    .btn-small.danger {
      background: #c53030;
      border-color: #c53030;
      color: white;
    }
    
    .btn-small.danger:hover {
      background: #a02828;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .checkbox-group label {
      margin: 0;
      cursor: pointer;
      user-select: none;
    }
    
    .context-menu-item {
      padding: 8px 16px;
      cursor: pointer;
      color: #e0e0e0;
      font-size: 13px;
      transition: background 0.2s;
    }
    
    .context-menu-item:hover {
      background: #3a3a3a;
    }
    
    /* ==================== SCREEN TABS STYLES - Comic Style ==================== */
    .screen-tabs-container {
      display: flex;
      align-items: flex-end;
      padding: 8px 8px 0 8px;
      gap: 8px;
      overflow-x: auto;
      background: var(--comic-dark);
    }

    .screen-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 0;
      flex-wrap: nowrap;
      border-bottom: none;
      padding-bottom: 0;
      align-items: flex-end;
    }

    .screen-tab {
      padding: 10px 16px;
      background: var(--comic-panel);
      border: 4px solid #000;
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.1s;
      position: relative;
      top: 4px;
      color: #fff;
      min-height: 44px;
    }

    .screen-tab:hover {
      background: #333;
    }

    .screen-tab.active {
      background: var(--comic-panel);
      border-color: #000;
      color: var(--primary);
      z-index: 10;
    }

    .screen-tab-name {
      font-family: 'Permanent Marker', cursive;
      font-weight: normal;
      font-size: 14px;
      white-space: nowrap;
    }

    .screen-tab-edit {
      background: none;
      border: none;
      color: #9ca3af;
      cursor: pointer;
      padding: 2px 4px;
      font-size: 12px;
      border-radius: 2px;
      width: auto;
      margin: 0;
      min-height: auto;
      min-width: auto;
      box-shadow: none;
    }

    .screen-tab-edit:hover {
      color: #fff;
    }

    .screen-tab-close {
      background: none !important;
      border: none !important;
      color: #ff6b6b;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 18px;
      line-height: 1;
      border-radius: 2px;
      width: auto !important;
      margin: 0 !important;
      min-height: 24px;
      min-width: 24px;
      box-shadow: none !important;
      text-shadow: none !important;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .screen-tab-close:hover {
      color: #ff4444;
      background: rgba(255, 107, 107, 0.2) !important;
    }

    .screen-tab-close:active {
      transform: none;
    }

    .screen-tab-add {
      padding: 8px 12px;
      background: var(--primary);
      border: 4px solid #000;
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.1s;
      position: relative;
      top: 4px;
      min-height: 44px;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .screen-tab-add:hover {
      background: var(--primary-hover);
    }

    .screen-tab-add:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }
    /* ==================== END SCREEN TABS STYLES ==================== */
    
    /* Header with config buttons */
    .page-header {
      display: flex;
      justify-content: flex-end;
      align-items: flex-start;
      margin-bottom: 6px;
      padding-top: 50px; /* Space for background image title */
    }
    
    .page-header h1 {
      margin: 0;
    }
    
    .config-buttons {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 12px;
      border-radius: 6px;
    }
    
    .config-buttons input[type="text"] {
      padding: 6px 10px;
      font-size: 12px;
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
      width: 150px;
    }
    
    .config-buttons input[type="text"]::placeholder {
      color: rgba(255, 255, 255, 0.7);
    }
    
    .config-btn {
      padding: 8px 14px;
      font-size: 12px;
      font-family: 'Permanent Marker', cursive;
      cursor: pointer;
      border-radius: 0;
      border: 2px solid #000;
      color: white;
      transition: all 0.1s;
      white-space: nowrap;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .config-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .config-btn.save {
      background: var(--primary);
    }

    .config-btn.save:hover {
      background: var(--primary-hover);
    }

    .config-btn.load {
      background: #3498db;
    }

    .config-btn.load:hover {
      background: #2980b9;
    }

    .config-btn.export-pdf {
      background: #8e44ad;
    }

    .config-btn.export-pdf:hover {
      background: #7d3c98;
    }
    
    .header-buttons-row {
      display: flex;
      align-items: center;
    }

    /* Hide desktop-only elements on mobile */
    .desktop-only {
      display: none;
    }

    /* Mobile Menu Overlay - Comic Style */
    .mobile-menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .mobile-menu-overlay.active {
      display: block;
      opacity: 1;
    }

    .mobile-menu {
      position: absolute;
      top: 0;
      right: 0;
      width: 85%;
      max-width: 320px;
      height: 100%;
      background: var(--comic-dark);
      border-left: 4px solid #000;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }

    .mobile-menu-overlay.active .mobile-menu {
      transform: translateX(0);
    }

    .mobile-menu-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      padding-top: calc(var(--safe-area-top) + 16px);
      border-bottom: 4px solid #000;
      font-size: 20px;
      font-family: 'Bangers', cursive;
      letter-spacing: 2px;
      color: var(--primary);
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .mobile-menu-close {
      width: 44px;
      height: 44px;
      border: 2px solid #000;
      background: transparent;
      color: #ff6b6b;
      font-size: 24px;
      cursor: pointer;
      border-radius: 2px;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
    }

    .mobile-menu-close:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .mobile-menu-content {
      padding: 16px 20px;
      padding-bottom: calc(var(--safe-area-bottom) + 20px);
    }

    .mobile-menu-section {
      margin-bottom: 24px;
    }

    .mobile-menu-label {
      font-size: 11px;
      font-weight: 700;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }

    .mobile-menu-btn {
      width: 100%;
      padding: 14px 16px;
      margin-bottom: 8px;
      background: #333;
      border: 2px solid #000;
      border-radius: 2px;
      color: var(--text-color);
      font-size: 14px;
      font-family: 'Permanent Marker', cursive;
      text-align: left;
      cursor: pointer;
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      transition: all 0.1s;
    }

    .mobile-menu-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    .mobile-menu-btn.install-btn {
      background: var(--primary);
      color: #fff;
      font-weight: normal;
      text-shadow:
        -1px -1px 0 #000,
         1px -1px 0 #000,
        -1px  1px 0 #000,
         1px  1px 0 #000;
    }

    .mobile-menu-info {
      font-size: 12px;
      color: var(--muted-color);
      margin-bottom: 4px;
    }

    /* View Containers - Mobile optimized */
    .view-container {
      display: none;
    }

    .view-container.active {
      display: block;
    }

    /* Mobile canvas wrapper */
    .mobile-canvas-wrapper {
      width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      border: 2px solid #000;
      border-radius: 2px;
      background: #000;
    }

    /* Landscape orientation hint */
    .orientation-hint {
      display: none;
      padding: 12px 16px;
      background: rgba(16, 185, 129, 0.15);
      border: 2px solid var(--primary);
      border-radius: 2px;
      margin-bottom: 12px;
      font-size: 13px;
      color: var(--primary);
    }

    @media (orientation: portrait) {
      .orientation-hint.show-in-portrait {
        display: block;
      }
    }

    /* Touch canvas controls */
    .touch-zoom-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .touch-zoom-btn {
      flex: 1;
      min-width: 70px;
      padding: 12px;
      background: #333;
      border: 2px solid #000;
      border-radius: 0;
      color: var(--text-color);
      box-shadow: 2px 2px 0px 0px rgba(0,0,0,1);
      transition: all 0.1s;
      font-size: 18px;
      cursor: pointer;
    }

    .touch-zoom-btn:active {
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    /* Mobile-friendly context menus - Comic Style */
    #panelContextMenu,
    #bumperContextMenu {
      min-width: 250px !important;
      border-radius: 2px !important;
      border: 2px solid #000 !important;
      box-shadow: 4px 4px 0px 0px rgba(0,0,0,1) !important;
      overflow: hidden;
    }

    #panelContextMenu > div,
    #bumperContextMenu > div,
    .context-menu-item {
      padding: 14px 16px !important;
      font-size: 14px !important;
      font-family: 'Permanent Marker', cursive !important;
      min-height: 48px;
      display: flex;
      align-items: center;
      border-bottom: 1px solid #444;
    }

    /* Mobile hint text */
    .mobile-hint {
      display: block;
      padding: 10px 16px;
      background: rgba(16, 185, 129, 0.15);
      border: 2px solid var(--primary);
      border-radius: 2px;
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--primary);
    }

    /* Hide desktop hints, show mobile hints */
    .hint:not(.mobile-hint) {
      display: none;
    }

  </style>
</head>
<body>
<!-- Custom Panel Modal -->
<div id="customPanelModal" class="modal-overlay">
  <div class="modal-dialog">
    <div class="modal-header">
      <h2 class="modal-title" id="customPanelModalTitle">Add Custom Panel</h2>
      <button class="modal-close" onclick="closeCustomPanelModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="modal-input-group">
        <label>Panel Brand</label>
        <input type="text" id="customPanelBrand" placeholder="e.g., ROE Visual">
      </div>
      
      <div class="modal-input-group">
        <label>Panel Name</label>
        <input type="text" id="customPanelName" placeholder="e.g., Black Pearl BP2">
      </div>
      
      <div class="modal-input-group">
        <label>Pixel Pitch (mm)</label>
        <input type="number" id="customPanelPixelPitch" step="0.01" placeholder="e.g., 2.84">
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>Panel Width (mm)</label>
          <input type="number" id="customPanelWidth" step="0.1" placeholder="e.g., 500">
        </div>
        <div class="modal-input-group">
          <label>Panel Height (mm)</label>
          <input type="number" id="customPanelHeight" step="0.1" placeholder="e.g., 500">
        </div>
      </div>
      
      <div class="modal-input-group">
        <label>Panel Depth (mm)</label>
        <input type="number" id="customPanelDepth" step="0.1" placeholder="e.g., 90">
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>Resolution Width (px)</label>
          <input type="number" id="customPanelResX" placeholder="e.g., 176">
        </div>
        <div class="modal-input-group">
          <label>Resolution Height (px)</label>
          <input type="number" id="customPanelResY" placeholder="e.g., 176">
        </div>
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>Max Power (W)</label>
          <input type="number" id="customPanelPowerMax" step="1" placeholder="e.g., 250">
        </div>
        <div class="modal-input-group">
          <label>Avg Power (W)</label>
          <input type="number" id="customPanelPowerAvg" step="1" placeholder="e.g., 125">
        </div>
      </div>
      
      <div class="modal-input-group">
        <label>Brightness (nits)</label>
        <input type="number" id="customPanelBrightness" placeholder="e.g., 5000">
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>Max Panels Hanging</label>
          <input type="number" id="customPanelMaxHanging" placeholder="e.g., 20">
        </div>
        <div class="modal-input-group">
          <label>Max Panels Stacking</label>
          <input type="number" id="customPanelMaxStacking" placeholder="e.g., 12">
        </div>
      </div>
      
      <div class="modal-input-group">
        <label>Panel Weight (kg)</label>
        <input type="number" id="customPanelWeight" step="0.1" placeholder="e.g., 8.5">
      </div>
      
      <div class="checkbox-group">
        <input type="checkbox" id="customPanelRemovableFrame" onchange="updateFrameWeightFields()">
        <label for="customPanelRemovableFrame">Has Removable Frame</label>
      </div>
      
      <div id="frameWeightFields" style="display: none;">
        <div class="modal-input-row">
          <div class="modal-input-group">
            <label>Frame Weight (kg)</label>
            <input type="number" id="customPanelFrameWeight" step="0.1" placeholder="e.g., 1.2">
          </div>
          <div class="modal-input-group">
            <label>Weight Without Frame (kg)</label>
            <input type="number" id="customPanelWeightNoFrame" step="0.1" placeholder="e.g., 7.3">
          </div>
        </div>
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>1W Bumper Weight (lbs)</label>
          <input type="number" id="customPanel1wBumper" step="0.1" placeholder="e.g., 5.5">
        </div>
        <div class="modal-input-group">
          <label>2W Bumper Weight (lbs)</label>
          <input type="number" id="customPanel2wBumper" step="0.1" placeholder="e.g., 8.8">
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn-secondary" onclick="closeCustomPanelModal()">Cancel</button>
      <button class="btn-primary" onclick="saveCustomPanel()">Save Panel</button>
    </div>
  </div>
</div>

<!-- Custom Processor Modal -->
<div id="customProcessorModal" class="modal-overlay">
  <div class="modal-dialog">
    <div class="modal-header">
      <h2 class="modal-title" id="customProcessorModalTitle">Add Custom Processor</h2>
      <button class="modal-close" onclick="closeCustomProcessorModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div class="modal-input-group">
        <label>Processor Name</label>
        <input type="text" id="customProcessorName" placeholder="e.g., My Custom Processor">
      </div>
      
      <div class="modal-input-row">
        <div class="modal-input-group">
          <label>Number of 10G Ports</label>
          <input type="number" id="customProcessor10gPorts" placeholder="e.g., 4" value="0">
        </div>
        <div class="modal-input-group">
          <label>Number of 1G Ports</label>
          <input type="number" id="customProcessor1gPorts" placeholder="e.g., 8" value="0">
        </div>
      </div>
      
      <div class="modal-input-group">
        <label>Max Pixels Per Port (1G)</label>
        <input type="number" id="customProcessorPixelsPer1g" placeholder="e.g., 525000">
        <div class="hint">Base capacity for 60Hz @ 8-bit</div>
      </div>
      
      <div class="modal-input-group">
        <label>Max Pixels Per Port (10G)</label>
        <input type="number" id="customProcessorPixelsPer10g" placeholder="e.g., 2250000">
        <div class="hint">Optional - only if processor has 10G ports</div>
      </div>
    </div>
    <div class="modal-footer">
      <button class="btn-secondary" onclick="closeCustomProcessorModal()">Cancel</button>
      <button class="btn-primary" onclick="saveCustomProcessor()">Save Processor</button>
    </div>
  </div>
</div>

<!-- Manage Custom Items Modal -->
<div id="manageCustomModal" class="modal-overlay">
  <div class="modal-dialog">
    <div class="modal-header">
      <h2 class="modal-title" id="manageCustomModalTitle">Manage Custom Items</h2>
      <button class="modal-close" onclick="closeManageCustomModal()">&times;</button>
    </div>
    <div class="modal-body">
      <div id="manageCustomContent"></div>
    </div>
    <div class="modal-footer">
      <button class="btn-primary" onclick="closeManageCustomModal()">Done</button>
    </div>
  </div>
</div>

<!-- Mobile Header -->
<header class="mobile-header">
  <h1>LED CALCULATOR</h1>
  <div class="mobile-header-actions">
    <button class="mobile-header-btn" onclick="document.getElementById('loadConfigInput').click()" title="Load Config">
      <span class="material-symbols-outlined">folder</span>
    </button>
    <button class="mobile-header-btn" onclick="saveConfiguration()" title="Save Config">
      <span class="material-symbols-outlined">save</span>
    </button>
    <button class="mobile-header-btn" onclick="toggleMobileMenu()" title="Menu">
      <span class="material-symbols-outlined">menu</span>
    </button>
  </div>
</header>

<!-- Mobile Menu Overlay -->
<div id="mobileMenuOverlay" class="mobile-menu-overlay" onclick="closeMobileMenu()">
  <div class="mobile-menu" onclick="event.stopPropagation()">
    <div class="mobile-menu-header">
      <span>Settings</span>
      <button class="mobile-menu-close" onclick="closeMobileMenu()">&times;</button>
    </div>
    <div class="mobile-menu-content">
      <div class="mobile-menu-section">
        <div class="mobile-menu-label">Configuration</div>
        <input type="text" id="configName" placeholder="Config name..." style="margin-bottom: 12px;">
        <button class="mobile-menu-btn" onclick="saveConfiguration(); closeMobileMenu();">ðŸ’¾ Save Configuration</button>
        <button class="mobile-menu-btn" onclick="document.getElementById('loadConfigInput').click()">ðŸ“‚ Load Configuration</button>
        <input type="file" id="loadConfigInput" accept=".ledconfig" style="display: none;" onchange="loadConfiguration(event); closeMobileMenu();">
        <button id="btnExportPDF" class="mobile-menu-btn" onclick="closeMobileMenu();">ðŸ“„ Export PDF</button>
      </div>
      <div class="mobile-menu-section">
        <div class="mobile-menu-label">Custom Items</div>
        <button class="mobile-menu-btn" onclick="openCustomPanelModal(); closeMobileMenu();">+ Add Custom Panel</button>
        <button class="mobile-menu-btn" onclick="openCustomProcessorModal(); closeMobileMenu();">+ Add Custom Processor</button>
        <button class="mobile-menu-btn" onclick="openManageCustomModal('panels'); closeMobileMenu();">Manage Custom Items</button>
      </div>
      <div class="mobile-menu-section">
        <div class="mobile-menu-label">App Info</div>
        <div class="mobile-menu-info">LED Wall Calculator - Mobile v1</div>
        <div class="mobile-menu-info">Â© 2025 Gabriel Labrecque</div>
        <button class="mobile-menu-btn install-btn" id="installPwaBtn" style="display: none;" onclick="installPwa()">ðŸ“² Install App</button>
      </div>
    </div>
  </div>
</div>

<!-- Legacy page header (hidden on mobile) -->
<div class="page-header desktop-only">
  <div>
    <!-- Title and description hidden - they're in the background image -->
  </div>
  <div class="header-buttons-row">
    <div class="config-buttons">
      <button class="config-btn save" onclick="saveConfiguration()">ðŸ’¾ Save</button>
      <button class="config-btn load" onclick="document.getElementById('loadConfigInput').click()">ðŸ“‚ Load</button>
    </div>
  </div>
</div>


  <!-- Screen Tabs Container -->
  <div id="screenTabsContainer"></div>

  <!-- Screen Rename Modal -->
  <div id="screenRenameModal" class="modal-overlay">
    <div class="modal-dialog" style="max-width: 400px;">
      <div class="modal-header">
        <h2 class="modal-title">Edit Screen</h2>
        <button class="modal-close" onclick="closeScreenRenameModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="modal-input-group">
          <label>Screen Name</label>
          <input type="text" id="screenRenameInput" placeholder="e.g., Main IMAG">
        </div>
        <div class="modal-input-group">
          <label>Primary Color</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="color" id="screenColorInput" style="width: 60px; height: 40px; border: 1px solid #444; border-radius: 4px; background: #2a2a2a; cursor: pointer;">
            <span id="screenColorPreview" style="flex: 1; padding: 8px 12px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; font-family: monospace; font-size: 12px;"></span>
          </div>
        </div>
        <div class="modal-input-group">
          <label>Secondary Color</label>
          <div style="display: flex; gap: 10px; align-items: center;">
            <input type="color" id="screenColor2Input" style="width: 60px; height: 40px; border: 1px solid #444; border-radius: 4px; background: #2a2a2a; cursor: pointer;">
            <span id="screenColor2Preview" style="flex: 1; padding: 8px 12px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; font-family: monospace; font-size: 12px;"></span>
          </div>
          <div class="hint">Panels alternate between primary and secondary colors in Standard Layout and Canvas View</div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" onclick="closeScreenRenameModal()">Cancel</button>
        <button class="btn-primary" onclick="saveScreenRename()">Save</button>
      </div>
    </div>
  </div>

  <div class="main-container">
    <div class="two-column-layout">
      
      <!-- LEFT COLUMN -->
      <div>
        
        <!-- Panel Type -->
        <div class="section-box">
          <div class="section-title">Panel Type</div>
          <label style="max-width: 280px; margin-bottom: 0;">
            <select id="panelType">
              <option value="BP2_V2">ROE Black Pearl BP2 V2</option>
              <option value="CB5_MKII">ROE Carbon CB5 MKII</option>
              <option value="CB5_MKII_HALF">ROE Carbon CB5 MKII Half Panel</option>
              <option value="MC7H">ROE MC7H</option>
              <option value="BO3">ROE Black Onyx BO3</option>
              <option value="BM4_MATTE">ROE Black Marble BM4 â€“ MATTE</option>
              <option value="DM2_6">ROE DM2.6</option>
              <option value="INFILED_AMT8_3">INFiLED AMT 8.3</option>
            </select>
          </label>
        </div>

        <!-- CB5 Half Panel Row Toggle (only visible when CB5 MKII is selected) -->
        <div id="cb5HalfPanelToggle" style="display: none; margin-top: 8px;">
          <div class="toggle-group">
            <button type="button" class="toggle-btn" id="addCB5HalfRowBtn" onclick="toggleCB5HalfRow()">+ Half Panel Row</button>
          </div>
        </div>

        <!-- Connecting Plates Section (CB5 MKII / DM2.6) -->
        <div id="connectingPlatesSection" style="display: none; margin-top: 8px;">
          <div class="section-box">
            <div class="section-title">Panel Connection Method</div>
            
            <!-- CB5 MKII can choose -->
            <div id="cb5ConnectionChoice" style="display: none;">
              <div class="toggle-group">
                <button type="button" class="toggle-btn active" id="connectionAirframeBtn" onclick="setConnectionMethod('airframe')">Air Frame</button>
                <button type="button" class="toggle-btn" id="connectionPlatesBtn" onclick="setConnectionMethod('plates')">Plates</button>
              </div>
            </div>
            
            <!-- DM2.6 always uses plates -->
            <div id="dm26ConnectionInfo" style="display: none;">
              <div class="hint" style="color: #4a9eff; font-weight: 500;">
                â„¹ DM2.6 panels use connecting plates only
              </div>
            </div>
            
            <!-- Plate Weight Inputs (hidden - now auto-calculated) -->
            <div id="plateWeightInputs" style="display: none;">
              <!-- Plate weights are now automatically calculated:
                   2-Way Plate: 0.5 kg each
                   4-Way Plate: 0.8 kg each
              -->
            </div>
          </div>
        </div>

        <!-- Dimensions Section -->
        <div class="section-box">
          <div class="section-title">Dimensions</div>
          
          <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 8px; flex-wrap: wrap;">
            <div class="toggle-group">
              <button type="button" class="toggle-btn active" id="dimModePanelsBtn" onclick="setDimensionMode('panels')">Panels</button>
              <button type="button" class="toggle-btn" id="dimModeSizeBtn" onclick="setDimensionMode('size')">Size</button>
            </div>
            
            <!-- Unit Toggles -->
            <div style="display: flex; align-items: center; gap: 12px;">
              <div style="display: flex; align-items: center;">
                <span class="toggle-label">Units:</span>
                <div class="toggle-group">
                  <button type="button" class="toggle-btn active" id="unitImperial" onclick="setUnitSystem('imperial')">Imperial</button>
                  <button type="button" class="toggle-btn" id="unitMetric" onclick="setUnitSystem('metric')">Metric</button>
                </div>
              </div>
            </div>
          </div>

          <div id="panelCountInputs">
            <div class="two-inputs" style="max-width: 200px;">
              <label>
                <span>Panels Wide</span>
                <input type="number" id="panelsWide" min="1">
              </label>
              <label>
                <span>Panels High</span>
                <input type="number" id="panelsHigh" min="1">
              </label>
            </div>
          </div>

          <div id="wallSizeInputs" style="display: none;">
            <div class="two-inputs" style="max-width: 200px;">
              <label>
                <span>Wall Width</span>
                <input type="number" id="wallWidth" min="0.1" step="0.01">
              </label>
              <label>
                <span>Wall Height</span>
                <input type="number" id="wallHeight" min="0.1" step="0.01">
              </label>
            </div>
          </div>
        </div>

        <!-- Power Section -->
        <div class="section-box">
          <div class="section-title">Power</div>
          
          <div class="compact-row" style="margin-bottom: 8px;">
            <label style="flex: 0 0 70px;">
              <span>Voltage</span>
              <input type="number" id="voltage" value="208">
            </label>
            <label style="flex: 0 0 70px;">
              <span>Breaker</span>
              <input type="number" id="breaker" value="20">
            </label>
            <label style="flex: 0 0 90px;">
              <span>Phase</span>
              <select id="phase">
                <option value="1">1-phase</option>
                <option value="3" selected>3-phase</option>
              </select>
            </label>
          </div>

          <div class="compact-row">
            <label style="flex: 0 0 100px;">
              <span>Power Basis</span>
              <select id="powerType">
                <option value="max" selected>Max</option>
                <option value="avg">Average</option>
              </select>
            </label>
            <label style="flex: 0 0 100px;">
              <span>Max/Circuit</span>
              <input type="number" id="maxPanelsPerCircuit" min="1" step="1" placeholder="Auto">
            </label>
          </div>
        </div>

        <!-- Data Section -->
        <div class="section-box">
          <div class="section-title">Data</div>
          
          <div class="compact-row" style="margin-bottom: 8px;">
            <label style="flex: 0 0 160px;">
              <span>Processor</span>
              <select id="processor">
                <option value="Brompton_SX40">Brompton SX40</option>
                <option value="Brompton_S8">Brompton S8</option>
                <option value="Brompton_M2">Brompton M2</option>
                <option value="Brompton_S4">Brompton S4</option>
                <option value="Brompton_T1">Brompton T1</option>
                <option value="Brompton_SQ200">Brompton SQ200</option>
                <option value="NovaStar_MX40_Pro">NovaStar MX40 Pro</option>
              </select>
            </label>
            <label style="flex: 0 0 75px;">
              <span>Frame Rate</span>
              <select id="frameRate">
                <option value="24">24 Hz</option>
                <option value="25">25 Hz</option>
                <option value="30">30 Hz</option>
                <option value="50">50 Hz</option>
                <option value="60" selected>60 Hz</option>
              </select>
            </label>
            <label style="flex: 0 0 65px;">
              <span>Bit Depth</span>
              <select id="bitDepth">
                <option value="8" selected>8 bit</option>
                <option value="10">10 bit</option>
                <option value="12">12 bit</option>
              </select>
            </label>
          </div>
          
          <div class="compact-row" style="margin-bottom: 8px;">
            <label style="flex: 0 0 70px;">
              <span>Max/Data</span>
              <input type="number" id="maxPanelsPerData" min="1" step="1" placeholder="Auto">
            </label>
            <label style="flex: 0 0 170px;">
              <span>Data Direction</span>
              <select id="dataStartDir">
                <option value="top">Topâ†’Bottom</option>
                <option value="bottom">Bottomâ†’Top</option>
                <option value="all_top">All from Top</option>
                <option value="all_bottom">All from Bottom</option>
              </select>
            </label>
          </div>

          <div style="display: flex; gap: 8px; align-items: center;">
            <span class="toggle-label">Options:</span>
            <div class="toggle-group">
              <button type="button" class="toggle-btn active" id="showArrowsBtn" onclick="toggleShowArrows()">Arrows</button>
              <button type="button" class="toggle-btn active" id="redundancyBtn" onclick="toggleRedundancy()">Data Redundancy</button>
              <button type="button" class="toggle-btn" id="processorRedundancyBtn" onclick="toggleProcessorRedundancy()">Processor Redundancy</button>
            </div>
          </div>
        </div>

      </div>

      <!-- RIGHT COLUMN -->
      <div>
        
        <!-- Structure Section -->
        <div class="section-box">
          <div class="section-title">Structure</div>
          
          <div class="compact-row" style="margin-bottom: 8px;">
            <label style="flex: 0 0 120px; margin-bottom: 0;">
              <span>Config Type</span>
              <select id="structureType">
                <option value="hanging">Hanging</option>
                <option value="ground">Ground Stack</option>
              </select>
            </label>
            <!-- Bumper Toggle -->
            <div style="padding-top: 16px;">
              <div class="toggle-group">
                <button type="button" class="toggle-btn active" id="useBumpersBtn" onclick="toggleUseBumpers()">Bumpers</button>
              </div>
            </div>
            <!-- 4-Way Bumper Option (CB5 only) -->
            <div id="fourWayBumperOption" style="display: none; padding-top: 16px;">
              <div class="toggle-group">
                <button type="button" class="toggle-btn" id="use4WayBumpersBtn" onclick="toggle4WayBumpers()">4-Way Bumpers</button>
              </div>
            </div>
          </div>
          
          <!-- Bumper Controls -->
          <div id="bumperControls">
            <div class="hint" style="font-size: 11px; margin-bottom: 0;">
              Long-press bumpers to edit â€¢ Auto-distributes by width
            </div>
          </div>
          
          <!-- Weight Display -->
          <div id="weightDisplay" class="weight-display" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 8px; color: #4a9eff;">Weight Distribution</div>
            <div id="weightContent"></div>
          </div>
        </div>
        
        <!-- Cabling Section -->
        <div class="section-box">
          <div class="section-title">Cabling</div>
          
          <div class="compact-row" style="margin-bottom: 8px;">
            <label style="flex: 0 0 90px;">
              <span>Trim Height</span>
              <input type="number" id="trimHeight" min="0" step="0.1" value="20">
            </label>
            <label style="flex: 0 0 90px;">
              <span>Wall to Floor</span>
              <input type="number" id="wallToFloor" min="0" step="0.1" value="5">
            </label>
          </div>
          
          <div class="compact-row" style="margin-bottom: 8px;">
            <label style="flex: 0 0 90px;">
              <span>Distro to Wall</span>
              <input type="number" id="distroToWall" min="0" step="0.1" value="10">
            </label>
            <label style="flex: 0 0 90px;">
              <span>Proc to Wall</span>
              <input type="number" id="processorToWall" min="0" step="0.1" value="15">
            </label>
          </div>
          
          <div class="compact-row">
            <label style="flex: 0 0 90px; margin-bottom: 0;">
              <span>FOH to Proc</span>
              <input type="number" id="fohToProcessor" min="0" step="0.1" value="50">
            </label>
          </div>
        </div>
        
        
      </div>

    </div>

    <div id="results" class="result">Configure your LED wall above - results update automatically.</div>
    <div id="specWarning" class="warn"></div>
    
    <div class="layout-container" id="standardContainer" style="display:none;">
      <div class="layout-title">
        <span>Standard Layout</span>
        <div class="undo-redo-buttons">
          <button class="undo-redo-btn" id="undoBtn" onclick="undo()" title="Undo">â†¶ Undo</button>
          <button class="undo-redo-btn" id="redoBtn" onclick="redo()" title="Redo">â†· Redo</button>
        </div>
      </div>
      <div class="mobile-hint">Tap panels to select â€¢ Long-press for options (delete, assign circuit/data)</div>
      <canvas id="standardCanvas"></canvas>
    </div>
    
    <div class="layout-container" id="powerContainer" style="display:none;">
      <div class="layout-title">Power Layout</div>
      <canvas id="powerCanvas"></canvas>
    </div>
    
    <div class="layout-container" id="dataContainer" style="display:none;">
      <div class="layout-title">Data Layout</div>
      <canvas id="dataCanvas"></canvas>
    </div>
    
    <div class="layout-container" id="structureContainer" style="display:none;">
      <div class="layout-title">
        <span>Structure Layout</span>
      </div>
      
      <!-- Manual Mode Toggle -->
      <div class="structure-mode-toggle">
        <button type="button" class="toggle-btn" id="manualBumperToggle" onclick="toggleManualBumperMode()">
          Manually Distribute Bumpers
        </button>
        <div class="undo-redo-buttons" id="structureUndoRedo" style="display: none;">
          <button class="undo-redo-btn" id="structureUndoBtn" onclick="structureUndo()" title="Undo (Ctrl+Z)">â†¶ Undo</button>
          <button class="undo-redo-btn" id="structureRedoBtn" onclick="structureRedo()" title="Redo (Ctrl+Y)">â†· Redo</button>
        </div>
        <span class="structure-mode-hint" id="structureModeHint">Auto-distribution active</span>
      </div>
      
      <!-- Selection Info (shown in manual mode) -->
      <div class="structure-selection-info" id="structureSelectionInfo">
        <strong>Manual Mode:</strong> Tap to select bumpers. Long-press for options.
      </div>
      
      <!-- Structure layout with canvas and info panel side by side -->
      <div class="structure-layout-wrapper">
        <div class="structure-canvas-area">
          <canvas id="structureCanvas"></canvas>
        </div>
        
        <!-- Info Panel with Weights and Plates -->
        <div class="structure-info-panel" id="structureInfoPanel" style="display: none;">
          <!-- Pickup Weights -->
          <div class="structure-info-box weights" id="structureWeightsBox">
            <div class="structure-info-title weights">Pickup Weights</div>
            <div id="structureWeightsContent"></div>
          </div>
          
          <!-- Connecting Plates -->
          <div class="structure-info-box plates" id="structurePlatesBox" style="display: none;">
            <div class="structure-info-title plates">Connecting Plates</div>
            <div id="structurePlatesContent"></div>
          </div>
          
          <!-- Ground Support Hardware -->
          <div class="structure-info-box ground-support" id="structureGroundSupportBox" style="display: none;">
            <div class="structure-info-title ground-support">Ground Support Hardware</div>
            <div id="structureGroundSupportContent"></div>
          </div>
          
          <!-- Total Structure Weight -->
          <div class="structure-info-box" id="structureTotalWeightBox" style="display: none; border-left: 3px solid #FFD700;">
            <div class="structure-info-title" style="color: #FFD700;">Total Structure Weight</div>
            <div id="structureTotalWeightContent"></div>
          </div>
        </div>
      </div>
      
      <!-- Context Menu for Bumpers -->
      <div id="bumperContextMenu" style="display:none; position:fixed; background:#2a2a2a; border:1px solid #555; border-radius:4px; padding:4px 0; box-shadow:0 2px 8px rgba(0,0,0,0.5); z-index:10000;">
        <div class="context-menu-item" onclick="changeBumperType('1w')">Change to 1W</div>
        <div class="context-menu-item" onclick="changeBumperType('2w')">Change to 2W</div>
        <div class="context-menu-item" onclick="deleteBumper()" style="color:#ff6b6b;">Delete Bumper</div>
      </div>
    </div>
    
    <!-- Layouts Toggle Bar (for mobile layouts view) -->
    <div id="layoutsTogglesContainer" class="layouts-toggle-container" style="display: none;">
      <div class="toggle-group">
        <button type="button" class="toggle-btn active" id="layoutToggleStandard" onclick="showMobileLayout('standard')">Standard</button>
        <button type="button" class="toggle-btn" id="layoutTogglePower" onclick="showMobileLayout('power')">Power</button>
        <button type="button" class="toggle-btn" id="layoutToggleData" onclick="showMobileLayout('data')">Data</button>
        <button type="button" class="toggle-btn" id="layoutToggleStructure" onclick="showMobileLayout('structure')">Structure</button>
      </div>
    </div>

    <div class="layout-container" id="canvasContainer" style="display:none;">
      <div class="layout-title">
        <span>Canvas View</span>
        <div class="canvas-zoom-controls">
          <button class="zoom-btn" onclick="zoomCanvas(-0.25)" title="Zoom Out">âˆ’</button>
          <input type="number" id="canvasZoomInput" value="100" min="50" max="500" step="10" onchange="setCanvasZoom(this.value)" title="Enter zoom percentage">
          <span class="zoom-percent">%</span>
          <button class="zoom-btn" onclick="zoomCanvas(0.25)" title="Zoom In">+</button>
          <button class="zoom-btn" onclick="resetCanvasZoom()" title="Reset Zoom">Reset</button>
        </div>
        <div class="undo-redo-buttons">
          <button class="undo-redo-btn" id="canvasUndoBtn" onclick="undoCanvasMove()" title="Undo Canvas Move">â†¶ Undo</button>
          <button class="undo-redo-btn" id="canvasRedoBtn" onclick="redoCanvasMove()" title="Redo Canvas Move">â†· Redo</button>
        </div>
    
      </div>
      
      <div class="canvas-with-options" style="flex-direction: column;">
        <!-- Canvas on the left -->
        <div>
          <div id="canvasViewWrapper" style="width: 100%; padding-bottom: 56.25%; /* 16:9 */ height: 0; overflow: hidden; border: 1px solid #444; background: #000; position: relative;">
            <div id="canvasViewport" style="position: absolute; top:0; left:0; width:100%; height:100%; transform-origin: 0 0; cursor: grab;">
              <canvas id="canvasView" style="display: block; width:100%; height:100%;"></canvas>
            </div>
          </div>
          <div style="color:#888; margin-top:8px; font-size:11px;">Pinch to zoom â€¢ Drag to pan when zoomed â€¢ Drag screens to reposition</div>
          <div style="color:#ccc; margin-top:4px; font-size:13px;" id="canvasInfo"></div>
        </div>
        
        <!-- Canvas Options on the right -->
        <div class="section-box" style="min-width: 100%; margin-bottom: 0;">
          <div class="section-title">Canvas Options</div>
           <div class="section-content">
          <label style="margin-bottom: 8px;">
            <span>Canvas Size</span>
            <select id="canvasSize">
              <option value="4K_UHD" selected="">4K UHD (3840x2160)</option>
              <option value="4K_DCI">4K DCI (4096x2160)</option>
              <option value="HD">HD (1920x1080)</option>
              <option value="custom">Custom</option>
            </select>
          </label>

          <div id="customCanvasInputs" style="display: none; margin-bottom: 8px;">
            <div class="two-inputs">
              <label style="margin-bottom: 0;">
                <span>Width (px)</span>
                <input type="number" id="customCanvasWidth" min="1">
              </label>
              <label style="margin-bottom: 0;">
                <span>Height (px)</span>
                <input type="number" id="customCanvasHeight" min="1">
              </label>
            </div>
          </div>
          
          <div style="display: flex; gap: 8px; margin-bottom: 8px;">
            <label style="margin-bottom: 0;">
              <span>X Pos</span>
              <input type="number" id="canvasX" value="0" min="0" style="width: 70px; padding: 6px;">
            </label>
            <label style="margin-bottom: 0;">
              <span>Y Pos</span>
              <input type="number" id="canvasY" value="0" min="0" style="width: 70px; padding: 6px;">
            </label>
          </div>
          
          <div style="display: flex; gap: 16px; align-items: center; margin-bottom: 8px;">
            <div class="toggle-group">
              <button type="button" class="toggle-btn active" id="snapModeBtn" onclick="toggleSnapMode()">Snap</button>
            </div>
            <label style="margin-bottom: 0;">
              <span style="font-size: 11px;">Fine (px)</span>
              <input type="number" id="arrowKeyIncrement" value="10" min="1" max="100" style="width: 55px; padding: 6px;">
            </label>
          </div>
          
          <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
            <select id="canvasExportFormat" style="width: 70px; padding: 6px;">
              <option value="png" selected="">PNG</option>
              <option value="jpeg">JPEG</option>
              <option value="pdf">PDF</option>
            </select>
            <input type="text" id="canvasExportFilename" placeholder="Filename..." style="flex: 1; padding: 6px 10px; font-size: 12px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px;">
            <button id="btnExportCanvas" class="config-btn" style="background: #E67E22; border-color: #E67E22;">ðŸ“· Export</button>
          </div>
          
          <!-- Screen Visibility Toggles -->
          <div id="canvasScreenToggles"></div>
        </div>
        </div>
      </div>
    </div>
    <!-- Gear List Section -->
    <div class="layout-container" id="gearListContainer" style="display:none;">
      <div class="layout-title">Gear List</div>
      <div id="gearListContent" style="color: #e0e0e0; line-height: 1.8;"></div>
    </div>

  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
console.log('JavaScript loaded - v61');

// Global unit settings
let displayLengthUnit = 'ft'; // 'ft' or 'm'
let displayWeightUnit = 'lbs'; // 'lbs' or 'kg'

// Unit conversion constants
const FT_TO_M = 0.3048;
const M_TO_FT = 3.28084;
const LBS_TO_KG = 0.453592;
const KG_TO_LBS = 2.20462;

// Unit system toggle function (Imperial = ft/lbs, Metric = m/kg)
function setUnitSystem(system) {
  if(system === 'imperial') {
    displayLengthUnit = 'ft';
    displayWeightUnit = 'lbs';
  } else {
    displayLengthUnit = 'm';
    displayWeightUnit = 'kg';
  }
  
  // Update button states
  document.getElementById('unitImperial').classList.toggle('active', system === 'imperial');
  document.getElementById('unitMetric').classList.toggle('active', system === 'metric');
  
  // Recalculate to update all displays
  calculate();
  
  // Update structure view weights
  if(bumpers.length > 0) {
    updatePickupWeightSummary();
  }
}

// Unit toggle functions (kept for compatibility)
function setLengthUnit(unit) {
  displayLengthUnit = unit;
  
  // Update button states if elements exist
  const unitImperial = document.getElementById('unitImperial');
  const unitMetric = document.getElementById('unitMetric');
  if(unitImperial && unitMetric) {
    unitImperial.classList.toggle('active', unit === 'ft');
    unitMetric.classList.toggle('active', unit === 'm');
  }
  
  // Recalculate to update all displays
  calculate();
}

function setWeightUnit(unit) {
  displayWeightUnit = unit;
  
  // Update button states if elements exist
  const unitImperial = document.getElementById('unitImperial');
  const unitMetric = document.getElementById('unitMetric');
  if(unitImperial && unitMetric) {
    unitImperial.classList.toggle('active', unit === 'lbs');
    unitMetric.classList.toggle('active', unit === 'kg');
  }
  
  // Recalculate to update all displays
  calculate();
  
  // Update structure view weights
  if(bumpers.length > 0) {
    updatePickupWeightSummary();
  }
}

// Helper functions for formatting values with current units
function formatLength(meters, decimals = 2) {
  if(displayLengthUnit === 'ft') {
    return (meters * M_TO_FT).toFixed(decimals) + ' ft';
  } else {
    return meters.toFixed(decimals) + ' m';
  }
}

function formatWeight(kg, decimals = 2) {
  if(displayWeightUnit === 'lbs') {
    return (kg * KG_TO_LBS).toFixed(decimals) + ' lbs';
  } else {
    return kg.toFixed(decimals) + ' kg';
  }
}

function formatWeightValue(kg, decimals = 0) {
  // Returns just the number without unit label
  if(displayWeightUnit === 'lbs') {
    return (kg * KG_TO_LBS).toFixed(decimals);
  } else {
    return kg.toFixed(decimals);
  }
}

function getWeightUnitLabel() {
  return displayWeightUnit;
}

function getLengthUnitLabel() {
  return displayLengthUnit;
}

// Dimension mode toggle
let currentDimensionMode = 'panels';
function setDimensionMode(mode) {
  currentDimensionMode = mode;
  document.getElementById('dimModePanelsBtn').classList.toggle('active', mode === 'panels');
  document.getElementById('dimModeSizeBtn').classList.toggle('active', mode === 'size');
  
  document.getElementById('panelCountInputs').style.display = mode === 'panels' ? 'block' : 'none';
  document.getElementById('wallSizeInputs').style.display = mode === 'size' ? 'block' : 'none';
  
  if(mode === 'panels') {
    syncFromPanels();
  } else {
    syncFromSize();
  }
  calculate();
}

// Show arrows toggle
let showArrowsEnabled = true;
function toggleShowArrows() {
  showArrowsEnabled = !showArrowsEnabled;
  document.getElementById('showArrowsBtn').classList.toggle('active', showArrowsEnabled);
  calculate();
}

// Redundancy toggle
let redundancyEnabled = true;
function toggleRedundancy() {
  redundancyEnabled = !redundancyEnabled;
  document.getElementById('redundancyBtn').classList.toggle('active', redundancyEnabled);
  calculate();
}

// Processor Redundancy toggle
let processorRedundancyEnabled = false;
function toggleProcessorRedundancy() {
  processorRedundancyEnabled = !processorRedundancyEnabled;
  document.getElementById('processorRedundancyBtn').classList.toggle('active', processorRedundancyEnabled);
  calculate();
}

// 4-way bumpers toggle
let use4WayBumpersEnabled = false;
function toggle4WayBumpers() {
  use4WayBumpersEnabled = !use4WayBumpersEnabled;
  document.getElementById('use4WayBumpersBtn').classList.toggle('active', use4WayBumpersEnabled);
  
  // Re-initialize bumpers
  initializeBumpers();
  calculate();
}

// Bumpers on/off toggle
function toggleUseBumpers() {
  useBumpers = !useBumpers;
  document.getElementById('useBumpersBtn').classList.toggle('active', useBumpers);
  
  // Show/hide bumper controls
  const bumperControls = document.getElementById('bumperControls');
  const fourWayOption = document.getElementById('fourWayBumperOption');
  const weightDisplay = document.getElementById('weightDisplay');
  
  if(useBumpers) {
    if(bumperControls) bumperControls.style.display = '';
    
    // Restore showTopBumper/showBottomBumper based on structure type
    const structureType = document.getElementById('structureType').value;
    if(structureType === 'hanging') {
      showTopBumper = true;
      showBottomBumper = false;
    } else {
      showTopBumper = false;
      showBottomBumper = true;
    }
    
    // Show 4-way option if CB5 panel
    const panelType = document.getElementById('panelType').value;
    const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
    if(fourWayOption && isCB5) {
      fourWayOption.style.display = 'block';
    }
    
    // Re-initialize bumpers when turned on
    initializeBumpers();
  } else {
    if(bumperControls) bumperControls.style.display = 'none';
    if(fourWayOption) fourWayOption.style.display = 'none';
    if(weightDisplay) weightDisplay.style.display = 'none';
    // Clear bumpers when turned off
    bumpers = [];
    showTopBumper = false;
    showBottomBumper = false;
  }
  
  // Redraw structure view and recalculate
  generateStructureLayout();
  calculate();
}

// Set bumpers state based on panel type
function updateBumpersForPanelType(panelType) {
  const allPanels = getAllPanels();
  const panel = allPanels[panelType];
  
  // Check if panel has uses_bumpers property set to false
  const panelUsesBumpers = panel && panel.uses_bumpers !== false;
  
  // Update state and UI
  useBumpers = panelUsesBumpers;
  document.getElementById('useBumpersBtn').classList.toggle('active', useBumpers);
  
  // Show/hide bumper controls
  const bumperControls = document.getElementById('bumperControls');
  const fourWayOption = document.getElementById('fourWayBumperOption');
  const weightDisplay = document.getElementById('weightDisplay');
  
  if(useBumpers) {
    if(bumperControls) bumperControls.style.display = '';
  } else {
    if(bumperControls) bumperControls.style.display = 'none';
    if(fourWayOption) fourWayOption.style.display = 'none';
    if(weightDisplay) weightDisplay.style.display = 'none';
    // Clear bumpers
    bumpers = [];
    showTopBumper = false;
    showBottomBumper = false;
  }
}

// Snap mode toggle
let snapModeEnabled = true;
function toggleSnapMode() {
  snapModeEnabled = !snapModeEnabled;
  document.getElementById('snapModeBtn').classList.toggle('active', snapModeEnabled);
}

// CB5 Half row toggle
let cb5HalfRowEnabled = false;
function toggleCB5HalfRow() {
  cb5HalfRowEnabled = !cb5HalfRowEnabled;
  document.getElementById('addCB5HalfRowBtn').classList.toggle('active', cb5HalfRowEnabled);

  // Update screen data so canvas view reflects the change
  if(typeof screens !== 'undefined' && screens[currentScreenId]) {
    screens[currentScreenId].data.addCB5HalfRow = cb5HalfRowEnabled;
  }

  updateSuggestedDataLimit(); // Update max/data placeholder when half panels toggled
  calculate();
}

// Connection method toggle
let connectionMethod = 'airframe';
function setConnectionMethod(method) {
  connectionMethod = method;
  document.getElementById('connectionAirframeBtn').classList.toggle('active', method === 'airframe');
  document.getElementById('connectionPlatesBtn').classList.toggle('active', method === 'plates');
  calculate();
}

// Compatibility getters - these mimic the old checkbox behavior
function isShowArrowsChecked() { return showArrowsEnabled; }
function isRedundancyChecked() { return redundancyEnabled; }
function isUse4WayBumpersChecked() { return use4WayBumpersEnabled; }
function isSnapModeChecked() { return snapModeEnabled; }
function isCB5HalfRowChecked() { return cb5HalfRowEnabled; }
function isConnectionPlates() { return connectionMethod === 'plates'; }

let lastLayoutMode = null;

// Interactive panel knockout state
let deletedPanels = new Set(); // stores "col,row" strings
let selectedPanels = new Set(); // stores "col,row" strings for multi-select
let customCircuitAssignments = new Map(); // stores "col,row" -> circuit number
let customDataLineAssignments = new Map(); // stores "col,row" -> data line number
let isDragging = false;
let dragStartX = 0;

// Canvas movement undo/redo state
let canvasMoveHistory = [];
let canvasMoveHistoryIndex = -1;
const MAX_CANVAS_HISTORY = 20;

// Structure view bumper state - NEW SYSTEM
let showTopBumper = false;
let showBottomBumper = false;
let useBumpers = true; // Toggle for enabling/disabling bumpers entirely
let manualBumperMode = false; // Toggle for manual bumper distribution mode
let selectedBumpers = new Set(); // Selected bumpers (by id) in structure view
let structureIsDragging = false;
let structureDragStartX = 0;
let structureDragStartY = 0;

// Structure view undo/redo
let structureHistory = [];
let structureHistoryIndex = -1;
const MAX_STRUCTURE_HISTORY = 30;

// Legacy bumper variables (for backward compatibility during migration)
let topBumper1wColumn = -1;
let bottomBumper1wColumn = -1;
let manualTopBumpers = [];
let manualBottomBumpers = [];

// Bumper tracking system - stores all placed bumpers with their properties
let bumpers = []; // Array of {id, type:'1w'|'2w'|'4w', position:'top'|'bottom', startCol, endCol, x, y, width, height}
let nextBumperId = 1;
let selectedBumper = null; // Currently selected bumper for editing
let hoveredBumper = null; // Bumper under mouse cursor

// Structure canvas interaction state
let structureCanvas = null;
let structureDraggingBumper = null; // Currently being dragged bumper
let structureOriginalImageData = null; // Store canvas state for quick restore
let dragStartY = 0;
let currentCanvas = null;
let currentPw = 0;
let currentPh = 0;
let panelSize = 50;

// Canvas view offset (for dragging the wall around the canvas)
let canvasOffsetX = 0;
let canvasOffsetY = 0;
let canvasZoomLevel = 1.0; // Zoom level for canvas view (1.0 = 100%)
let canvasPanX = 0; // Pan offset X
let canvasPanY = 0; // Pan offset Y
let isPanningCanvas = false;
let panStartX = 0;
let panStartY = 0;

// Context menu state
let contextMenuVisible = false;
let contextMenuX = 0;
let contextMenuY = 0;
let contextMenuBumper = null;


// Undo/Redo system
let undoHistory = [];
let redoHistory = [];
const MAX_HISTORY = 50;

function saveState() {
  const state = {
    deletedPanels: new Set(deletedPanels),
    selectedPanels: new Set(selectedPanels),
    customCircuitAssignments: new Map(customCircuitAssignments),
    customDataLineAssignments: new Map(customDataLineAssignments)
  };
  
  undoHistory.push(state);
  if(undoHistory.length > MAX_HISTORY) {
    undoHistory.shift();
  }
  
  // Clear redo history when new action is performed
  redoHistory = [];
  updateUndoRedoButtons();
}

function undo() {
  if(undoHistory.length === 0) return;
  
  // Save current state to redo history
  const currentState = {
    deletedPanels: new Set(deletedPanels),
    selectedPanels: new Set(selectedPanels),
    customCircuitAssignments: new Map(customCircuitAssignments),
    customDataLineAssignments: new Map(customDataLineAssignments)
  };
  redoHistory.push(currentState);
  
  // Restore previous state
  const previousState = undoHistory.pop();
  deletedPanels = new Set(previousState.deletedPanels);
  selectedPanels = new Set(previousState.selectedPanels);
  customCircuitAssignments = new Map(previousState.customCircuitAssignments);
  customDataLineAssignments = new Map(previousState.customDataLineAssignments);
  
  // Sync deleted panels to current screen data for canvas view
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.deletedPanels = new Set(deletedPanels);
  }
  
  // Regenerate all layouts without calling calculate (which would reset redo stack)
  generateLayout('standard');
  generateLayout('power');
  generateLayout('data');
  generateStructureLayout();
  
  // Update canvas view to reflect changes
  showCanvasView();
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
  
  updateUndoRedoButtons();
}

function redo() {
  if(redoHistory.length === 0) return;
  
  // Save current state to undo history
  const currentState = {
    deletedPanels: new Set(deletedPanels),
    selectedPanels: new Set(selectedPanels),
    customCircuitAssignments: new Map(customCircuitAssignments),
    customDataLineAssignments: new Map(customDataLineAssignments)
  };
  undoHistory.push(currentState);
  
  // Restore next state
  const nextState = redoHistory.pop();
  deletedPanels = new Set(nextState.deletedPanels);
  selectedPanels = new Set(nextState.selectedPanels);
  customCircuitAssignments = new Map(nextState.customCircuitAssignments);
  customDataLineAssignments = new Map(nextState.customDataLineAssignments);
  
  // Sync deleted panels to current screen data for canvas view
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.deletedPanels = new Set(deletedPanels);
  }
  
  // Regenerate all layouts without calling calculate (which would reset redo stack)
  generateLayout('standard');
  generateLayout('power');
  generateLayout('data');
  generateStructureLayout();
  
  // Update canvas view to reflect changes
  showCanvasView();
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
  
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  
  if(undoBtn) {
    undoBtn.disabled = undoHistory.length === 0;
  }
  if(redoBtn) {
    redoBtn.disabled = redoHistory.length === 0;
  }
}

// Resistor colors for POWER and DATA layouts only
const resistorColors = ['#964B00','#FF0000','#FFA500','#FFFF00','#008000','#0000FF','#8B00FF','#808080','#FFFFFF','#333333'];
// Standard layout colors - magenta, cyan, yellow, blue, green, red at 50% brightness
const standardColors = [
  '#800080',  // Magenta at 50% brightness
  '#008080',  // Cyan at 50% brightness
  '#808000',  // Yellow at 50% brightness
  '#000080',  // Blue at 50% brightness
  '#008000',  // Green at 50% brightness
  '#800000'   // Red at 50% brightness
];

// ----------- Specs (updated from spec sheet) -----------
const panels = {
  "BP2_V2": {brand:"ROE Visual", name:"Black Pearl BP2 V2", pixel_pitch_mm:2.84, width_m:0.5, height_m:0.5, depth_mm:90, res_x:176, res_y:176, weight_kg:9.35, power_max_w:190, power_avg_w:95, brightness_nits:1500, max_hanging:20, max_stacking:12, bumper_1w_lbs:7.38, bumper_2w_lbs:17.1, max_panels_per_circuit:8, max_panels_per_data:16, power_jumper_ft:"1'", data_jumper_ft:"1'", data_cross_jumper_ft:"2'", jumpers_builtin:false},
  "CB5_MKII": {brand:"ROE Visual", name:"Carbon CB5 MKII", pixel_pitch_mm:5.77, width_m:0.6, height_m:1.2, depth_mm:80, res_x:104, res_y:208, weight_kg:12.13, power_max_w:480, power_avg_w:240, brightness_nits:6000, max_hanging:12, max_stacking:5, bumper_1w_lbs:13.9, bumper_2w_lbs:27.5, bumper_4w_lbs:66.15, max_panels_per_circuit:3, max_panels_per_data:24, power_jumper_ft:null, data_jumper_ft:null, data_cross_jumper_ft:"3'", jumpers_builtin:true},
  "CB5_MKII_HALF": {brand:"ROE Visual", name:"Carbon CB5 MKII Half Panel", pixel_pitch_mm:5.77, width_m:0.6, height_m:0.6, depth_mm:79, res_x:104, res_y:104, weight_kg:6.69, power_max_w:250, power_avg_w:125, brightness_nits:6000, max_hanging:24, max_stacking:10, bumper_1w_lbs:13.9, bumper_2w_lbs:27.5, bumper_4w_lbs:66.15, max_panels_per_circuit:6, max_panels_per_data:48, power_jumper_ft:null, data_jumper_ft:null, data_cross_jumper_ft:"3'", jumpers_builtin:true},
  "MC7H": {brand:"ROE Visual", name:"MC7H", pixel_pitch_mm:7.5, width_m:0.6, height_m:0.6, depth_mm:90, res_x:80, res_y:80, weight_kg:14.8, power_max_w:420, power_avg_w:210, brightness_nits:5000, max_hanging:20, max_stacking:8, bumper_1w_lbs:15.44, bumper_2w_lbs:28.22, max_panels_per_circuit:4, max_panels_per_data:82, power_jumper_ft:null, data_jumper_ft:null, data_cross_jumper_ft:"3'", jumpers_builtin:true},
  "BO3": {brand:"ROE Visual", name:"Black Onyx BO3", pixel_pitch_mm:3.47, width_m:0.5, height_m:0.5, depth_mm:90, res_x:144, res_y:144, weight_kg:9.35, power_max_w:170, power_avg_w:85, brightness_nits:1500, max_hanging:20, max_stacking:8, bumper_1w_lbs:7.38, bumper_2w_lbs:17.1, max_panels_per_circuit:9, max_panels_per_data:25, power_jumper_ft:"1'", data_jumper_ft:"1'", data_cross_jumper_ft:"2'", jumpers_builtin:false},
  "BM4_MATTE": {brand:"ROE Visual", name:"Black Marble BM4 (Matte)", pixel_pitch_mm:4.76, width_m:0.61, height_m:0.61, depth_mm:140, res_x:128, res_y:128, weight_kg:16.0, power_max_w:280, power_avg_w:140, brightness_nits:2000, max_hanging:null, max_stacking:null, bumper_1w_lbs:null, bumper_2w_lbs:null, max_panels_per_circuit:5, max_panels_per_data:32, power_jumper_ft:"4'", data_jumper_ft:"4'", data_cross_jumper_ft:"4'", jumpers_builtin:false, uses_bumpers:false},
  "DM2_6": {brand:"ROE Visual", name:"DM2.6", pixel_pitch_mm:2.6, width_m:0.5, height_m:0.5, depth_mm:80, res_x:192, res_y:192, weight_kg:5.76, power_max_w:180, power_avg_w:90, brightness_nits:1500, max_hanging:20, max_stacking:12, bumper_1w_lbs:7.38, bumper_2w_lbs:17.1, max_panels_per_circuit:8, max_panels_per_data:14, power_jumper_ft:"1.5'", data_jumper_ft:"1.5'", data_cross_jumper_ft:"3'", jumpers_builtin:false},
  "INFILED_AMT8_3": {brand:"INFiLED", name:"AMT 8.3", pixel_pitch_mm:8.33, width_m:1.0, height_m:1.0, depth_mm:107, res_x:120, res_y:120, weight_kg:15.8, power_max_w:720, power_avg_w:360, brightness_nits:5000, max_hanging:18, max_stacking:18, bumper_1w_lbs:null, bumper_2w_lbs:null, max_panels_per_circuit:2, max_panels_per_data:36, power_jumper_ft:"1.5'", data_jumper_ft:"1.5'", data_cross_jumper_ft:"4'", jumpers_builtin:false}
};

const processors = {
  "Brompton_SX40": {name:"Brompton SX40", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, pixels_per_10g:9000000, total_pixels:9000000, outputs:"4 Ã— 10G trunks"},
  "Brompton_S8": {name:"Brompton S8", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, total_pixels:4500000, outputs:"8 Ã— 1G"},
  "Brompton_M2": {name:"Brompton M2", base_pixels_1g:500000, base_framerate:60, base_bitdepth:8, total_pixels:2000000, outputs:"4 Ã— 1G"},
  "Brompton_S4": {name:"Brompton S4", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, total_pixels:2000000, outputs:"4 Ã— 1G"},
  "Brompton_T1": {name:"Brompton T1", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, total_pixels:525000, outputs:"1 Ã— 1G"},
  "Brompton_SQ200": {name:"Brompton SQ200", base_pixels_1g:525000, base_framerate:60, base_bitdepth:8, total_pixels:9000000, outputs:"100Gâ†’10Gâ†’1G fanout"},
  "NovaStar_MX40_Pro": {name:"NovaStar MX40 Pro", base_pixels_1g:650000, base_framerate:60, base_bitdepth:8, total_pixels:8800000, outputs:"20 Ã— 1G + 4 Ã— 10G"}
};

// ==================== CUSTOM PANELS AND PROCESSORS SYSTEM v24 ====================

// Storage keys
const STORAGE_KEY_CUSTOM_PANELS = 'ledcalc_custom_panels';
const STORAGE_KEY_CUSTOM_PROCESSORS = 'ledcalc_custom_processors';

// Custom panels storage
let customPanels = {};
let customProcessors = {};

// Load custom data from localStorage
function loadCustomData() {
  try {
    const panelsData = localStorage.getItem(STORAGE_KEY_CUSTOM_PANELS);
    if(panelsData) {
      customPanels = JSON.parse(panelsData);
      console.log('Loaded custom panels:', Object.keys(customPanels).length);
    }
    
    const processorsData = localStorage.getItem(STORAGE_KEY_CUSTOM_PROCESSORS);
    if(processorsData) {
      customProcessors = JSON.parse(processorsData);
      console.log('Loaded custom processors:', Object.keys(customProcessors).length);
    }
  } catch(err) {
    console.error('Error loading custom data:', err);
  }
}

// Save custom data to localStorage
function saveCustomPanels() {
  try {
    localStorage.setItem(STORAGE_KEY_CUSTOM_PANELS, JSON.stringify(customPanels));
  } catch(err) {
    console.error('Error saving custom panels:', err);
    alert('Error saving custom panel data');
  }
}

function saveCustomProcessors() {
  try {
    localStorage.setItem(STORAGE_KEY_CUSTOM_PROCESSORS, JSON.stringify(customProcessors));
  } catch(err) {
    console.error('Error saving custom processors:', err);
    alert('Error saving custom processor data');
  }
}

// Get all panels (built-in + custom)
function getAllPanels() {
  return {...panels, ...customPanels};
}

// Get all processors (built-in + custom)
function getAllProcessors() {
  return {...processors, ...customProcessors};
}

// Load custom data from localStorage on startup
loadCustomData();

// Helper functions to get current selections
function getCurrentPanel() {
  const allPanels = getAllPanels();
  const panelType = document.getElementById('panelType')?.value;
  return panelType ? allPanels[panelType] : null;
}

function getCurrentProcessor() {
  const allProcessors = getAllProcessors();
  const processorType = document.getElementById('processor')?.value;
  return processorType ? allProcessors[processorType] : null;
}

// Update panel dropdowns
function updatePanelDropdowns() {
  const panelSelect = document.getElementById('panelType');
  if(!panelSelect) return;
  
  const currentValue = panelSelect.value;
  const allPanels = getAllPanels();
  
  // Clear and rebuild
  panelSelect.innerHTML = '';
  
  // Add built-in panels first
  const builtInGroup = document.createElement('optgroup');
  builtInGroup.label = 'Built-in Panels';
  Object.keys(panels).forEach(key => {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = `${panels[key].brand} ${panels[key].name}`;
    builtInGroup.appendChild(option);
  });
  panelSelect.appendChild(builtInGroup);
  
  // Add custom panels
  if(Object.keys(customPanels).length > 0) {
    const customGroup = document.createElement('optgroup');
    customGroup.label = 'Custom Panels';
    Object.keys(customPanels).forEach(key => {
      const option = document.createElement('option');
      option.value = key;
      option.textContent = `${customPanels[key].brand} ${customPanels[key].name} (Custom)`;
      customGroup.appendChild(option);
    });
    panelSelect.appendChild(customGroup);
  }
  
  // Add "Add Custom Panel" option
  const addOption = document.createElement('option');
  addOption.value = '__ADD_CUSTOM__';
  addOption.textContent = '+ Add Custom Panel...';
  addOption.style.fontWeight = 'bold';
  addOption.style.color = '#4a9eff';
  panelSelect.appendChild(addOption);
  
  // Restore selection
  if(currentValue && allPanels[currentValue]) {
    panelSelect.value = currentValue;
  }
}

// Update processor dropdowns
function updateProcessorDropdowns() {
  const processorSelect = document.getElementById('processor');
  if(!processorSelect) return;
  
  const currentValue = processorSelect.value;
  const allProcessors = getAllProcessors();
  
  // Clear and rebuild
  processorSelect.innerHTML = '';
  
  // Add built-in processors first
  const builtInGroup = document.createElement('optgroup');
  builtInGroup.label = 'Built-in Processors';
  Object.keys(processors).forEach(key => {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = processors[key].name;
    builtInGroup.appendChild(option);
  });
  processorSelect.appendChild(builtInGroup);
  
  // Add custom processors
  if(Object.keys(customProcessors).length > 0) {
    const customGroup = document.createElement('optgroup');
    customGroup.label = 'Custom Processors';
    Object.keys(customProcessors).forEach(key => {
      const option = document.createElement('option');
      option.value = key;
      option.textContent = `${customProcessors[key].name} (Custom)`;
      customGroup.appendChild(option);
    });
    processorSelect.appendChild(customGroup);
  }
  
  // Add "Add Custom Processor" option
  const addOption = document.createElement('option');
  addOption.value = '__ADD_CUSTOM__';
  addOption.textContent = '+ Add Custom Processor...';
  addOption.style.fontWeight = 'bold';
  addOption.style.color = '#4a9eff';
  processorSelect.appendChild(addOption);
  
  // Restore selection
  if(currentValue && allProcessors[currentValue]) {
    processorSelect.value = currentValue;
  }
}

// ==================== END CUSTOM STORAGE SYSTEM ====================

// Bumper weights (in kg, converted from lbs where needed)
const bumperWeights = {
  '1w': 2.5,  // kg (approximate)
  '2w': 4.0,  // kg (approximate)
  '4w': 30.0  // kg (66.15 lbs)
};

function calculateAdjustedPixelCapacity(processor, frameRate, bitDepth){
  const baseCapacity = processor.base_pixels_1g || 525000;
  const baseFR = processor.base_framerate || 60;
  const frameRateScale = baseFR / frameRate;
  let bitDepthScale = 1.0;
  if(bitDepth === 10) bitDepthScale = 8 / 10;
  else if(bitDepth === 12) bitDepthScale = 8 / 12;
  const adjustedCapacity = baseCapacity * frameRateScale * bitDepthScale;
  return Math.floor(adjustedCapacity);
}

function toMeters(v, units){ return units==='m' ? v : v*0.3048; }
function fromMeters(m, units){ return units==='m' ? m : m/0.3048; }

function approxAspectRatio(w,h){
  const ratio=w/h;
  const common=[{n:'16:9',v:16/9},{n:'4:3',v:4/3},{n:'3:2',v:3/2},{n:'2:1',v:2/1},{n:'21:9',v:21/9},{n:'1:1',v:1}];
  for(const c of common){ if(Math.abs(ratio-c.v)/c.v<0.02) return {label:c.n, value:ratio}; }
  let best={num:Math.round(ratio*10), den:10, diff:Math.abs(ratio-Math.round(ratio*10)/10)};
  for(let den=1; den<=20; den++){ const num=Math.round(ratio*den); const diff=Math.abs(ratio-(num/den)); if(diff<best.diff){ best={num,den,diff}; } }
  return {label:`${best.num}:${best.den}`, value:ratio};
}

function showSpecWarningIfNeeded(){
  const p = panels[document.getElementById('panelType').value];
  const warn = document.getElementById('specWarning');
  const missingCritical = !p.width_m || !p.height_m || !p.res_x || !p.res_y || !p.power_max_w;
  warn.textContent = missingCritical ? "âš ï¸ Selected model has unconfirmed specs (TBD). Calculations and layouts are limited until datasheet values are confirmed." : "";
}

// Structure functions
function updateBumpersFromStructureType() {
  const structureType = document.getElementById('structureType').value;
  
  if(structureType === 'hanging') {
    showTopBumper = true;
    showBottomBumper = false;
  } else { // ground
    showTopBumper = false;
    showBottomBumper = true;
  }
  
  // Re-initialize bumpers when structure type changes
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  if(pw > 0) {
    initializeBumpers();
  }
  
  updateStructureVisualization();
  updateWeightDisplay();
}

function set1wColumn() {
  const input = document.getElementById('bumper1wColumnInput');
  const col = parseInt(input.value);
  const W = parseInt(document.getElementById('panelsWide').value) || 0;
  
  if(col >= 1 && col <= W) {
    const structureType = document.getElementById('structureType').value;
    
    if(structureType === 'hanging') {
      topBumper1wColumn = col - 1; // Convert to 0-indexed
    } else { // ground
      bottomBumper1wColumn = col - 1;
    }
    
    updateStructureVisualization();
    updateWeightDisplay();
  } else {
    alert(`Please enter a column number between 1 and ${W}`);
  }
}

function clear1wColumn() {
  const structureType = document.getElementById('structureType').value;
  
  if(structureType === 'hanging') {
    topBumper1wColumn = -1;
  } else { // ground
    bottomBumper1wColumn = -1;
  }
  
  const input = document.getElementById('bumper1wColumnInput');
  if(input) input.value = '';
  
  updateStructureVisualization();
  updateWeightDisplay();
}

function updateStructureVisualization() {
  const canvas = document.getElementById('structureCanvas');
  if(canvas && canvas.width > 0) {
    generateStructureLayout();
  }
}

function updateWeightDisplay() {
  const weightDiv = document.getElementById('weightDisplay');
  const weightContent = document.getElementById('weightContent');
  const bumperDistSelect = document.getElementById('bumperDistribution');
  
  // Return early if elements don't exist yet
  if(!weightDiv || !weightContent || !bumperDistSelect) {
    return;
  }
  
  const bumperDist = bumperDistSelect.value;
  
  if(bumperDist !== 'auto' || (!showTopBumper && !showBottomBumper)) {
    weightDiv.style.display = 'none';
    return;
  }
  
  weightDiv.style.display = 'block';
  
  const W = parseInt(document.getElementById('panelsWide').value) || 0;
  const H = parseInt(document.getElementById('panelsHigh').value) || 0;
  const panelType = document.getElementById('panelType').value;
  const p = panels[panelType];
  
  if(W === 0 || H === 0 || !p) {
    weightContent.innerHTML = '<div style="color: #888;">Enter dimensions to calculate weights</div>';
    return;
  }
  
  // Check if panel has bumper weight data
  if(p.bumper_1w_lbs === null || p.bumper_1w_lbs === undefined || 
     p.bumper_2w_lbs === null || p.bumper_2w_lbs === undefined) {
    weightContent.innerHTML = '<div style="color: #888;">No bumper weight data available for this panel type</div>';
    return;
  }
  
  // Convert panel-specific bumper weights from lbs to kg
  const bumper1wKg = p.bumper_1w_lbs * 0.453592;
  const bumper2wKg = p.bumper_2w_lbs * 0.453592;
  const bumper4wKg = p.bumper_4w_lbs ? (p.bumper_4w_lbs * 0.453592) : 0;
  
  // Get correct panel weight based on connection method
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const panelWeightKg = getPanelWeight(panelType, useConnectingPlates);
  
  let html = '';
  
  const needsOneW = W % 2 === 1;
  const num2WBumpers = Math.floor(W / 2);
  
  // Check if 4-way bumpers are enabled for CB5
  const use4Way = use4WayBumpersEnabled;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  const show4WayOnly = use4Way && isCB5;
  
  // Only show 2-way bumpers if NOT using 4-way bumpers
  if(!show4WayOnly) {
    if(showTopBumper) {
      html += '<div style="font-weight: bold; color: #4CAF50; margin-bottom: 4px;">Top Bumper</div>';
      
      // Show 2W bumpers
      for(let i = 0; i < num2WBumpers; i++) {
        const col1 = i * 2;
        const col2 = i * 2 + 1;
        let panelCount = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${col1},${row}`)) panelCount++;
          if(!deletedPanels.has(`${col2},${row}`)) panelCount++;
        }
        const panelWeight = panelCount * panelWeightKg;
        const totalWeight = panelWeight + bumper2wKg;
        html += `<div class="weight-item">Cols ${col1 + 1}-${col2 + 1} (2W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
      
      // Show 1W bumper if needed
      if(needsOneW) {
        const lastCol = W - 1;
        let panelCount = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${lastCol},${row}`)) panelCount++;
        }
        const panelWeight = panelCount * panelWeightKg;
        const totalWeight = panelWeight + bumper1wKg;
        html += `<div class="weight-item">Col ${lastCol + 1} (1W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
    }
    
    if(showBottomBumper) {
      if(showTopBumper) html += '<div style="margin-top: 8px;"></div>';
      html += '<div style="font-weight: bold; color: #FF9800; margin-bottom: 4px;">Bottom Bumper</div>';
      
      // Show 2W bumpers
      for(let i = 0; i < num2WBumpers; i++) {
        const col1 = i * 2;
        const col2 = i * 2 + 1;
        let panelCount = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${col1},${row}`)) panelCount++;
          if(!deletedPanels.has(`${col2},${row}`)) panelCount++;
        }
        const panelWeight = panelCount * panelWeightKg;
        const totalWeight = panelWeight + bumper2wKg;
        html += `<div class="weight-item">Cols ${col1 + 1}-${col2 + 1} (2W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
      
      // Show 1W bumper if needed
      if(needsOneW) {
        const lastCol = W - 1;
        let panelCount = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${lastCol},${row}`)) panelCount++;
        }
        const panelWeight = panelCount * panelWeightKg;
        const totalWeight = panelWeight + bumper1wKg;
        html += `<div class="weight-item">Col ${lastCol + 1} (1W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
    }
  }
  
  // Add 4-way bumper calculations for CB5 (replaces 2-way display when enabled)
  if(show4WayOnly && (showTopBumper || showBottomBumper) && bumper4wKg > 0) {
    
    if(showTopBumper) {
      html += '<div style="font-weight: bold; color: #4CAF50; margin-bottom: 4px;">Top Bumper (4-Way)</div>';
      
      const fourWayCount = Math.floor(W / 4);  // Each 4W covers 4 columns
      for(let i = 0; i < fourWayCount; i++) {
        // Each 4W bumper covers 4 columns: i*4, i*4+1, i*4+2, i*4+3
        const col1 = i * 4;
        const col2 = i * 4 + 1;
        const col3 = i * 4 + 2;
        const col4 = i * 4 + 3;
        
        // Count panels in all 4 columns
        let totalPanelCount = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${col1},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col2},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col3},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col4},${row}`)) totalPanelCount++;
        }
        
        // 4W bumper pickup includes: 4 columns of panels + 2x 2W bumpers + 1x 4W bumper
        const panelWeight = totalPanelCount * panelWeightKg;
        const bumper2wWeight = 2 * bumper2wKg;  // Two 2W bumpers (27.5 lbs each for CB5)
        const bumper4wWeight = bumper4wKg;      // One 4W bumper (66.15 lbs for CB5)
        const totalWeight = panelWeight + bumper2wWeight + bumper4wWeight;
        
        html += `<div class="weight-item">Cols ${col1 + 1}-${col4 + 1} (4W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
    }
    
    if(showBottomBumper) {
      if(showTopBumper) html += '<div style="margin-top: 8px;"></div>';
      html += '<div style="font-weight: bold; color: #FF9800; margin-bottom: 4px;">Bottom Bumper (4-Way)</div>';
      
      const fourWayCount = Math.floor(W / 4);  // Each 4W covers 4 columns
      for(let i = 0; i < fourWayCount; i++) {
        // Each 4W bumper covers 4 columns: i*4, i*4+1, i*4+2, i*4+3
        const col1 = i * 4;
        const col2 = i * 4 + 1;
        const col3 = i * 4 + 2;
        const col4 = i * 4 + 3;
        
        // Count panels in all 4 columns
        let totalPanelCount = 0;
        for(let row = 0; row < H; row++) {
          if(!deletedPanels.has(`${col1},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col2},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col3},${row}`)) totalPanelCount++;
          if(!deletedPanels.has(`${col4},${row}`)) totalPanelCount++;
        }
        
        // 4W bumper pickup includes: 4 columns of panels + 2x 2W bumpers + 1x 4W bumper
        const panelWeight = totalPanelCount * panelWeightKg;
        const bumper2wWeight = 2 * bumper2wKg;  // Two 2W bumpers (27.5 lbs each for CB5)
        const bumper4wWeight = bumper4wKg;      // One 4W bumper (66.15 lbs for CB5)
        const totalWeight = panelWeight + bumper2wWeight + bumper4wWeight;
        
        html += `<div class="weight-item">Cols ${col1 + 1}-${col4 + 1} (4W): ${totalWeight.toFixed(1)} kg (${(totalWeight * 2.20462).toFixed(1)} lbs)</div>`;
      }
    }
  }
  
  weightContent.innerHTML = html;
}

function calculateTotalBumperWeight(W, H) {
  // Calculate total bumper weight based on current configuration
  let totalBumperWeight = 0;
  
  // Check if bumpers are enabled
  if(!useBumpers) {
    return 0;
  }
  
  // Use the global variable for 4-way bumpers state
  const use4Way = use4WayBumpersEnabled;
  
  const panelTypeSelect = document.getElementById('panelType');
  const panelType = panelTypeSelect ? panelTypeSelect.value : '';
  const p = panels[panelType];
  
  // Return 0 if panel doesn't have bumper weight data
  if(!p || p.bumper_1w_lbs === null || p.bumper_1w_lbs === undefined || 
     p.bumper_2w_lbs === null || p.bumper_2w_lbs === undefined) {
    return 0;
  }
  
  // Convert lbs to kg for panel-specific bumper weights
  const bumper1wKg = p.bumper_1w_lbs * 0.453592;
  const bumper2wKg = p.bumper_2w_lbs * 0.453592;
  const bumper4wKg = p.bumper_4w_lbs ? (p.bumper_4w_lbs * 0.453592) : 0;
  
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  const bumperDistSelect = document.getElementById('bumperDistribution');
  const bumperDist = bumperDistSelect ? bumperDistSelect.value : 'auto';
  
  // Only calculate bumper weights if in auto mode
  if(bumperDist !== 'auto') {
    return 0;
  }
  
  // When 4-way bumpers are enabled for CB5, use different calculation
  if(use4Way && isCB5 && (showTopBumper || showBottomBumper) && bumper4wKg > 0) {
    const fourWayCount = Math.floor(W / 4);  // Each 4W covers 4 columns
    const remainingCols = W % 4;              // Leftover columns after 4W bumpers
    
    // Add 4W bumpers for top (includes 2x 2W bumpers + 1x 4W bumper per pickup)
    if(showTopBumper) {
      totalBumperWeight += fourWayCount * bumper4wKg;           // 4W bumper weight
      totalBumperWeight += fourWayCount * 2 * bumper2wKg;        // 2x 2W bumpers per 4W
      
      // Add bumpers for remaining columns (not covered by 4W)
      if(remainingCols >= 2) {
        // Add 2W bumper(s) for pairs
        const extra2W = Math.floor(remainingCols / 2);
        totalBumperWeight += extra2W * bumper2wKg;
      }
      if(remainingCols % 2 === 1) {
        // Add 1W bumper for the last odd column
        totalBumperWeight += bumper1wKg;
      }
    }
    
    // Add 4W bumpers for bottom (includes 2x 2W bumpers + 1x 4W bumper per pickup)
    if(showBottomBumper) {
      totalBumperWeight += fourWayCount * bumper4wKg;           // 4W bumper weight
      totalBumperWeight += fourWayCount * 2 * bumper2wKg;        // 2x 2W bumpers per 4W
      
      // Add bumpers for remaining columns (not covered by 4W)
      if(remainingCols >= 2) {
        // Add 2W bumper(s) for pairs
        const extra2W = Math.floor(remainingCols / 2);
        totalBumperWeight += extra2W * bumper2wKg;
      }
      if(remainingCols % 2 === 1) {
        // Add 1W bumper for the last odd column
        totalBumperWeight += bumper1wKg;
      }
    }
  } else {
    // Standard 2W bumper calculation (when NOT using 4-way bumpers)
    const needsOneW = W % 2 === 1;
    const num2WBumpers = Math.floor(W / 2);
    
    // Calculate top bumper weight
    if(showTopBumper) {
      // Add 2W bumpers (each covers 2 columns)
      totalBumperWeight += num2WBumpers * bumper2wKg;
      // Add 1W bumper for the remaining column if odd width
      if(needsOneW) {
        totalBumperWeight += bumper1wKg;
      }
    }
    
    // Calculate bottom bumper weight
    if(showBottomBumper) {
      // Add 2W bumpers (each covers 2 columns)
      totalBumperWeight += num2WBumpers * bumper2wKg;
      // Add 1W bumper for the remaining column if odd width
      if(needsOneW) {
        totalBumperWeight += bumper1wKg;
      }
    }
  }
  
  return totalBumperWeight;
}

// ==================== COMPREHENSIVE BUMPER MANAGEMENT SYSTEM v23 ====================

// Initialize bumpers based on structure configuration
function initializeBumpers() {
  // Skip if bumpers are disabled
  if(!useBumpers) {
    bumpers = [];
    showTopBumper = false;
    showBottomBumper = false;
    return;
  }
  
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  const ph = parseInt(document.getElementById('panelsHigh').value) || 0;
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  console.log('Initializing bumpers:', {pw, ph, use4Way, isCB5, showTopBumper, showBottomBumper});
  
  bumpers = [];
  nextBumperId = 1;
  
  // Reset the bumpersInitialized flag for current screen since we're creating fresh bumpers
  // This will be set back to true when saveCurrentScreenData() runs
  if(screens[currentScreenId] && screens[currentScreenId].data) {
    screens[currentScreenId].data.bumpersInitialized = false;
  }
  
  if(pw === 0) {
    console.log('Width is 0, skipping bumper initialization');
    return;
  }
  
  // Initialize top bumpers
  if(showTopBumper) {
    console.log('Adding top bumpers...');
    if(use4Way && isCB5) {
      // Add 4W bumpers first - each spans from center of one 2W to center of next 2W
      // This covers 2 columns (2 panel widths) per 4W bumper
      const fourWayCount = Math.floor(pw / 4);
      for(let i = 0; i < fourWayCount; i++) {
        // Each 4W spans from center of 2W at (i*4, i*4+1) to center of 2W at (i*4+2, i*4+3)
        // First 2W center: (i*4 + 0.5 + i*4 + 1.5)/2 = i*4 + 1
        // Second 2W center: (i*4 + 2.5 + i*4 + 3.5)/2 = i*4 + 3
        bumpers.push({
          id: nextBumperId++,
          type: '4w',
          position: 'top',
          startCol: i * 4 + 1,      // Center of first 2W: 1, 5, 9...
          endCol: i * 4 + 3         // Center of second 2W: 3, 7, 11...
        });
      }
      
      // Add 2W bumpers - one per pair of columns
      const num2WBumpers = Math.floor(pw / 2);
      for(let i = 0; i < num2WBumpers; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '2w',
          position: 'top',
          startCol: i * 2,
          endCol: i * 2 + 1
        });
      }
      
      // Add 1W bumper for odd last column
      if(pw % 2 === 1) {
        bumpers.push({
          id: nextBumperId++,
          type: '1w',
          position: 'top',
          startCol: pw - 1,
          endCol: pw - 1
        });
      }
    } else {
      // Just 2W bumpers - one per pair of columns
      const num2WBumpers = Math.floor(pw / 2);
      for(let i = 0; i < num2WBumpers; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '2w',
          position: 'top',
          startCol: i * 2,
          endCol: i * 2 + 1
        });
      }
      
      // Add 1W bumper for odd last column
      if(pw % 2 === 1) {
        bumpers.push({
          id: nextBumperId++,
          type: '1w',
          position: 'top',
          startCol: pw - 1,
          endCol: pw - 1
        });
      }
    }
  }
  
  // Initialize bottom bumpers
  if(showBottomBumper) {
    console.log('Adding bottom bumpers...');
    if(use4Way && isCB5) {
      // Add 2W bumpers - one per pair of columns
      const num2WBumpers = Math.floor(pw / 2);
      for(let i = 0; i < num2WBumpers; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '2w',
          position: 'bottom',
          startCol: i * 2,
          endCol: i * 2 + 1
        });
      }
      
      // Add 1W bumper for odd last column
      if(pw % 2 === 1) {
        bumpers.push({
          id: nextBumperId++,
          type: '1w',
          position: 'bottom',
          startCol: pw - 1,
          endCol: pw - 1
        });
      }
      
      // Add 4W bumpers - each spans from center of one 2W to center of next 2W
      const fourWayCount = Math.floor(pw / 4);
      for(let i = 0; i < fourWayCount; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '4w',
          position: 'bottom',
          startCol: i * 4 + 1,      // Center of first 2W: 1, 5, 9...
          endCol: i * 4 + 3         // Center of second 2W: 3, 7, 11...
        });
      }
    } else {
      // Just 2W bumpers - one per pair of columns
      const num2WBumpers = Math.floor(pw / 2);
      for(let i = 0; i < num2WBumpers; i++) {
        bumpers.push({
          id: nextBumperId++,
          type: '2w',
          position: 'bottom',
          startCol: i * 2,
          endCol: i * 2 + 1
        });
      }
      
      // Add 1W bumper for odd last column
      if(pw % 2 === 1) {
        bumpers.push({
          id: nextBumperId++,
          type: '1w',
          position: 'bottom',
          startCol: pw - 1,
          endCol: pw - 1
        });
      }
    }
  }
  
  console.log(`Initialized ${bumpers.length} bumpers:`, bumpers);
}

// Get bumper at mouse position
function getBumperAtMouse(canvas, clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  
  // Check bumpers in reverse order (top-most first)
  for(let i = bumpers.length - 1; i >= 0; i--) {
    const bumper = bumpers[i];
    
    // Check if bumper has position data (use undefined check, not falsy check since y can be 0)
    if(bumper.x === undefined || bumper.y === undefined || 
       bumper.width === undefined || bumper.height === undefined) continue;
    
    if(x >= bumper.x && x <= bumper.x + bumper.width &&
       y >= bumper.y && y <= bumper.y + bumper.height) {
      return bumper;
    }
  }
  
  return null;
}

// Create and show context menu
function showBumperContextMenu(bumper, x, y) {
  hideContextMenu();
  
  const menu = document.createElement('div');
  menu.id = 'bumperContextMenu';
  menu.style.cssText = `
    position: fixed;
    left: ${x}px;
    top: ${y}px;
    background: #2a2a2a;
    border: 1px solid #555;
    border-radius: 6px;
    padding: 4px 0;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    z-index: 10000;
    min-width: 180px;
    font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
  `;
  
  const options = [];
  
  // Type-specific options
  if(bumper.type === '2w') {
    options.push({
      label: `Replace with 1W Bumper`,
      action: () => replaceBumperType(bumper.id, '1w')
    });
    
    // Add option to move ladder hardware to other column (only for bottom 2W bumpers)
    if(bumper.position === 'bottom') {
      const currentLadderCol = bumper.ladderColumn === 'right' ? 'right (col ' + (bumper.endCol + 1) + ')' : 'left (col ' + (bumper.startCol + 1) + ')';
      const targetCol = bumper.ladderColumn === 'right' ? 'left' : 'right';
      const targetColNum = bumper.ladderColumn === 'right' ? bumper.startCol + 1 : bumper.endCol + 1;
      options.push({
        label: `Move Ladder to Col ${targetColNum}`,
        action: () => toggleBumperLadderColumn(bumper.id)
      });
    }
  } else if(bumper.type === '1w') {
    options.push({
      label: `Replace with 2W Bumper`,
      action: () => replaceBumperType(bumper.id, '2w')
    });
  }
  
  if(bumper.type !== '4w') {
    options.push({
      label: `Move Bumper...`,
      action: () => startMovingBumper(bumper.id)
    });
  }
  
  options.push({ separator: true });
  
  options.push({
    label: `Delete Bumper`,
    danger: true,
    action: () => deleteBumper(bumper.id)
  });
  
  options.forEach(opt => {
    if(opt.separator) {
      const sep = document.createElement('div');
      sep.style.cssText = 'height: 1px; background: #444; margin: 4px 0;';
      menu.appendChild(sep);
    } else {
      const item = document.createElement('div');
      item.textContent = opt.label;
      item.style.cssText = `
        padding: 8px 16px;
        cursor: pointer;
        color: ${opt.danger ? '#ff6b6b' : '#e0e0e0'};
        font-size: 13px;
      `;
      
      item.addEventListener('mouseenter', function() {
        this.style.background = opt.danger ? '#4a2020' : '#3a3a3a';
      });
      
      item.addEventListener('mouseleave', function() {
        this.style.background = 'transparent';
      });
      
      item.addEventListener('click', function(e) {
        e.stopPropagation();
        opt.action();
        hideContextMenu();
      });
      
      menu.appendChild(item);
    }
  });
  
  document.body.appendChild(menu);
  contextMenuVisible = true;
  
  // Adjust if off-screen
  const menuRect = menu.getBoundingClientRect();
  if(menuRect.right > window.innerWidth) {
    menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
  }
  if(menuRect.bottom > window.innerHeight) {
    menu.style.top = (window.innerHeight - menuRect.height - 10) + 'px';
  }
}

// Toggle which column the ladder hardware is on for a 2W bumper
function toggleBumperLadderColumn(bumperId) {
  const bumper = bumpers.find(b => b.id === bumperId);
  if(!bumper || bumper.type !== '2w') return;
  
  // Toggle between left (default/undefined) and right
  bumper.ladderColumn = bumper.ladderColumn === 'right' ? 'left' : 'right';
  
  // Redraw structure layout
  generateStructureLayout();
}

function hideContextMenu() {
  const menu = document.getElementById('bumperContextMenu');
  if(menu && menu.parentNode) {
    menu.parentNode.removeChild(menu);
  }
  contextMenuVisible = false;
}

// Toggle manual bumper distribution mode
function toggleManualBumperMode() {
  manualBumperMode = !manualBumperMode;
  
  const toggleBtn = document.getElementById('manualBumperToggle');
  const hintSpan = document.getElementById('structureModeHint');
  const selectionInfo = document.getElementById('structureSelectionInfo');
  const undoRedoDiv = document.getElementById('structureUndoRedo');
  
  if(manualBumperMode) {
    toggleBtn.classList.add('active');
    toggleBtn.textContent = 'âœ“ Manual Mode Active';
    hintSpan.textContent = 'Click bumpers to select';
    selectionInfo.classList.add('visible');
    undoRedoDiv.style.display = 'flex';
    
    // Save initial state when entering manual mode
    saveStructureState();
    updateStructureUndoRedoButtons();
  } else {
    toggleBtn.classList.remove('active');
    toggleBtn.textContent = 'Manually Distribute Bumpers';
    hintSpan.textContent = 'Auto-distribution active';
    selectionInfo.classList.remove('visible');
    undoRedoDiv.style.display = 'none';
    
    // Clear selections when exiting manual mode
    selectedBumpers.clear();
    selectedBumper = null;
  }
  
  // Redraw to show/hide selection highlights
  generateStructureLayout();
}

// Get panel at mouse position in structure canvas
function getStructurePanelAtMouse(canvas, clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = (clientX - rect.left) * (canvas.width / rect.width);
  const y = (clientY - rect.top) * (canvas.height / rect.height);
  
  const size = 50;
  const {pw, ph} = getEffectivePanelCountsForLayout();
  
  // Calculate panel Y offset (accounting for top bumpers)
  const bumperHeight = 40;
  const fourWayHeight = 20;
  const fourWayGap = 5;
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  let panelYOffset = 0;
  if(showTopBumper) {
    panelYOffset += bumperHeight;
    if(use4Way && isCB5) panelYOffset += fourWayHeight + fourWayGap;
  }
  
  // Check if click is in panel area
  if(y < panelYOffset || y >= panelYOffset + ph * size) return null;
  if(x < 0 || x >= pw * size) return null;
  
  const col = Math.floor(x / size);
  const row = Math.floor((y - panelYOffset) / size);
  
  if(col < 0 || col >= pw || row < 0 || row >= ph) return null;
  
  const panelKey = `${col},${row}`;
  
  // Don't select deleted panels
  if(deletedPanels.has(panelKey)) return null;
  
  return {
    col: col,
    row: row,
    key: panelKey,
    x: col * size,
    y: panelYOffset + row * size
  };
}

// Get all panels in a rectangle (for drag selection in structure view)
function getStructurePanelsInRect(startX, startY, endX, endY) {
  const canvas = document.getElementById('structureCanvas');
  if(!canvas) return [];
  
  const rect = canvas.getBoundingClientRect();
  const x1 = (Math.min(startX, endX) - rect.left) * (canvas.width / rect.width);
  const y1 = (Math.min(startY, endY) - rect.top) * (canvas.height / rect.height);
  const x2 = (Math.max(startX, endX) - rect.left) * (canvas.width / rect.width);
  const y2 = (Math.max(startY, endY) - rect.top) * (canvas.height / rect.height);
  
  const size = 50;
  const {pw, ph} = getEffectivePanelCountsForLayout();
  
  // Calculate panel Y offset
  const bumperHeight = 40;
  const fourWayHeight = 20;
  const fourWayGap = 5;
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  let panelYOffset = 0;
  if(showTopBumper) {
    panelYOffset += bumperHeight;
    if(use4Way && isCB5) panelYOffset += fourWayHeight + fourWayGap;
  }
  
  const panels = [];
  
  for(let col = 0; col < pw; col++) {
    for(let row = 0; row < ph; row++) {
      const panelX = col * size;
      const panelY = panelYOffset + row * size;
      
      // Check if panel intersects with selection rectangle
      if(panelX + size > x1 && panelX < x2 && 
         panelY + size > y1 && panelY < y2) {
        const panelKey = `${col},${row}`;
        if(!deletedPanels.has(panelKey)) {
          panels.push({
            col: col,
            row: row,
            key: panelKey
          });
        }
      }
    }
  }
  
  return panels;
}

// Update the structure selection info display
function updateStructureSelectionInfo() {
  const infoDiv = document.getElementById('structureSelectionInfo');
  if(!infoDiv) return;
  
  if(!manualBumperMode) {
    infoDiv.classList.remove('visible');
    return;
  }
  
  const bumperCount = selectedBumpers.size;
  
  let text = '<strong>Manual Mode:</strong> ';
  
  if(bumperCount === 0) {
    text += 'Tap to select bumpers. Long-press for options.';
  } else {
    text += `Selected: ${bumperCount} bumper${bumperCount > 1 ? 's' : ''}`;
  }
  
  infoDiv.innerHTML = text;
  infoDiv.classList.add('visible');
}

// Structure undo/redo functions
function saveStructureState() {
  // Don't save if not in manual mode
  if(!manualBumperMode) return;
  
  // Create a deep copy of the bumpers array
  const state = {
    bumpers: bumpers.map(b => ({...b})),
    nextBumperId: nextBumperId
  };
  
  // Remove any states after current index (when we make a new change after undoing)
  if(structureHistoryIndex < structureHistory.length - 1) {
    structureHistory = structureHistory.slice(0, structureHistoryIndex + 1);
  }
  
  // Add new state
  structureHistory.push(state);
  
  // Limit history size
  if(structureHistory.length > MAX_STRUCTURE_HISTORY) {
    structureHistory.shift();
  } else {
    structureHistoryIndex++;
  }
  
  updateStructureUndoRedoButtons();
}

function structureUndo() {
  if(structureHistoryIndex <= 0) return;
  
  structureHistoryIndex--;
  restoreStructureState(structureHistory[structureHistoryIndex]);
}

function structureRedo() {
  if(structureHistoryIndex >= structureHistory.length - 1) return;
  
  structureHistoryIndex++;
  restoreStructureState(structureHistory[structureHistoryIndex]);
}

function restoreStructureState(state) {
  if(!state) return;
  
  // Restore bumpers
  bumpers = state.bumpers.map(b => ({...b}));
  nextBumperId = state.nextBumperId;
  
  // Clear selections
  selectedBumpers.clear();
  selectedBumper = null;
  
  // Redraw
  generateStructureLayout();
  updateWeightDisplay();
  updateStructureUndoRedoButtons();
  updateStructureSelectionInfo();
}

function updateStructureUndoRedoButtons() {
  const undoBtn = document.getElementById('structureUndoBtn');
  const redoBtn = document.getElementById('structureRedoBtn');
  
  if(undoBtn) {
    undoBtn.disabled = structureHistoryIndex <= 0;
  }
  if(redoBtn) {
    redoBtn.disabled = structureHistoryIndex >= structureHistory.length - 1;
  }
}

// Bumper manipulation functions
function replaceBumperType(bumperId, newType) {
  const bumper = bumpers.find(b => b.id === bumperId);
  if(!bumper) return;
  
  saveStructureState(); // Save before change
  bumper.type = newType;
  generateStructureLayout();
  updateWeightDisplay();
  calculate();
}

function deleteBumper(bumperId) {
  saveStructureState(); // Save before change
  bumpers = bumpers.filter(b => b.id !== bumperId);
  selectedBumpers.delete(bumperId);
  generateStructureLayout();
  updateWeightDisplay();
  calculate();
}

function startMovingBumper(bumperId) {
  const bumper = bumpers.find(b => b.id === bumperId);
  if(!bumper) return;
  
  selectedBumper = bumper;
  // Visual feedback will be added in the draw function
  generateStructureLayout();
}

function addBumperAtColumn(position, type, column) {
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  if(column < 0 || column >= pw) return;
  
  let endCol = column;
  if(type === '2w' || type === '4w') {
    endCol = column + 1;
    // Make sure we don't exceed panel width
    if(endCol >= pw) {
      endCol = pw - 1;
    }
  }
  
  // Check if bumper already exists at this position
  const exists = bumpers.some(b => 
    b.position === position && 
    b.type === type && 
    b.startCol === column
  );
  
  if(!exists) {
    saveStructureState(); // Save before change
    bumpers.push({
      id: nextBumperId++,
      type: type,
      position: position,
      startCol: column,
      endCol: endCol
    });
    
    generateStructureLayout();
    updateWeightDisplay();
    calculate();
  }
}

// Show empty area context menu for adding bumpers
function showEmptyAreaContextMenu(position, column, x, y) {
  hideContextMenu();
  
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  
  const menu = document.createElement('div');
  menu.id = 'bumperContextMenu';
  menu.style.cssText = `
    position: fixed;
    left: ${x}px;
    top: ${y}px;
    background: #2a2a2a;
    border: 1px solid #555;
    border-radius: 6px;
    padding: 4px 0;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    z-index: 10000;
    min-width: 180px;
    font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
  `;
  
  const options = [
    {
      label: `Add 2W Bumper at Columns ${column + 1}-${column + 2}`,
      action: () => addBumperAtColumn(position, '2w', column)
    },
    {
      label: `Add 1W Bumper at Column ${column + 1}`,
      action: () => addBumperAtColumn(position, '1w', column)
    }
  ];
  
  // Add 4W option for CB5 panels
  if(isCB5 && column + 1 < pw) {
    options.push({
      label: `Add 4W Bumper at Columns ${column + 1}-${column + 2}`,
      action: () => addBumperAtColumn(position, '4w', column)
    });
  }
  
  options.forEach(opt => {
    const item = document.createElement('div');
    item.textContent = opt.label;
    item.style.cssText = `
      padding: 8px 16px;
      cursor: pointer;
      color: #e0e0e0;
      font-size: 13px;
    `;
    
    item.addEventListener('mouseenter', function() {
      this.style.background = '#3a3a3a';
    });
    
    item.addEventListener('mouseleave', function() {
      this.style.background = 'transparent';
    });
    
    item.addEventListener('click', function(e) {
      e.stopPropagation();
      opt.action();
      hideContextMenu();
    });
    
    menu.appendChild(item);
  });
  
  document.body.appendChild(menu);
  contextMenuVisible = true;
  
  // Adjust if off-screen
  const menuRect = menu.getBoundingClientRect();
  if(menuRect.right > window.innerWidth) {
    menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
  }
  if(menuRect.bottom > window.innerHeight) {
    menu.style.top = (window.innerHeight - menuRect.height - 10) + 'px';
  }
}

// ==================== END BUMPER MANAGEMENT SYSTEM ====================

function syncFromPanels(){
  const p=panels[document.getElementById('panelType').value];
  const units = displayLengthUnit; // Use global unit setting
  const pwInput = document.getElementById('panelsWide').value;
  const phInput = document.getElementById('panelsHigh').value;
  const wallWidthEl = document.getElementById('wallWidth');
  const wallHeightEl = document.getElementById('wallHeight');
  
  // If either panel value is empty, clear the corresponding wall dimension
  if(!pwInput && wallWidthEl) {
    wallWidthEl.value = '';
  }
  if(!phInput && wallHeightEl) {
    wallHeightEl.value = '';
  }
  
  // Only sync if both panel values are actually entered
  if(!pwInput || !phInput) return;
  
  const pw=Math.max(1,parseInt(pwInput)||1);
  const ph=Math.max(1,parseInt(phInput)||1);
  if(!p.width_m || !p.height_m){ return; }
  const wM=pw*p.width_m, hM=ph*p.height_m;
  if(wallWidthEl) wallWidthEl.value = fromMeters(wM, units).toFixed(2);
  if(wallHeightEl) wallHeightEl.value = fromMeters(hM, units).toFixed(2);
}

function syncFromSize(){
  const p=panels[document.getElementById('panelType').value];
  const units = displayLengthUnit; // Use global unit setting
  const wallWidthEl = document.getElementById('wallWidth');
  const wallHeightEl = document.getElementById('wallHeight');
  const wInput = wallWidthEl ? wallWidthEl.value : '';
  const hInput = wallHeightEl ? wallHeightEl.value : '';
  const panelsWideEl = document.getElementById('panelsWide');
  const panelsHighEl = document.getElementById('panelsHigh');
  
  // If either wall dimension is empty, clear the corresponding panel count
  if(!wInput && panelsWideEl) {
    panelsWideEl.value = '';
  }
  if(!hInput && panelsHighEl) {
    panelsHighEl.value = '';
  }
  
  // Only sync if both wall dimensions are actually entered
  if(!wInput || !hInput) return;
  
  const w = parseFloat(wInput);
  const h = parseFloat(hInput);
  if(!p.width_m || !p.height_m || w <= 0 || h <= 0){ return; }
  const wM = toMeters(w, units);
  const hM = toMeters(h, units);
  const pw = Math.max(1, Math.round(wM / p.width_m));
  const ph = Math.max(1, Math.round(hM / p.height_m));
  if(panelsWideEl) panelsWideEl.value = pw;
  if(panelsHighEl) panelsHighEl.value = ph;
}

function getEffectivePanelCounts(){
  const p=panels[document.getElementById('panelType').value];
  const units = displayLengthUnit; // Use global unit setting
  const wallWidthEl = document.getElementById('wallWidth');
  const wallHeightEl = document.getElementById('wallHeight');
  const w = wallWidthEl ? (parseFloat(wallWidthEl.value)||0) : 0;
  const h = wallHeightEl ? (parseFloat(wallHeightEl.value)||0) : 0;
  if(w>0 && h>0 && p.width_m && p.height_m){
    const wM=toMeters(w, units), hM=toMeters(h, units);
    const pw=Math.max(1, Math.round(wM / p.width_m));
    const ph=Math.max(1, Math.round(hM / p.height_m));
    return {pw, ph, entered:{w, h, units}, snapped:{wM:pw*p.width_m, hM:ph*p.height_m}};
  }else{
    const pw=Math.max(1,parseInt(document.getElementById('panelsWide').value)||1);
    const ph=Math.max(1,parseInt(document.getElementById('panelsHigh').value)||1);
    return {pw, ph, entered:null, snapped:{wM:p.width_m?pw*p.width_m:0, hM:p.height_m?ph*p.height_m:0}};
  }
}

function calculateActualDataLines(pw, ph, panelsPerDataLine, startDir) {
  // Collect all custom data line numbers in use first
  const usedCustomDataLines = new Set();
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++) {
      const panelKey = `${c},${r}`;
      if(!deletedPanels.has(panelKey) && customDataLineAssignments.has(panelKey)) {
        usedCustomDataLines.add(customDataLineAssignments.get(panelKey) - 1);
      }
    }
  }
  
  // Build panel assignments based on start direction
  let maxDataLine = -1;
  
  if(startDir === 'all_top') {
    // Each column is its own data line
    let autoDataLineCounter = 0;
    for(let c=0; c<pw; c++){
      while(usedCustomDataLines.has(autoDataLineCounter)) {
        autoDataLineCounter++;
      }
      
      for(let r=0; r<ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          const dataLine = customDataLineAssignments.has(panelKey) 
            ? customDataLineAssignments.get(panelKey) - 1
            : autoDataLineCounter;
          if(dataLine > maxDataLine) maxDataLine = dataLine;
        }
      }
      autoDataLineCounter++;
    }
  } else if(startDir === 'all_bottom') {
    // Each column is its own data line
    let autoDataLineCounter = 0;
    for(let c=0; c<pw; c++){
      while(usedCustomDataLines.has(autoDataLineCounter)) {
        autoDataLineCounter++;
      }
      
      for(let r=ph-1; r>=0; r--) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          const dataLine = customDataLineAssignments.has(panelKey) 
            ? customDataLineAssignments.get(panelKey) - 1
            : autoDataLineCounter;
          if(dataLine > maxDataLine) maxDataLine = dataLine;
        }
      }
      autoDataLineCounter++;
    }
  } else {
    // Serpentine: top or bottom
    // Use per-panel counting to match generateLayout visualization
    const startFromTop = (startDir === 'top');
    let autoDataLineCounter = 0;
    let panelsInCurrentAutoDataLine = 0;
    
    // Skip initial custom data lines
    while(usedCustomDataLines.has(autoDataLineCounter)) {
      autoDataLineCounter++;
    }
    
    // Build serpentine path
    let currentColumn = 0;
    let serpentineGoingDown = startFromTop;
    
    while(currentColumn < pw) {
      // Process panels in this column in serpentine order
      const rows = serpentineGoingDown 
        ? Array.from({length: ph}, (_, i) => i) 
        : Array.from({length: ph}, (_, i) => ph - 1 - i);
      
      for(const r of rows) {
        const panelKey = `${currentColumn},${r}`;
        if(deletedPanels.has(panelKey)) continue;
        
        let dataLine;
        if(customDataLineAssignments.has(panelKey)) {
          dataLine = customDataLineAssignments.get(panelKey) - 1;
        } else {
          // Find next available data line number (skip over custom assignments)
          while(usedCustomDataLines.has(autoDataLineCounter)) {
            autoDataLineCounter++;
          }
          
          dataLine = autoDataLineCounter;
          panelsInCurrentAutoDataLine++;
          
          // Move to next data line when we reach the limit
          if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
            autoDataLineCounter++;
            panelsInCurrentAutoDataLine = 0;
            
            // Skip over any custom data lines
            while(usedCustomDataLines.has(autoDataLineCounter)) {
              autoDataLineCounter++;
            }
          }
        }
        
        if(dataLine > maxDataLine) maxDataLine = dataLine;
      }
      
      // Move to next column and toggle direction
      currentColumn++;
      serpentineGoingDown = !serpentineGoingDown;
    }
  }
  
  // Return total number of data lines
  return maxDataLine + 1;
}

// ==================== CONNECTING PLATES FUNCTIONS ====================

function getPanelWeight(panelType, useConnectingPlates) {
  // Get base panel weight
  const p = panels[panelType];
  if (!p) return 0;
  
  // If using connecting plates, CB5 panels don't have air frames
  if (useConnectingPlates) {
    if (panelType === 'CB5_MKII') {
      // Full CB5 panel WITHOUT air frame is 9.10 lbs = 4.127 kg
      return 4.127;
    } else if (panelType === 'CB5_MKII_HALF') {
      // Half CB5 panel WITHOUT air frame is 3.60 lbs = 1.633 kg
      return 1.633;
    }
  }
  
  // Return standard weight with air frame
  return p.weight_kg || 0;
}

function shouldUseConnectingPlates(panelType) {
  // DM2.6 always uses connecting plates
  if (panelType === 'DM2_6') {
    return true;
  }
  
  // CB5 MKII and CB5 MKII HALF can choose
  if (panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF') {
    return connectionMethod === 'plates';
  }
  
  return false;
}

function calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg) {
  // For perimeter-only 2-way plates and interior + bumper 4-way plates:
  
  // 2-way plates (yellow) on perimeter:
  // - Left edge: (ph-1) plates between vertically adjacent panels
  // - Right edge: (ph-1) plates between vertically adjacent panels
  // - Top/Bottom edge: (pw-1) plates between horizontally adjacent panels
  // - 2 plates at top-left and top-right where panels meet bumpers (or bottom if ground stacking)
  // Note: Corner plates are part of the edge counts, not separate
  const perimeterVertical = 2 * (ph - 1); // Left + Right edges
  const perimeterHorizontal = (pw - 1); // Top or Bottom edge
  const bumperEdgePlates = 2; // Vertical plates at left/right where they meet bumpers
  const total2way = perimeterVertical + perimeterHorizontal + bumperEdgePlates;
  
  // 4-way plates (red):
  // - Interior intersections: (pw-1) Ã— (ph-1)
  // - Bumper-to-panel connections: (pw-1) plates at top or bottom row
  const interior4way = (pw - 1) * (ph - 1);
  const bumper4way = (pw - 1);
  const total4way = interior4way + bumper4way;
  
  // Calculate weights
  const weight2way = total2way * plate2wayKg;
  const weight4way = total4way * plate4wayKg;
  const totalPlateWeight = weight2way + weight4way;
  
  return {
    perimeterVertical,
    perimeterHorizontal,
    bumperEdgePlates,
    total2way,
    interior4way,
    bumper4way,
    total4way,
    weight2way,
    weight4way,
    totalPlateWeight
  };
}

function updatePlatesDisplay(useConnectingPlates, pw, ph, plate2wayKg, plate4wayKg) {
  // This function now just triggers the structure panel update
  // The actual display is handled by updateStructurePlatesDisplay()
  // which is called from updatePickupWeightSummary()
  
  // If structure view is visible, it will update automatically
  // Just call the structure plates display update
  updateStructurePlatesDisplay();
}

function updateConnectingPlatesVisibility(panelType) {
  const platesSection = document.getElementById('connectingPlatesSection');
  const cb5Choice = document.getElementById('cb5ConnectionChoice');
  const dm26Info = document.getElementById('dm26ConnectionInfo');
  
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  const isDM26 = panelType === 'DM2_6';
  
  if (isCB5 || isDM26) {
    platesSection.style.display = 'block';
    
    if (isCB5) {
      // CB5 can choose between air frame and connecting plates
      cb5Choice.style.display = 'block';
      dm26Info.style.display = 'none';
    } else if (isDM26) {
      // DM2.6 always uses plates (no choice)
      cb5Choice.style.display = 'none';
      dm26Info.style.display = 'block';
      
      // Force plates selection for DM2.6
      const platesRadio = document.querySelector('input[name="connectionMethod"][value="plates"]');
      if (platesRadio) platesRadio.checked = true;
    }
  } else {
    platesSection.style.display = 'none';
  }
}

function resetCalculator() {
  // Clear the current screen's stored data so it doesn't get restored
  if(typeof screens !== 'undefined' && typeof currentScreenId !== 'undefined' && screens[currentScreenId]) {
    // Reset the screen data to defaults
    screens[currentScreenId].data = {
      panelsWide: '',
      panelsHigh: '',
      wallWidth: '',
      wallHeight: '',
      units: 'ft',
      dimensionMode: 'panels',
      panelType: document.getElementById('panelType').value, // Keep the newly selected panel type
      voltage: 208,
      breaker: 20,
      phase: '3',
      derate: false,
      powerType: 'max',
      maxPanelsPerCircuit: '',
      processor: 'Brompton_SX40',
      frameRate: 60,
      bitDepth: 8,
      maxPanelsPerData: '',
      dataStartDir: 'top',
      showArrows: true,
      redundancy: true,
      processorRedundancy: false,
      structureType: 'hanging',
      useBumpers: true,
      use4WayBumpers: false,
      deletedPanels: new Set(),
      bumpers: [],
      canvasX: 0,
      canvasY: 0,
      addCB5HalfRow: false
    };
  }
  
  // Reset input fields to default values
  document.getElementById('panelsWide').value = '';
  document.getElementById('panelsHigh').value = '';
  document.getElementById('wallWidth').value = '';
  document.getElementById('wallHeight').value = '';
  
  // Reset units to defaults (Imperial)
  displayLengthUnit = 'ft';
  displayWeightUnit = 'lbs';
  document.getElementById('unitImperial')?.classList.add('active');
  document.getElementById('unitMetric')?.classList.remove('active');
  
  // Reset toggle states
  cb5HalfRowEnabled = false;
  document.getElementById('addCB5HalfRowBtn')?.classList.remove('active');
  
  use4WayBumpersEnabled = false;
  document.getElementById('use4WayBumpersBtn')?.classList.remove('active');
  
  redundancyEnabled = false;
  document.getElementById('redundancyBtn')?.classList.remove('active');
  
  showArrowsEnabled = true;
  document.getElementById('showArrowsBtn')?.classList.add('active');
  
  snapModeEnabled = true;
  document.getElementById('snapModeBtn')?.classList.add('active');
  
  // Reset connection method to air frames (default)
  connectionMethod = 'airframe';
  document.getElementById('connectionAirframeBtn')?.classList.add('active');
  document.getElementById('connectionPlatesBtn')?.classList.remove('active');
  
  // Reset dimension mode
  currentDimensionMode = 'panels';
  document.getElementById('dimModePanelsBtn')?.classList.add('active');
  document.getElementById('dimModeSizeBtn')?.classList.remove('active');
  
  // Reset bumper distribution to auto
  const bumperDist = document.getElementById('bumperDistribution');
  if(bumperDist) bumperDist.value = 'auto';
  
  // Reset structure type to hanging
  const structureType = document.getElementById('structureType');
  if(structureType) structureType.value = 'hanging';
  
  // Reset max panels per data line
  document.getElementById('maxPanelsPerData').value = '';
  
  // Reset max panels per circuit
  document.getElementById('maxPanelsPerCircuit').value = '';
  
  // Clear deleted panels
  deletedPanels.clear();
  
  // Clear selected panels (standard layout view)
  selectedPanels.clear();
  
  // Clear custom circuit assignments
  customCircuitAssignments.clear();
  
  // Clear custom data line assignments
  customDataLineAssignments.clear();
  
  // Reset bumpers
  bumpers = [];
  nextBumperId = 1;
  selectedBumper = null;
  hoveredBumper = null;
  
  // Reset global bumper visibility flags
  showTopBumper = true;
  showBottomBumper = false;
  
  // Reset manual bumper mode
  manualBumperMode = false;
  selectedBumpers.clear();
  structureIsDragging = false;
  structureDraggingBumper = null;
  
  // Reset structure view undo/redo
  structureHistory = [];
  structureHistoryIndex = -1;
  
  // Update manual mode UI
  const toggleBtn = document.getElementById('manualBumperToggle');
  const hintSpan = document.getElementById('structureModeHint');
  const selectionInfo = document.getElementById('structureSelectionInfo');
  const undoRedoDiv = document.getElementById('structureUndoRedo');
  if(toggleBtn) {
    toggleBtn.classList.remove('active');
    toggleBtn.textContent = 'Manually Distribute Bumpers';
  }
  if(hintSpan) hintSpan.textContent = 'Auto-distribution active';
  if(selectionInfo) selectionInfo.classList.remove('visible');
  if(undoRedoDiv) undoRedoDiv.style.display = 'none';
  
  // Reset canvas event listener flag so it can be re-attached
  const structCanvas = document.getElementById('structureCanvas');
  if(structCanvas) structCanvas._structureListenersAttached = false;
  
  // Reset legacy bumper variables
  topBumper1wColumn = -1;
  bottomBumper1wColumn = -1;
  manualTopBumpers = [];
  manualBottomBumpers = [];
  
  // Clear undo/redo stacks
  undoStack = [];
  redoStack = [];
  canvasUndoStack = [];
  canvasRedoStack = [];
  undoHistory = [];
  redoHistory = [];
  
  // Reset canvas view state
  canvasOffsetX = 0;
  canvasOffsetY = 0;
  canvasZoomLevel = 1.0;
  canvasPanX = 0;
  canvasPanY = 0;
  
  // Reset context menu state
  contextMenuVisible = false;
  hideContextMenu();
  
  // Reset results display
  document.getElementById('results').innerText = '';
  
  // Hide all layout containers
  const layoutContainers = ['standardContainer', 'structureContainer', 'powerContainer', 'dataContainer', 'canvasContainer', 'gearListContainer'];
  layoutContainers.forEach(containerId => {
    const container = document.getElementById(containerId);
    if(container) {
      container.style.display = 'none';
    }
  });
  
  // Clear all canvas drawings
  const canvases = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasViewCanvas'];
  canvases.forEach(canvasId => {
    const canvas = document.getElementById(canvasId);
    if(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Also reset canvas dimensions
      canvas.width = 0;
      canvas.height = 0;
    }
  });
  
  // Hide pickup weight summary
  const pickupSummary = document.getElementById('pickupWeightSummary');
  if(pickupSummary) pickupSummary.style.display = 'none';
  
  // Update visibility of CB5-specific options
  updateCB5HalfPanelVisibility();
  
  // Update 4-way bumper visibility
  const fourWayOption = document.getElementById('fourWayBumperOption');
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  if(fourWayOption) {
    fourWayOption.style.display = isCB5 ? 'block' : 'none';
  }
  
  // Update connecting plates visibility
  updateConnectingPlatesVisibility(panelType);
  
  // Force immediate DOM update by reading a layout property
  document.body.offsetHeight;
  
  // Hide all layout containers AND clear their visibility with repaint
  const layoutContainersToHide = ['standardContainer', 'structureContainer', 'powerContainer', 'dataContainer', 'canvasContainer', 'gearListContainer'];
  layoutContainersToHide.forEach(containerId => {
    const container = document.getElementById(containerId);
    if(container) {
      container.style.display = 'none';
      // Force repaint by toggling a class
      container.classList.add('reset-hidden');
      void container.offsetWidth; // Force reflow
    }
  });
  
  // Clear all canvases
  const canvasesToClear = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasViewCanvas'];
  canvasesToClear.forEach(canvasId => {
    const canvas = document.getElementById(canvasId);
    if(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      canvas.width = 0;
      canvas.height = 0;
    }
  });
  
  // Show ready message
  document.getElementById('results').innerHTML = '<div style="padding: 40px; text-align: center; color: #888;">' +
    '<h3 style="color: #0a66c2; margin-bottom: 10px;">Ready to Configure</h3>' +
    '<p>Enter panel dimensions above to begin calculating your LED wall.</p>' +
    '</div>';
  
  // Force browser to repaint by scrolling to top of results
  const resultsEl = document.getElementById('results');
  if(resultsEl) {
    resultsEl.scrollIntoView({ behavior: 'instant', block: 'start' });
  }
}

function calculate(){
  console.log('=== calculate() called ===');
  console.log('Current screen:', currentScreenId);
  
  showSpecWarningIfNeeded();
  
  // Check if this is an empty/new screen (no dimensions entered)
  const panelsWideInput = document.getElementById('panelsWide');
  const panelsHighInput = document.getElementById('panelsHigh');
  const wallWidthInput = document.getElementById('wallWidth');
  const wallHeightInput = document.getElementById('wallHeight');
  
  const panelsWideVal = panelsWideInput ? panelsWideInput.value.trim() : '';
  const panelsHighVal = panelsHighInput ? panelsHighInput.value.trim() : '';
  const wallWidthVal = wallWidthInput ? wallWidthInput.value.trim() : '';
  const wallHeightVal = wallHeightInput ? wallHeightInput.value.trim() : '';
  
  // If all dimension fields are empty, show a helpful message
  if(!panelsWideVal && !panelsHighVal && !wallWidthVal && !wallHeightVal) {
    document.getElementById('results').innerHTML = '<div style="padding: 40px; text-align: center; color: #888;">' +
      '<h3 style="color: #0a66c2; margin-bottom: 10px;">Ready to Configure</h3>' +
      '<p>Enter panel dimensions above to begin calculating your LED wall.</p>' +
      '</div>';
    
    // Hide all layout containers
    const layoutContainers = ['standardContainer', 'structureContainer', 'powerContainer', 'dataContainer', 'canvasContainer', 'gearListContainer'];
    layoutContainers.forEach(containerId => {
      const container = document.getElementById(containerId);
      if(container) {
        container.style.display = 'none';
      }
    });
    
    // Clear all canvases for empty screen
    const canvases = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasViewCanvas'];
    canvases.forEach(canvasId => {
      const canvas = document.getElementById(canvasId);
      if(canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    });
    return;
  }
  
  const allPanels = getAllPanels();
  const allProcessors = getAllProcessors();
  const panelType = document.getElementById('panelType').value;
  const p=allPanels[panelType];
  const pr=allProcessors[document.getElementById('processor').value];
  if(!p.width_m || !p.height_m || !p.res_x || !p.res_y || !p.power_max_w){
    document.getElementById('results').innerText = "Please confirm specs for this model (dimensions, resolution, power, etc.) before running calculations.";
    return;
  }
  
  // Check if CB5 half panel row is enabled
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && panelType === 'CB5_MKII';
  
  const powerType = document.getElementById('powerType').value;
  const voltage = parseFloat(document.getElementById('voltage').value)||220;
  const breaker = parseFloat(document.getElementById('breaker').value)||20;
  const phase = parseInt(document.getElementById('phase').value)||3;
  // Derate removed - default to no derating
  const derate = 1.0; // Derating disabled
  const {pw, ph, entered, snapped} = getEffectivePanelCounts();
  const units = displayLengthUnit; // Use global unit setting

  const wallWM = snapped.wM, wallHM = snapped.hM;
  const wallWF = wallWM? (wallWM/0.3048) : 0;
  const wallHF = wallHM? (wallHM/0.3048) : 0;

  const totalPanelsGrid = pw*ph;
  const activePanelsCount = totalPanelsGrid - deletedPanels.size;
  
  // Calculate mixed panel counts if CB5 half row is enabled
  let totalPanels, totalPixels, totalWeight, totalPowerW, resX, resY, adjustedWallHM, adjustedWallHF;
  
  if(hasCB5HalfRow) {
    // Get half panel specs
    const halfPanel = panels['CB5_MKII_HALF'];
    
    // Main panels are all except bottom row
    const mainPanelCount = activePanelsCount - pw; // Subtract bottom row
    const halfPanelCount = pw; // Bottom row
    
    // Calculate totals combining both panel types
    totalPanels = mainPanelCount + halfPanelCount;
    totalPixels = (mainPanelCount * (p.res_x * p.res_y)) + (halfPanelCount * (halfPanel.res_x * halfPanel.res_y));
    
    // Calculate panel weight and add bumper weight
    // Get correct panel weights based on connection method
    const useConnectingPlates = shouldUseConnectingPlates(panelType);
    const mainPanelWeightKg = getPanelWeight('CB5_MKII', useConnectingPlates);
    const halfPanelWeightKg = getPanelWeight('CB5_MKII_HALF', useConnectingPlates);
    
    const panelWeight = (mainPanelCount * mainPanelWeightKg) + (halfPanelCount * halfPanelWeightKg);
    const bumperWeight = calculateTotalBumperWeight(pw, ph);
    
    // Calculate connecting plates weight if applicable
    let plateWeight = 0;
    
    if (useConnectingPlates) {
      // Connecting plate weights (constants)
      const plate2wayKg = 0.141; // 2-way plate weight (0.31 lbs)
      const plate4wayKg = 0.249; // 4-way plate weight (0.55 lbs)
      const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
      plateWeight = plates.totalPlateWeight;
      updatePlatesDisplay(true, pw, ph, plate2wayKg, plate4wayKg);
    } else {
      updatePlatesDisplay(false, 0, 0, 0, 0);
    }
    
    totalWeight = panelWeight + bumperWeight + plateWeight;
    
    const perPanelW = powerType==='max' ? p.power_max_w : (p.power_avg_w||p.power_max_w*0.5);
    const perHalfPanelW = powerType==='max' ? halfPanel.power_max_w : (halfPanel.power_avg_w||halfPanel.power_max_w*0.5);
    totalPowerW = (mainPanelCount * perPanelW) + (halfPanelCount * perHalfPanelW);
    
    // Resolution includes both types
    resX = pw * p.res_x; // Width stays same
    resY = (ph - 1) * p.res_y + halfPanel.res_y; // Main rows + half row
    
    // Adjust wall height to include half panel
    adjustedWallHM = wallHM + (halfPanel.height_m - p.height_m);
    adjustedWallHF = adjustedWallHM / 0.3048;
  } else {
    // Standard calculation (no half panels)
    totalPanels = activePanelsCount;
    resX = pw*p.res_x;
    resY = ph*p.res_y;
    totalPixels = activePanelsCount * (p.res_x*p.res_y);
    
    // Calculate panel weight and add bumper weight
    const useConnectingPlates = shouldUseConnectingPlates(panelType);
    const panelWeightKg = getPanelWeight(panelType, useConnectingPlates);
    
    const panelWeight = totalPanels * panelWeightKg;
    const bumperWeight = calculateTotalBumperWeight(pw, ph);
    
    // Calculate connecting plates weight if applicable
    let plateWeight = 0;
    
    if (useConnectingPlates) {
      // Connecting plate weights (constants)
      const plate2wayKg = 0.141; // 2-way plate weight (0.31 lbs)
      const plate4wayKg = 0.249; // 4-way plate weight (0.55 lbs)
      const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
      plateWeight = plates.totalPlateWeight;
      updatePlatesDisplay(true, pw, ph, plate2wayKg, plate4wayKg);
    } else {
      updatePlatesDisplay(false, 0, 0, 0, 0);
    }
    
    totalWeight = panelWeight + bumperWeight + plateWeight;
    
    const perPanelW = powerType==='max' ? p.power_max_w : (p.power_avg_w||p.power_max_w*0.5);
    totalPowerW = totalPanels * perPanelW;
    adjustedWallHM = wallHM;
    adjustedWallHF = wallHF;
  }
  
  const totalWeightLbs = totalWeight * 2.20462;

  const circuitCapacityW = voltage*breaker*derate;
  const perPanelW = powerType==='max' ? p.power_max_w : (p.power_avg_w||p.power_max_w*0.5);
  
  // Always calculate based on power settings
  const calculatedPanelsPerCircuit = Math.max(1, Math.floor(circuitCapacityW / perPanelW));
  
  // Get user override or use calculated value
  const userMaxPanelsPerCircuit = parseInt(document.getElementById('maxPanelsPerCircuit').value);
  const panelsPerCircuit = userMaxPanelsPerCircuit > 0 ? userMaxPanelsPerCircuit : calculatedPanelsPerCircuit;
  
  // Update placeholder to show calculated value
  const maxPanelsPerCircuitInput = document.getElementById('maxPanelsPerCircuit');
  if(maxPanelsPerCircuitInput) {
    maxPanelsPerCircuitInput.placeholder = calculatedPanelsPerCircuit.toString();
  }
  
  const columnsPerCircuit = Math.max(1, Math.floor(panelsPerCircuit / ph));
  const circuitsByColumns = Math.ceil(pw / columnsPerCircuit);

  const ampsSingle = totalPowerW / voltage;
  // For 3-phase: Total Watts / Voltage = Total Amps, then Total Amps / 3 = Amps per phase
  const totalAmps = totalPowerW / voltage;
  const ampsPerPhase = phase===3 ? (totalAmps / 3) : ampsSingle;

  const pixelsPerPanel = p.res_x*p.res_y;
  const frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  const bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  // Using redundancyEnabled toggle state
  const redundancy = redundancyEnabled;
  const adjustedCapacity = calculateAdjustedPixelCapacity(pr, frameRate, bitDepth);
  
  // Calculate suggested panels per data line accounting for mixed panel types
  let capacityBasedPanelsPerData;
  if(hasCB5HalfRow) {
    // With half panels, we need to calculate based on average pixels per panel
    const halfPanel = panels['CB5_MKII_HALF'];
    const halfPanelPixels = halfPanel.res_x * halfPanel.res_y;
    const mainPanelCount = activePanelsCount - pw; // All except bottom row
    const halfPanelCount = pw; // Bottom row
    const totalPixels = (mainPanelCount * pixelsPerPanel) + (halfPanelCount * halfPanelPixels);
    const avgPixelsPerPanel = totalPixels / activePanelsCount;
    capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / avgPixelsPerPanel));
  } else {
    capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
  }
  
  // Use the panel-specific limit if available, otherwise use capacity-based calculation
  // The auto value is the MINIMUM of capacity-based calculation and panel-specific limit
  const panelSpecificDataLimit = p.max_panels_per_data || null;
  const suggestedPanelsPerData = panelSpecificDataLimit 
    ? Math.min(capacityBasedPanelsPerData, panelSpecificDataLimit)
    : capacityBasedPanelsPerData;
  
  const userMax = parseInt(document.getElementById('maxPanelsPerData').value);
  const panelsPerDataLine = userMax>0 ? userMax : suggestedPanelsPerData;
  
  // Get data start direction
  const startDirEl = document.getElementById('dataStartDir');
  const startDir = startDirEl ? startDirEl.value : 'top';
  
  // Calculate actual data lines used (including custom assignments)
  // Use adjusted ph if CB5 half row is enabled
  const adjustedPh = hasCB5HalfRow ? ph + 1 : ph;
  const actualDataLines = calculateActualDataLines(pw, adjustedPh, panelsPerDataLine, startDir);
  const dataLines = actualDataLines;
  const portsNeeded = dataLines; // Each data line needs one port
  
  const redundancyMultiplier = redundancy ? 2 : 1;
  const portsNeededFinal = portsNeeded * redundancyMultiplier;
  const dataLinesFinal = dataLines * redundancyMultiplier;

  const ar = (wallWM&&wallHM) ? approxAspectRatio(wallWM, wallHM) : {label:"N/A", value:0};

  // Calculate weight breakdown
  const bumperWeight = calculateTotalBumperWeight(pw, ph);
  const panelWeightOnly = totalWeight - bumperWeight;
  
  // AUTOMATIC DISTRIBUTION CALCULATION
  const processorId = document.getElementById('processor').value;
  let distributionBoxName = '';
  let distributionCount = 0;
  
  if(processorId === 'Brompton_SX40' && portsNeeded > 0) {
    const baseDistributionCount = Math.ceil(portsNeeded / 10);
    distributionCount = redundancy ? baseDistributionCount * 2 : baseDistributionCount;
    distributionBoxName = 'Brompton XD';
  } else if(processorId === 'NovaStar_MX40_Pro' && portsNeeded > 0) {
    const baseDistributionCount = Math.ceil(portsNeeded / 10);
    distributionCount = redundancy ? baseDistributionCount * 2 : baseDistributionCount;
    distributionBoxName = 'NovaStar CVT';
  }

  // Build HTML output matching the example format
  let html = '';
  
  // Get unit labels for display
  const lenUnit = getLengthUnitLabel();
  const wtUnit = getWeightUnitLabel();
  
  // Convert values based on selected units
  const panelWidthDisplay = displayLengthUnit === 'ft' ? (p.width_m * M_TO_FT).toFixed(3) : p.width_m.toFixed(3);
  const panelHeightDisplay = displayLengthUnit === 'ft' ? (p.height_m * M_TO_FT).toFixed(3) : p.height_m.toFixed(3);
  const wallWidthDisplay = displayLengthUnit === 'ft' ? wallWF.toFixed(2) : wallWM.toFixed(2);
  const wallHeightDisplay = displayLengthUnit === 'ft' ? adjustedWallHF.toFixed(2) : adjustedWallHM.toFixed(2);
  const panelWeightDisplay = displayWeightUnit === 'lbs' ? (p.weight_kg * KG_TO_LBS).toFixed(2) : p.weight_kg.toFixed(2);
  const totalWeightDisplay = displayWeightUnit === 'lbs' ? totalWeightLbs.toFixed(2) : totalWeight.toFixed(2);
  const panelOnlyWeightDisplay = displayWeightUnit === 'lbs' ? (panelWeightOnly * KG_TO_LBS).toFixed(2) : panelWeightOnly.toFixed(2);
  const bumperWeightDisplay = displayWeightUnit === 'lbs' ? (bumperWeight * KG_TO_LBS).toFixed(2) : bumperWeight.toFixed(2);
  
  // PANEL Section
  html += `<div class="result-row"><strong>Panel:</strong> ${p.brand} ${p.name}</div>`;
  html += `<div class="result-row"><strong>Pixel pitch:</strong> ${p.pixel_pitch_mm} mm</div>`;
  html += `<div class="result-row"><strong>Panel size:</strong> ${panelWidthDisplay} ${lenUnit} Ã— ${panelHeightDisplay} ${lenUnit}</div>`;
  html += `<div class="result-row"><strong>Panel res:</strong> ${p.res_x} Ã— ${p.res_y}</div>`;
  if(p.brightness_nits) html += `<div class="result-row"><strong>Brightness:</strong> ${p.brightness_nits} nits</div>`;
  if(p.weight_kg) html += `<div class="result-row"><strong>Weight per panel:</strong> ${panelWeightDisplay} ${wtUnit}</div>`;
  html += `<div class="result-row"><strong>Panel power (Max/Avg):</strong> ${p.power_max_w} W / ${p.power_avg_w} W</div>`;
  if(p.max_hanging !== null && p.max_hanging !== undefined) html += `<div class="result-row"><strong>Max hanging:</strong> ${p.max_hanging} Panels</div>`;
  if(p.max_stacking !== null && p.max_stacking !== undefined) html += `<div class="result-row"><strong>Max Stacking:</strong> ${p.max_stacking} Panels</div>`;
  if(p.bumper_1w_lbs !== null && p.bumper_1w_lbs !== undefined) {
    const b1w = displayWeightUnit === 'lbs' ? p.bumper_1w_lbs.toFixed(1) : (p.bumper_1w_lbs * LBS_TO_KG).toFixed(1);
    const b2w = displayWeightUnit === 'lbs' ? p.bumper_2w_lbs.toFixed(1) : (p.bumper_2w_lbs * LBS_TO_KG).toFixed(1);
    html += `<div class="result-row"><strong>Bumper Weights:</strong> 1W= ${b1w} ${wtUnit}, 2W= ${b2w} ${wtUnit}</div>`;
  }
  
  // WALL Section
  html += `<br><br>`;
  html += `<div class="result-section-title">WALL</div>`;
  html += `<div class="result-row"><strong>Dimensions:</strong> ${wallWidthDisplay} ${lenUnit} Ã— ${wallHeightDisplay} ${lenUnit} (${pw} Ã— ${ph} panels${hasCB5HalfRow ? ' + half row' : ''})</div>`;
  html += `<div class="result-row"><strong>Total panel count:</strong> ${totalPanels}</div>`;
  html += `<div class="result-row"><strong>Resolution:</strong> ${resX} Ã— ${resY}</div>`;
  html += `<div class="result-row"><strong>Total pixel count:</strong> (${totalPixels.toLocaleString()} px)</div>`;
  html += `<div class="result-row"><strong>Aspect ratio:</strong> ${ar.label}</div>`;
  html += `<div class="result-row"><strong>Total weight:</strong> ${totalWeightDisplay} ${wtUnit}</div>`;
  if(bumperWeight > 0) {
    html += `<div class="result-row result-indent"><strong>Panels:</strong> ${panelOnlyWeightDisplay} ${wtUnit}</div>`;
    html += `<div class="result-row result-indent"><strong>Bumpers:</strong> ${bumperWeightDisplay} ${wtUnit}</div>`;
  }
  
  // POWER Section
  html += `<br>`;
  html += `<div class="result-section-title">POWER (${powerType.toUpperCase()})</div>`;
  html += `<div class="result-row"><strong>Total wall power:</strong> ${totalPowerW.toLocaleString()} W</div>`;
  html += `<div class="result-row"><strong>Total amps:</strong> ${ampsSingle.toFixed(2)} A @ ${voltage} V</div>`;
  if(phase === 3) html += `<div class="result-row"><strong>Total amps per phase:</strong> ${ampsPerPhase.toFixed(2)} A @ ${voltage} V</div>`;
  html += `<div class="result-row"><strong>Max panels per circuit:</strong> ${panelsPerCircuit}</div>`;
  html += `<div class="result-row"><strong>Estimated circuits:</strong> ${circuitsByColumns}</div>`;
  
  // DATA Section
  html += `<br>`;
  html += `<div class="result-section-title">DATA</div>`;
  html += `<div class="result-row"><strong>Processor:</strong> ${pr.name}</div>`;
  if(distributionBoxName) {
    html += `<div class="result-row"><strong>Distribution box:</strong> ${distributionBoxName}${distributionCount > 0 ? ` (${distributionCount})` : ''}</div>`;
  }
  html += `<div class="result-row"><strong>Port Capacity:</strong> ${adjustedCapacity.toLocaleString()} px</div>`;
  html += `<div class="result-row"><strong>Max panels per data line:</strong> ${panelsPerDataLine}</div>`;
  html += `<div class="result-row"><strong>Estimated 1G ports needed:</strong> ${portsNeededFinal}</div>`;
  html += `<div class="result-row"><strong>Estimated data lines:</strong> ${dataLinesFinal}</div>`;
  html += `<div class="result-row"><strong>Frame Rate:</strong> ${frameRate} Hz</div>`;
  html += `<div class="result-row"><strong>Bit Depth:</strong> ${bitDepth}-bit</div>`;
  html += `<div class="result-row"><strong>Screen resolution:</strong> ${resX} Ã— ${resY}</div>`;
  html += `<div class="result-row"><strong>Redundancy:</strong> ${redundancy ? 'Yes' : 'No'}</div>`;

  document.getElementById('results').innerHTML = html;
  
  // Store calculated values for gear list to use
  if(screens[currentScreenId]) {
    screens[currentScreenId].calculatedData = {
      // Equipment
      processorName: pr.name,
      processorCount: 1,
      distributionBoxCount: distributionCount,
      distributionBoxName: distributionBoxName,
      panelCount: totalPanels,
      activePanels: totalPanels, // Same as totalPanels (deletedPanels already accounted for)
      
      // Rigging
      bumper1wCount: bumpers.filter(b => b.type === '1w').length,
      bumper2wCount: bumpers.filter(b => b.type === '2w').length,
      bumper4wCount: bumpers.filter(b => b.type === '4w').length,
      
      // Data
      dataLines: dataLines,
      portsNeeded: portsNeeded,
      portsNeededFinal: portsNeededFinal,
      
      // Power
      circuitsNeeded: circuitsByColumns,
      socaCount: Math.ceil(circuitsByColumns / 6),
      columnsPerCircuit: columnsPerCircuit
    };
  }
  
  generateLayout('standard');
  generateStructureLayout();
  generateLayout('power');
  generateLayout('data');
  showCanvasView();
}

function lightenColor(hex, percent) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  const newR = Math.min(255, Math.floor(r + (255 - r) * percent));
  const newG = Math.min(255, Math.floor(g + (255 - g) * percent));
  const newB = Math.min(255, Math.floor(b + (255 - b) * percent));
  return `#${newR.toString(16).padStart(2,'0')}${newG.toString(16).padStart(2,'0')}${newB.toString(16).padStart(2,'0')}`;
}

function hexToRgba(hex, alpha){
  const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function getContrastColor(hex){
  const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
  const brightness=(r*299+g*587+b*114)/1000;
  return brightness<128?'#FFFFFF':'#000000';
}
function colorForIndex(i){
  const base=resistorColors[i%10];
  const cycle=Math.floor(i/10);
  const alpha=Math.max(0.4, 1 - cycle*0.2);
  return { fill: hexToRgba(base, alpha), text: getContrastColor(base), solid: base };
}

// Make colors more vibrant for PDF export by increasing saturation and darkening slightly
function getVibrantColorForPDF(hexColor) {
  // Special case for white - use dark gray instead
  if(hexColor === '#FFFFFF') {
    return '#4A4A4A'; // Dark gray for white
  }
  
  // Special case for yellow - make it more saturated/darker
  if(hexColor === '#FFFF00') {
    return '#DAA520'; // Goldenrod instead of pure yellow
  }
  
  // For other colors, increase saturation and darken slightly
  const r = parseInt(hexColor.slice(1,3), 16);
  const g = parseInt(hexColor.slice(3,5), 16);
  const b = parseInt(hexColor.slice(5,7), 16);
  
  // Convert to HSL for easier saturation adjustment
  const rNorm = r / 255;
  const gNorm = g / 255;
  const bNorm = b / 255;
  
  const max = Math.max(rNorm, gNorm, bNorm);
  const min = Math.min(rNorm, gNorm, bNorm);
  const l = (max + min) / 2;
  
  let h, s;
  if(max === min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch(max) {
      case rNorm: h = ((gNorm - bNorm) / d + (gNorm < bNorm ? 6 : 0)) / 6; break;
      case gNorm: h = ((bNorm - rNorm) / d + 2) / 6; break;
      case bNorm: h = ((rNorm - gNorm) / d + 4) / 6; break;
    }
  }
  
  // Increase saturation by 20% and darken by 15%
  s = Math.min(1, s * 1.2);
  const newL = Math.max(0.25, l * 0.85); // Don't go too dark, minimum lightness of 0.25
  
  // Convert back to RGB
  function hue2rgb(p, q, t) {
    if(t < 0) t += 1;
    if(t > 1) t -= 1;
    if(t < 1/6) return p + (q - p) * 6 * t;
    if(t < 1/2) return q;
    if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
  }
  
  let rNew, gNew, bNew;
  if(s === 0) {
    rNew = gNew = bNew = newL;
  } else {
    const q = newL < 0.5 ? newL * (1 + s) : newL + s - newL * s;
    const p = 2 * newL - q;
    rNew = hue2rgb(p, q, h + 1/3);
    gNew = hue2rgb(p, q, h);
    bNew = hue2rgb(p, q, h - 1/3);
  }
  
  const rFinal = Math.round(rNew * 255);
  const gFinal = Math.round(gNew * 255);
  const bFinal = Math.round(bNew * 255);
  
  return `#${rFinal.toString(16).padStart(2,'0')}${gFinal.toString(16).padStart(2,'0')}${bFinal.toString(16).padStart(2,'0')}`;
}

function getCanvasDescription() {
  const p = panels[document.getElementById('panelType').value];
  const {pw, ph} = getEffectivePanelCounts();
  
  // Check if CB5 half panel row is enabled
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && document.getElementById('panelType').value === 'CB5_MKII';
  
  // Calculate wall resolution accounting for CB5 half panels
  let wallResX, wallResY;
  if(hasCB5HalfRow) {
    const halfPanel = panels['CB5_MKII_HALF'];
    wallResX = pw * p.res_x;
    wallResY = (ph - 1) * p.res_y + halfPanel.res_y; // Main rows + half row
  } else {
    wallResX = pw * p.res_x;
    wallResY = ph * p.res_y;
  }
  
  const canvasSize = document.getElementById('canvasSize').value;
  let canvasResX, canvasResY;
  
  if(canvasSize === 'custom') {
    canvasResX = parseInt(document.getElementById('customCanvasWidth').value) || 1920;
    canvasResY = parseInt(document.getElementById('customCanvasHeight').value) || 1080;
  } else if(canvasSize === '4K_UHD') {
    canvasResX = 3840;
    canvasResY = 2160;
  } else if(canvasSize === '4K_DCI') {
    canvasResX = 4096;
    canvasResY = 2160;
  } else if(canvasSize === 'HD') {
    canvasResX = 1920;
    canvasResY = 1080;
  } else {
    // Fallback
    canvasResX = 1920;
    canvasResY = 1080;
  }
  
  const canvasX = parseInt(document.getElementById('canvasX').value) || 0;
  const canvasY = parseInt(document.getElementById('canvasY').value) || 0;
  
  // Calculate coverage percentage
  const canvasArea = canvasResX * canvasResY;
  const wallArea = wallResX * wallResY;
  const coverage = ((canvasArea / wallArea) * 100).toFixed(1);
  
  // Get screen name from the current screen object
  const screen = screens[currentScreenId];
  const screenName = screen ? screen.name : '';
  const namePrefix = screenName ? `${screenName} - ` : '';
  
  const panelDescription = hasCB5HalfRow ? `${pw} Ã— ${ph} + half row panels` : `${pw} Ã— ${ph} panels`;
  
  return `${namePrefix}Wall Resolution: ${wallResX} Ã— ${wallResY} px (${panelDescription})\nCanvas Resolution: ${canvasResX} Ã— ${canvasResY} px\nPosition: X=${canvasX}px, Y=${canvasY}px\nCoverage: ${coverage}%`;
}

// Create outline-only version of standard layout for PDF
function createOutlineOnlyStandardCanvas() {
  const sourceCanvas = document.getElementById('standardCanvas');
  if(!sourceCanvas || sourceCanvas.width === 0) return null;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = sourceCanvas.width;
  tempCanvas.height = sourceCanvas.height;
  const ctx = tempCanvas.getContext('2d');
  
  // White background
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
  
  const {pw, ph} = getEffectivePanelCounts();
  const size = panelSize;
  
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++){
      const panelKey = `${c},${r}`;
      const x = c * size;
      const y = r * size;
      
      if(deletedPanels.has(panelKey)) {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(x, y, size, size);
        ctx.setLineDash([]);
        continue;
      }
      
      // White fill
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, size, size);
      
      // Color outline - make more vibrant for PDF
      const baseColor = getStandardColorForPanel(c, r);
      const outlineColor = getVibrantColorForPDF(baseColor);
      ctx.strokeStyle = outlineColor;
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, size, size);
      
      // Panel number
      ctx.fillStyle = '#000000';
      ctx.fillText(`${c+1}.${r+1}`, x+size/2, y+size/2);
    }
  }
  
  return tempCanvas;
}

// Create outline-only version of power layout for PDF
function createOutlineOnlyPowerCanvas() {
  const sourceCanvas = document.getElementById('powerCanvas');
  if(!sourceCanvas || sourceCanvas.width === 0) return null;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = sourceCanvas.width;
  tempCanvas.height = sourceCanvas.height;
  const ctx = tempCanvas.getContext('2d');
  
  // White background
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
  
  const {pw, ph} = getEffectivePanelCountsForLayout();
  const size = 50;
  const socaLabelHeight = 60;
  
  // Calculate panelsPerCircuit the same way as in calculate() function
  const p = panels[document.getElementById('panelType').value];
  const powerType = document.getElementById('powerType').value;
  const voltage = parseInt(document.getElementById('voltage').value) || 208;
  const breaker = parseInt(document.getElementById('breaker').value) || 20;
  // Derate removed - default to no derating
  const derate = 1.0; // Derating disabled
  const activePanelsCount = (pw * ph) - deletedPanels.size;
  const perPanelW = powerType === 'max' ? p.power_max_w : (p.power_avg_w || p.power_max_w * 0.5);
  const circuitCapacityW = voltage * breaker * derate;
  const calculatedPanelsPerCircuit = Math.max(1, Math.floor(circuitCapacityW / perPanelW));
  const userMaxPanelsPerCircuit = parseInt(document.getElementById('maxPanelsPerCircuit').value);
  const panelsPerCircuit = userMaxPanelsPerCircuit > 0 ? userMaxPanelsPerCircuit : calculatedPanelsPerCircuit;
  
  // Copy SOCA labels from original canvas
  const sourceCtx = sourceCanvas.getContext('2d');
  const labelData = sourceCtx.getImageData(0, 0, sourceCanvas.width, socaLabelHeight);
  ctx.putImageData(labelData, 0, 0);
  
  // STEP 1: Build list of all panels in order (column by column, top to bottom) - SAME AS ORIGINAL
  const orderedPanels = [];
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++){
      const panelKey = `${c},${r}`;
      if(!deletedPanels.has(panelKey)) {
        orderedPanels.push({
          key: panelKey,
          col: c,
          row: r,
          isCustom: customCircuitAssignments.has(panelKey),
          customCircuit: customCircuitAssignments.has(panelKey) ? customCircuitAssignments.get(panelKey) - 1 : null
        });
      }
    }
  }
  
  // STEP 2: Collect all custom circuit numbers that are in use - SAME AS ORIGINAL
  const usedCustomCircuits = new Set();
  orderedPanels.forEach(p => {
    if(p.isCustom) {
      usedCustomCircuits.add(p.customCircuit);
    }
  });
  
  // STEP 3: Assign circuit numbers - SAME AS ORIGINAL
  const panelToCircuit = new Map();
  let autoCircuitCounter = 0;
  let panelsInCurrentAutoCircuit = 0;
  
  orderedPanels.forEach(panel => {
    if(panel.isCustom) {
      // Keep custom assignment
      panelToCircuit.set(panel.key, panel.customCircuit);
    } else {
      // Find next available circuit number (skip over custom assignments)
      while(usedCustomCircuits.has(autoCircuitCounter)) {
        autoCircuitCounter++;
      }
      
      // Auto-assign to current circuit
      panelToCircuit.set(panel.key, autoCircuitCounter);
      panelsInCurrentAutoCircuit++;
      
      // Move to next circuit when we reach the limit
      if(panelsInCurrentAutoCircuit >= panelsPerCircuit) {
        autoCircuitCounter++;
        panelsInCurrentAutoCircuit = 0;
        
        // Skip over any custom circuits
        while(usedCustomCircuits.has(autoCircuitCounter)) {
          autoCircuitCounter++;
        }
      }
    }
  });
  
  ctx.font = '11px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Draw all panels
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++){
      const panelKey = `${c},${r}`;
      const x = c * size;
      const y = r * size + socaLabelHeight;
      
      if(deletedPanels.has(panelKey)) {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(x, y, size, size);
        ctx.setLineDash([]);
        continue;
      }
      
      const circuitNum = panelToCircuit.get(panelKey);
      if(circuitNum === undefined) continue;
      
      const socaGroup = Math.floor(circuitNum / 6);
      const colorIndex = circuitNum % 6;
      const colors = colorForIndex(colorIndex);
      const lightenPercent = socaGroup * 0.15;
      const baseColor = lightenColor(colors.solid, lightenPercent);
      
      // Make color more vibrant for PDF
      const outlineColor = getVibrantColorForPDF(baseColor);
      
      // White fill
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, size, size);
      
      // Color outline - use thicker line for better visibility
      ctx.strokeStyle = outlineColor;
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, size, size);
      
      // Panel number
      ctx.fillStyle = '#000000';
      ctx.fillText(`${c+1}.${r+1}`, x+size/2, y+size/2);
    }
  }
  
  return tempCanvas;
}

// Create outline-only version of data layout for PDF
function createOutlineOnlyDataCanvas() {
  const sourceCanvas = document.getElementById('dataCanvas');
  if(!sourceCanvas || sourceCanvas.width === 0) return null;
  
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = sourceCanvas.width;
  tempCanvas.height = sourceCanvas.height;
  const ctx = tempCanvas.getContext('2d');
  
  // White background
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
  
  const {pw, ph} = getEffectivePanelCounts();
  const size = 50;
  
  // Calculate panelsPerDataLine the same way as in calculate() function
  const p = panels[document.getElementById('panelType').value];
  const pr = processors[document.getElementById('processor').value];
  const pixelsPerPanel = p.res_x * p.res_y;
  const frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  const bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  const adjustedCapacity = calculateAdjustedPixelCapacity(pr, frameRate, bitDepth);
  const suggestedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
  const userMax = parseInt(document.getElementById('maxPanelsPerData').value);
  const panelsPerDataLine = userMax > 0 ? userMax : suggestedPanelsPerData;
  
  const startDir = document.getElementById('dataStartDir').value;
  
  // Build data path based on start direction (SAME AS ORIGINAL)
  const serp = [];
  
  if(startDir === 'all_top') {
    // All columns start at top (going down)
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          serp.push({c, r});
        }
      }
    }
  } else if(startDir === 'all_bottom') {
    // All columns start at bottom (going up)
    for(let c=0; c<pw; c++){
      for(let r=ph-1; r>=0; r--) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          serp.push({c, r});
        }
      }
    }
  } else {
    // Serpentine pattern (for 'top' and 'bottom')
    const startFromTop = (startDir==='top' || startDir==='top_left');
    for(let c=0; c<pw; c++){
      const dirDown = (c%2===0) ? startFromTop : !startFromTop;
      if(dirDown){ 
        for(let r=0; r<ph; r++) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            serp.push({c, r});
          }
        }
      } else { 
        for(let r=ph-1; r>=0; r--) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            serp.push({c, r});
          }
        }
      }
    }
  }
  
  // Group into data lines with support for custom assignments (SAME AS ORIGINAL)
  const orderedDataPanels = [];
  serp.forEach(panel => {
    const panelKey = `${panel.c},${panel.r}`;
    orderedDataPanels.push({
      c: panel.c,
      r: panel.r,
      key: panelKey,
      isCustom: customDataLineAssignments.has(panelKey),
      customDataLine: customDataLineAssignments.has(panelKey) ? customDataLineAssignments.get(panelKey) - 1 : null
    });
  });
  
  // Collect all custom data line numbers in use
  const usedCustomDataLines = new Set();
  orderedDataPanels.forEach(p => {
    if(p.isCustom) {
      usedCustomDataLines.add(p.customDataLine);
    }
  });
  
  // Assign data line numbers
  const panelToDataLine = new Map();
  let autoDataLineCounter = 0;
  let panelsInCurrentAutoDataLine = 0;
  
  orderedDataPanels.forEach(panel => {
    if(panel.isCustom) {
      // Keep custom assignment
      panelToDataLine.set(panel.key, panel.customDataLine);
    } else {
      // Find next available data line number (skip over custom assignments)
      while(usedCustomDataLines.has(autoDataLineCounter)) {
        autoDataLineCounter++;
      }
      
      // Auto-assign to current data line
      panelToDataLine.set(panel.key, autoDataLineCounter);
      panelsInCurrentAutoDataLine++;
      
      // Move to next data line when we reach the limit
      if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
        autoDataLineCounter++;
        panelsInCurrentAutoDataLine = 0;
        
        // Skip over any custom data lines
        while(usedCustomDataLines.has(autoDataLineCounter)) {
          autoDataLineCounter++;
        }
      }
    }
  });
  
  // Build groups based on data line assignments
  const dataLineGroups = new Map();
  orderedDataPanels.forEach(panel => {
    const dataLine = panelToDataLine.get(panel.key);
    if(!dataLineGroups.has(dataLine)) {
      dataLineGroups.set(dataLine, []);
    }
    dataLineGroups.get(dataLine).push({c: panel.c, r: panel.r});
  });
  
  // Convert to array sorted by data line number
  const groups = [];
  const sortedDataLines = Array.from(dataLineGroups.keys()).sort((a, b) => a - b);
  sortedDataLines.forEach(dataLine => {
    groups.push(dataLineGroups.get(dataLine));
  });
  
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Draw deleted panels first
  for(let c=0; c<pw; c++){
    for(let r=0; r<ph; r++){
      const panelKey = `${c},${r}`;
      const x = c * size;
      const y = r * size;
      
      if(deletedPanels.has(panelKey)) {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(x, y, size, size);
        ctx.setLineDash([]);
      }
    }
  }
  
  // Draw active panels with data grouping
  for(let gi=0; gi<groups.length; gi++){
    const colors = colorForIndex(gi);
    const vibrantColor = getVibrantColorForPDF(colors.solid);
    
    for(let idx=0; idx<groups[gi].length; idx++){
      const pnt = groups[gi][idx];
      const x = pnt.c * size;
      const y = pnt.r * size;
      
      // White fill
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, size, size);
      
      // Color outline - use thicker line for better visibility
      ctx.strokeStyle = vibrantColor;
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, size, size);
      
      // Panel number
      ctx.fillStyle = '#000000';
      ctx.fillText(`${pnt.c+1}.${pnt.r+1}`, x+size/2, y+size/2);
    }
  }
  
  return tempCanvas;
}

function getStandardColorForPanel(c, r){
  // Get the current screen's colors (same as canvas view)
  const currentScreen = screens[currentScreenId];
  const primaryColor = currentScreen ? currentScreen.color : '#808080';
  const secondaryColor = currentScreen ? (currentScreen.color2 || darkenColor(primaryColor, 30)) : '#606060';
  
  // Alternate colors in a checkerboard pattern (same logic as canvas view)
  const isEvenPanel = (c + r) % 2 === 0;
  return isEvenPanel ? primaryColor : secondaryColor;
}

function getEffectivePanelCountsForLayout(){ 
  const {pw, ph} = getEffectivePanelCounts(); 
  
  // Check if CB5 half panel row is enabled
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && document.getElementById('panelType').value === 'CB5_MKII';
  
  // Add an extra row if CB5 half panels are enabled
  const adjustedPh = hasCB5HalfRow ? ph + 1 : ph;
  
  return {pw, ph: adjustedPh}; 
}

function generateLayout(mode){
  lastLayoutMode = mode;
  const p=panels[document.getElementById('panelType').value];
  if(!p.width_m || !p.height_m){ return; }
  const proc=processors[document.getElementById('processor').value];
  const voltage=parseFloat(document.getElementById('voltage').value)||220;
  const breaker=parseFloat(document.getElementById('breaker').value)||20;
  const powerType=document.getElementById('powerType').value;
  const perPanelW = powerType==='max' ? (p.power_max_w||0) : (p.power_avg_w||0);
  // Derate removed - default to no derating
  const derate = 1.0; // Derating disabled
  const circuitW=voltage*breaker*derate;
  const calculatedPanelsPerCircuit=Math.max(1, Math.floor(circuitW/Math.max(1,perPanelW)||1));
  
  // Get user override or use calculated value
  const userMaxPanelsPerCircuit = parseInt(document.getElementById('maxPanelsPerCircuit').value);
  const panelsPerCircuit = userMaxPanelsPerCircuit > 0 ? userMaxPanelsPerCircuit : calculatedPanelsPerCircuit;
  
  const pixelsPerPanel=(p.res_x&&p.res_y)?p.res_x*p.res_y: (176*176);
  const frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  const bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  const adjustedCapacity = calculateAdjustedPixelCapacity(proc, frameRate, bitDepth);
  
  // Calculate suggested panels per data line accounting for CB5 half panels
  let capacityBasedPanelsPerData;
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && document.getElementById('panelType').value === 'CB5_MKII';
  
  if(hasCB5HalfRow) {
    // With half panels, calculate based on average pixels per panel
    const {pw, ph} = getEffectivePanelCounts();
    const totalPanelsGrid = pw * ph;
    const activePanelsCount = totalPanelsGrid - deletedPanels.size;
    const halfPanel = panels['CB5_MKII_HALF'];
    const halfPanelPixels = halfPanel.res_x * halfPanel.res_y;
    const mainPanelCount = activePanelsCount - pw; // All except bottom row
    const halfPanelCount = pw; // Bottom row
    const totalPixels = (mainPanelCount * pixelsPerPanel) + (halfPanelCount * halfPanelPixels);
    const avgPixelsPerPanel = totalPixels / activePanelsCount;
    capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / avgPixelsPerPanel));
  } else {
    capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
  }
  
  // Apply panel-specific max_panels_per_data limit (same logic as calculate())
  const panelSpecificDataLimit = p.max_panels_per_data || null;
  const suggestedPanelsPerData = panelSpecificDataLimit 
    ? Math.min(capacityBasedPanelsPerData, panelSpecificDataLimit)
    : capacityBasedPanelsPerData;
  
  const userMax = parseInt(document.getElementById('maxPanelsPerData').value);
  const panelsPerDataLine = (mode==='data') ? (userMax>0?userMax:suggestedPanelsPerData) : null;
  const startDirEl = document.getElementById('dataStartDir');
  const startDir = startDirEl ? startDirEl.value : 'top';
  // Using showArrowsEnabled toggle state
  const showArrows = showArrowsEnabled;

  const {pw, ph} = getEffectivePanelCountsForLayout();

  let canvasId, containerId;
  if(mode === 'standard'){
    canvasId = 'standardCanvas';
    containerId = 'standardContainer';
    
    // Setup interactivity after first render
    setTimeout(() => setupStandardCanvasInteractivity(), 10);
  } else if(mode === 'power'){
    canvasId = 'powerCanvas';
    containerId = 'powerContainer';
  } else {
    canvasId = 'dataCanvas';
    containerId = 'dataContainer';
  }

  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const size = 50;
  canvas.width = pw * size;
  canvas.height = ph * size;
  document.getElementById(containerId).style.display = 'block';

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.font = '11px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  if(mode==='standard'){
    currentCanvas = canvas;
    currentPw = pw;
    currentPh = ph;
    panelSize = size;
    
    for(let c=0;c<pw;c++){ 
      for(let r=0;r<ph;r++){
        const panelKey = `${c},${r}`;
        
        // Skip deleted panels
        if(deletedPanels.has(panelKey)) {
          const x=c*size, y=r*size;
          ctx.fillStyle = '#1a1a1a'; // Dark background for deleted
          ctx.fillRect(x, y, size, size);
          ctx.strokeStyle = '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(x, y, size, size);
          ctx.setLineDash([]);
          continue;
        }
        
        const x=c*size, y=r*size;
        const fillColor = getStandardColorForPanel(c, r);
        ctx.fillStyle = fillColor;
        ctx.fillRect(x, y, size, size);
        
        // Highlight selected panels
        if(selectedPanels.has(panelKey)) {
          ctx.strokeStyle = '#00FF00';
          ctx.lineWidth = 4;
          ctx.strokeRect(x+2, y+2, size-4, size-4);
        }
        
        // Show indicators for custom assignments
        if(customCircuitAssignments.has(panelKey)) {
          ctx.fillStyle = '#FFD700'; // Gold indicator for circuit
          ctx.fillRect(x+size-10, y+2, 8, 8);
        }
        if(customDataLineAssignments.has(panelKey)) {
          ctx.fillStyle = '#00CED1'; // Cyan indicator for data line
          ctx.fillRect(x+2, y+size-10, 8, 8);
        }
        
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, size, size);
        ctx.fillStyle = '#000000'; // Always use black text (no black panels in standard layout)
        ctx.fillText(`${c+1}.${r+1}`, x+size/2, y+size/2);
      }
    }
    
    return;
  }

  if(mode==='power'){
    // Power layout rule: Always start circuits at the top of each column
    // Knockouts in a column split that column into separate circuit segments
    
    const socaLabelHeight = 60;
    canvas.height = ph * size + socaLabelHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Build column-by-column circuit assignments
    const columnCircuits = []; // Array of circuit segments per column
    let globalCircuitIndex = 0;
    
    for(let c=0; c<pw; c++){
      const columnPanels = [];
      
      // Collect active panels in this column from top to bottom
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          columnPanels.push({c, r, key: panelKey});
        }
      }
      
      // Split column into circuit segments based on panelsPerCircuit
      let circuitSegments = [];
      for(let i=0; i<columnPanels.length; i += panelsPerCircuit){
        const segment = columnPanels.slice(i, i + panelsPerCircuit);
        if(segment.length > 0) {
          circuitSegments.push({
            circuitNum: globalCircuitIndex++,
            panels: segment
          });
        }
      }
      
      columnCircuits.push(circuitSegments);
    }
    
    // Flatten all circuits for SOCA grouping
    const allCircuits = [];
    columnCircuits.forEach(col => {
      col.forEach(seg => {
        allCircuits.push(seg);
      });
    });
    
    // STEP 1: Build list of all panels in order (column by column, top to bottom)
    const orderedPanels = [];
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          orderedPanels.push({
            key: panelKey,
            col: c,
            row: r,
            isCustom: customCircuitAssignments.has(panelKey),
            customCircuit: customCircuitAssignments.has(panelKey) ? customCircuitAssignments.get(panelKey) - 1 : null
          });
        }
      }
    }
    
    // STEP 2: Collect all custom circuit numbers that are in use
    const usedCustomCircuits = new Set();
    orderedPanels.forEach(p => {
      if(p.isCustom) {
        usedCustomCircuits.add(p.customCircuit);
      }
    });
    
    // STEP 3: Assign circuit numbers
    const panelToCircuit = new Map();
    let autoCircuitCounter = 0;
    let panelsInCurrentAutoCircuit = 0;
    
    orderedPanels.forEach(panel => {
      if(panel.isCustom) {
        // Keep custom assignment
        panelToCircuit.set(panel.key, panel.customCircuit);
      } else {
        // Find next available circuit number (skip over custom assignments)
        while(usedCustomCircuits.has(autoCircuitCounter)) {
          autoCircuitCounter++;
        }
        
        // Auto-assign to current circuit
        panelToCircuit.set(panel.key, autoCircuitCounter);
        panelsInCurrentAutoCircuit++;
        
        // Move to next circuit when we reach the limit
        if(panelsInCurrentAutoCircuit >= panelsPerCircuit) {
          autoCircuitCounter++;
          panelsInCurrentAutoCircuit = 0;
          
          // Skip over any custom circuits
          while(usedCustomCircuits.has(autoCircuitCounter)) {
            autoCircuitCounter++;
          }
        }
      }
    });
    
    // Draw all panels
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        const x = c * size;
        const y = r * size + socaLabelHeight;
        
        // Check if panel is deleted
        if(deletedPanels.has(panelKey)) {
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x, y, size, size);
          ctx.strokeStyle = '#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(x, y, size, size);
          ctx.setLineDash([]);
          continue;
        }
        
        // Get circuit number for this panel
        const circuitNum = panelToCircuit.get(panelKey);
        if(circuitNum === undefined) continue;
        
        // Determine which SOCA group this circuit belongs to
        const socaGroup = Math.floor(circuitNum / 6);
        const colorIndex = circuitNum % 6;
        const colors = colorForIndex(colorIndex);
        
        // Lighten the color based on SOCA group (10% lighter for each SOCA)
        const lightenPercent = socaGroup * 0.15; // 15% lighter per SOCA group
        const fillColor = lightenColor(colors.solid, lightenPercent);
        
        ctx.fillStyle = fillColor;
        ctx.fillRect(x, y, size, size);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, size, size);
        
        // Always use black text (no black panels in power layout)
        ctx.fillStyle = '#000000';
        
        ctx.font = '11px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${c+1}.${r+1}`, x+size/2, y+size/2);
      }
    }
    
    // Draw SOCA labels
    // Find the actual max circuit number used (including custom assignments)
    let maxCircuitNum = 0;
    panelToCircuit.forEach(circuitNum => {
      if(circuitNum > maxCircuitNum) maxCircuitNum = circuitNum;
    });
    const totalCircuits = maxCircuitNum + 1;
    const socaGroups = Math.ceil(totalCircuits / 6);
    
    // Build a map of circuit number -> panels with that circuit
    const circuitPanelMap = new Map();
    for(let c=0; c<pw; c++){
      for(let r=0; r<ph; r++){
        const panelKey = `${c},${r}`;
        if(deletedPanels.has(panelKey)) continue;
        
        const circuitNum = panelToCircuit.get(panelKey);
        if(circuitNum !== undefined) {
          if(!circuitPanelMap.has(circuitNum)) {
            circuitPanelMap.set(circuitNum, []);
          }
          circuitPanelMap.get(circuitNum).push({
            c: c,
            r: r,
            x: c * size
          });
        }
      }
    }
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 3;
    ctx.font = 'bold 16px Arial';
    ctx.fillStyle = '#000000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    for(let s = 0; s < socaGroups; s++){
      const startCircuit = s * 6;
      const endCircuit = Math.min((s + 1) * 6 - 1, totalCircuits - 1);
      
      // Find the leftmost and rightmost panels in this SOCA group
      let minX = Infinity;
      let maxX = -Infinity;
      
      for(let circuit = startCircuit; circuit <= endCircuit; circuit++) {
        if(circuitPanelMap.has(circuit)) {
          const panels = circuitPanelMap.get(circuit);
          panels.forEach(p => {
            minX = Math.min(minX, p.x);
            maxX = Math.max(maxX, p.x);
          });
        }
      }
      
      // If no panels found, skip this SOCA
      if(minX === Infinity) continue;
      
      const lineY = 35;
      const startX = minX;
      const endX = maxX + size;
      const midX = (startX + endX) / 2;
      
      // Draw horizontal line across the top
      ctx.beginPath();
      ctx.moveTo(startX, lineY);
      ctx.lineTo(endX, lineY);
      ctx.stroke();
      
      // Draw vertical ticks at the ends
      ctx.beginPath();
      ctx.moveTo(startX, lineY - 8);
      ctx.lineTo(startX, lineY + 8);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(endX, lineY - 8);
      ctx.lineTo(endX, lineY + 8);
      ctx.stroke();
      
      // Draw SOCA label above the line
      ctx.fillText(`SOCA ${s + 1}`, midX, lineY - 20);
      
      // Draw circuit range below the line
      ctx.font = '12px Arial';
      const circuitRange = startCircuit === endCircuit ? 
        `Circuit ${startCircuit + 1}` : 
        `Circuits ${startCircuit + 1}-${endCircuit + 1}`;
      ctx.fillText(circuitRange, midX, lineY + 20);
      ctx.font = 'bold 16px Arial';
    }
    
    return;
  }

  if(mode==='data'){
    // Build data path based on start direction (matching calculateActualDataLines logic)
    const serp = [];
    
    if(startDir === 'all_top') {
      // All columns start at top (going down)
      for(let c=0; c<pw; c++){
        for(let r=0; r<ph; r++) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            serp.push({c, r});
          }
        }
      }
    } else if(startDir === 'all_bottom') {
      // All columns start at bottom (going up)
      for(let c=0; c<pw; c++){
        for(let r=ph-1; r>=0; r--) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            serp.push({c, r});
          }
        }
      }
    } else {
      // Serpentine pattern (for 'top' and 'bottom')
      // Build serpentine path that respects data line boundaries
      const startFromTop = (startDir==='top');
      
      let panelsInCurrentDataLine = 0;
      let currentDataLine = 0;
      let currentColumn = 0;
      let serpentineGoingDown = startFromTop; // Initial direction
      let lastDataLineEndedAtBoundary = true; // First data line starts fresh
      
      while(currentColumn < pw) {
        // Count non-deleted, non-custom panels in this column
        let panelsInColumn = 0;
        for(let r=0; r<ph; r++) {
          const panelKey = `${currentColumn},${r}`;
          if(!deletedPanels.has(panelKey) && !customDataLineAssignments.has(panelKey)) {
            panelsInColumn++;
          }
        }
        
        // Check if adding this entire column would exceed the data line limit
        if(panelsInCurrentDataLine > 0 && panelsInCurrentDataLine + panelsInColumn > panelsPerDataLine) {
          // This column will cause a split - need to add partial column
          const panelsWeCanAdd = panelsPerDataLine - panelsInCurrentDataLine;
          
          if(panelsWeCanAdd > 0) {
            // Add partial column to current data line
            if(serpentineGoingDown) {
              // Going down - add from top
              let added = 0;
              for(let r=0; r<ph && added<panelsWeCanAdd; r++) {
                const panelKey = `${currentColumn},${r}`;
                if(!deletedPanels.has(panelKey)) {
                  serp.push({c: currentColumn, r: r});
                  added++;
                }
              }
              // Data line ends mid-column, not at boundary
              lastDataLineEndedAtBoundary = false;
            } else {
              // Going up - add from bottom
              let added = 0;
              for(let r=ph-1; r>=0 && added<panelsWeCanAdd; r--) {
                const panelKey = `${currentColumn},${r}`;
                if(!deletedPanels.has(panelKey)) {
                  serp.push({c: currentColumn, r: r});
                  added++;
                }
              }
              // Data line ends mid-column, not at boundary
              lastDataLineEndedAtBoundary = false;
            }
          }
          
          // Start new data line
          currentDataLine++;
          panelsInCurrentDataLine = 0;
          
          // If previous data line ended mid-column, continue serpentine in same direction
          // If it ended at boundary, start fresh serpentine
          if(!lastDataLineEndedAtBoundary) {
            // Continue in same column, same direction
            // Don't toggle direction, don't move to next column yet
            // The remaining panels in this column will be added in next iteration
            // But we need to continue adding panels from this column
            const remainingPanels = panelsInColumn - panelsWeCanAdd;
            
            if(serpentineGoingDown) {
              // Continue going down from where we left off
              let added = 0;
              for(let r=panelsWeCanAdd; r<ph && added<Math.min(remainingPanels, panelsPerDataLine); r++) {
                const panelKey = `${currentColumn},${r}`;
                if(!deletedPanels.has(panelKey)) {
                  serp.push({c: currentColumn, r: r});
                  panelsInCurrentDataLine++;
                  added++;
                }
              }
            } else {
              // Continue going up from where we left off
              let added = 0;
              for(let r=ph-1-panelsWeCanAdd; r>=0 && added<Math.min(remainingPanels, panelsPerDataLine); r--) {
                const panelKey = `${currentColumn},${r}`;
                if(!deletedPanels.has(panelKey)) {
                  serp.push({c: currentColumn, r: r});
                  panelsInCurrentDataLine++;
                  added++;
                }
              }
            }
            
            // Check if we finished this column
            if(panelsInCurrentDataLine >= remainingPanels) {
              // Finished column, move to next and toggle direction
              currentColumn++;
              serpentineGoingDown = !serpentineGoingDown;
              
              // Check if this column ended at a boundary
              if(serpentineGoingDown) {
                // Was going up, now going down - ended at top (boundary)
                lastDataLineEndedAtBoundary = true;
              } else {
                // Was going down, now going up - ended at bottom (boundary)
                lastDataLineEndedAtBoundary = true;
              }
            }
            // If we didn't finish the column, we'll continue it in the next data line iteration
            continue;
          } else {
            // Previous data line ended at boundary - start fresh serpentine
            // Reset direction based on start preference
            serpentineGoingDown = startFromTop;
            // Don't increment column - we still need to process this column
          }
        } else {
          // Entire column fits in current data line
          if(serpentineGoingDown) {
            // Going down
            for(let r=0; r<ph; r++) {
              const panelKey = `${currentColumn},${r}`;
              if(!deletedPanels.has(panelKey)) {
                serp.push({c: currentColumn, r: r});
                panelsInCurrentDataLine++;
              }
            }
            // Ended at bottom of column - this is a boundary
            lastDataLineEndedAtBoundary = true;
          } else {
            // Going up
            for(let r=ph-1; r>=0; r--) {
              const panelKey = `${currentColumn},${r}`;
              if(!deletedPanels.has(panelKey)) {
                serp.push({c: currentColumn, r: r});
                panelsInCurrentDataLine++;
              }
            }
            // Ended at top of column - this is a boundary
            lastDataLineEndedAtBoundary = true;
          }
          
          // Move to next column and toggle direction
          currentColumn++;
          serpentineGoingDown = !serpentineGoingDown;
        }
      }
    }
    
    // Group into data lines with support for custom assignments
    // Build ordered list of all panels
    const orderedDataPanels = [];
    serp.forEach(panel => {
      const panelKey = `${panel.c},${panel.r}`;
      orderedDataPanels.push({
        c: panel.c,
        r: panel.r,
        key: panelKey,
        isCustom: customDataLineAssignments.has(panelKey),
        customDataLine: customDataLineAssignments.has(panelKey) ? customDataLineAssignments.get(panelKey) - 1 : null
      });
    });
    
    // Collect all custom data line numbers in use
    const usedCustomDataLines = new Set();
    orderedDataPanels.forEach(p => {
      if(p.isCustom) {
        usedCustomDataLines.add(p.customDataLine);
      }
    });
    
    // Assign data line numbers
    const panelToDataLine = new Map();
    let autoDataLineCounter = 0;
    let panelsInCurrentAutoDataLine = 0;
    
    // Special handling for all_top and all_bottom - each column is its own data line
    if(startDir === 'all_top' || startDir === 'all_bottom') {
      let currentColumn = -1;
      let columnDataLine = 0;
      
      orderedDataPanels.forEach(panel => {
        if(panel.isCustom) {
          // Keep custom assignment
          panelToDataLine.set(panel.key, panel.customDataLine);
        } else {
          // Check if we've moved to a new column
          if(panel.c !== currentColumn) {
            // Moving to new column - get next available data line
            if(currentColumn >= 0) {
              // Not the first column, so increment
              columnDataLine++;
            }
            currentColumn = panel.c;
            
            // Find next available data line number (skip over custom assignments)
            while(usedCustomDataLines.has(columnDataLine)) {
              columnDataLine++;
            }
          }
          
          // All panels in this column use the same data line
          panelToDataLine.set(panel.key, columnDataLine);
        }
      });
    } else {
      // Normal serpentine: split by panelsPerDataLine
      orderedDataPanels.forEach(panel => {
        if(panel.isCustom) {
          // Keep custom assignment
          panelToDataLine.set(panel.key, panel.customDataLine);
        } else {
          // Find next available data line number (skip over custom assignments)
          while(usedCustomDataLines.has(autoDataLineCounter)) {
            autoDataLineCounter++;
          }
          
          // Auto-assign to current data line
          panelToDataLine.set(panel.key, autoDataLineCounter);
          panelsInCurrentAutoDataLine++;
          
          // Move to next data line when we reach the limit
          if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
            autoDataLineCounter++;
            panelsInCurrentAutoDataLine = 0;
            
            // Skip over any custom data lines
            while(usedCustomDataLines.has(autoDataLineCounter)) {
              autoDataLineCounter++;
            }
          }
        }
      });
    }
    
    // Build groups based on data line assignments
    const dataLineGroups = new Map();
    orderedDataPanels.forEach(panel => {
      const dataLine = panelToDataLine.get(panel.key);
      if(!dataLineGroups.has(dataLine)) {
        dataLineGroups.set(dataLine, []);
      }
      dataLineGroups.get(dataLine).push({c: panel.c, r: panel.r});
    });
    
    // Convert to array sorted by data line number
    const groups = [];
    const sortedDataLines = Array.from(dataLineGroups.keys()).sort((a, b) => a - b);
    sortedDataLines.forEach(dataLine => {
      groups.push(dataLineGroups.get(dataLine));
    });

    // Draw all panels first (including deleted)
    for(let c=0;c<pw;c++){
      for(let r=0;r<ph;r++){
        const panelKey = `${c},${r}`;
        const x=c*size, y=r*size;
        
        // Check if panel is deleted
        if(deletedPanels.has(panelKey)) {
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(x,y,size,size);
          ctx.strokeStyle='#333333';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.strokeRect(x,y,size,size);
          ctx.setLineDash([]);
        }
      }
    }

    // Draw active panels with data grouping
    const groupPoints = [];
    for(let gi=0; gi<groups.length; gi++){
      const colors=colorForIndex(gi);
      groupPoints[gi] = [];
      for(let idx=0; idx<groups[gi].length; idx++){
        const pnt = groups[gi][idx];
        const x=pnt.c*size, y=pnt.r*size;
        ctx.fillStyle=colors.fill;
        ctx.fillRect(x,y,size,size);
        ctx.strokeStyle='#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x,y,size,size);
        
        // Use white text only for data line 9 (black resistor color), black text for all others
        ctx.fillStyle = (gi === 9) ? '#FFFFFF' : '#000000';
        
        // Show panel number as column.row (matching standard layout)
        ctx.fillText(`${pnt.c+1}.${pnt.r+1}`, x+size/2, y+size/2);
        groupPoints[gi].push({x:x+size/2, y:y+size/2, color: colors.solid});
      }
    }
    if(showArrows){
      if(startDir === 'all_top' || startDir === 'all_bottom') {
        // For all_top and all_bottom, draw one arrow per column
        // Group points by column
        for(let gi=0; gi<groupPoints.length; gi++){
          const pts = groupPoints[gi];
          if(pts.length<2) continue;
          
          // Group points by column
          const columnGroups = new Map();
          groups[gi].forEach((pnt, idx) => {
            if(!columnGroups.has(pnt.c)) {
              columnGroups.set(pnt.c, []);
            }
            columnGroups.get(pnt.c).push(pts[idx]);
          });
          
          // Draw arrow for each column
          columnGroups.forEach((columnPoints) => {
            if(columnPoints.length >= 2) {
              drawArrowPath(ctx, columnPoints, '#000000');
            }
          });
        }
      } else {
        // For serpentine patterns, only draw arrows between ADJACENT panels in same data line
        // Build segments of continuous adjacent panels
        for(let gi=0; gi<groupPoints.length; gi++){
          const pts = groupPoints[gi];
          const grp = groups[gi];
          if(pts.length<2) continue;
          
          // Build segments - break when panels are not adjacent
          const segments = [];
          let currentSegment = [pts[0]];
          
          for(let i=1; i<pts.length; i++){
            const prev = grp[i-1];
            const curr = grp[i];
            
            // Check if current panel is adjacent to previous (within same column or adjacent columns)
            const colDiff = Math.abs(curr.c - prev.c);
            const rowDiff = Math.abs(curr.r - prev.r);
            
            // Adjacent means: same column (any row), or adjacent columns at top/bottom boundary
            const isAdjacent = (colDiff === 0) || // same column
                               (colDiff === 1 && (prev.r === 0 || prev.r === ph-1 || curr.r === 0 || curr.r === ph-1)); // adjacent column at boundary
            
            if(isAdjacent) {
              currentSegment.push(pts[i]);
            } else {
              // Not adjacent - finish current segment and start new one
              if(currentSegment.length >= 2) {
                segments.push(currentSegment);
              }
              currentSegment = [pts[i]];
            }
          }
          
          // Add final segment
          if(currentSegment.length >= 2) {
            segments.push(currentSegment);
          }
          
          // Draw each segment
          segments.forEach(segment => {
            drawArrowPath(ctx, segment, '#000000');
          });
        }
      }
    }
    return;
  }
}

function drawArrowPath(ctx, points, colorHex){
  ctx.save();
  ctx.strokeStyle = colorHex;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for(let i=1;i<points.length;i++){
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.stroke();

  const end = points[points.length-1];
  const prev = points[points.length-2];
  const angle = Math.atan2(end.y - prev.y, end.x - prev.x);
  drawVArrowhead(ctx, end.x, end.y, angle, colorHex);
  ctx.restore();
}

// Structure View generation
function generateStructureLayout(){
  const p=panels[document.getElementById('panelType').value];
  if(!p.width_m || !p.height_m){ return; }

  const {pw, ph} = getEffectivePanelCountsForLayout();

  const canvas = document.getElementById('structureCanvas');
  const ctx = canvas.getContext('2d');
  const size = 50;
  const bumperHeight = 40; // Height for bumper row
  const fourWayHeight = 20; // Height for 4-way bumper
  const fourWayGap = 5; // Gap between 2W and 4W bumpers
  
  // Check if 4-way bumpers are enabled
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  const has4WayBumpers = use4Way && isCB5;
  
  // Calculate canvas height - add space for bumpers and 4-way bumpers
  let canvasHeight = ph * size;
  if(showTopBumper) {
    canvasHeight += bumperHeight;
    if(has4WayBumpers) canvasHeight += fourWayHeight + fourWayGap;
  }
  if(showBottomBumper) {
    canvasHeight += bumperHeight;
    if(has4WayBumpers) canvasHeight += fourWayHeight + fourWayGap;
  }
  
  canvas.width = pw * size;
  canvas.height = canvasHeight;
  document.getElementById('structureContainer').style.display = 'block';

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Fill entire canvas with dark background (same as deleted panels)
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.font = '11px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Y offset for panels - leave space for top bumper and 4-way if enabled
  let panelYOffset = 0;
  if(showTopBumper) {
    panelYOffset += bumperHeight;
    if(has4WayBumpers) panelYOffset += fourWayHeight + fourWayGap;
  }

  // Draw all panels with black outline and labels
  for(let c=0;c<pw;c++){ 
    for(let r=0;r<ph;r++){
      const panelKey = `${c},${r}`;
      
      // Skip deleted panels - they'll show the dark background
      if(deletedPanels.has(panelKey)) {
        const x=c*size, y=panelYOffset + r*size;
        // Draw dashed outline for deleted panels
        ctx.strokeStyle='#333333';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(x, y, size, size);
        ctx.setLineDash([]);
        continue;
      }
      
      const x=c*size, y=panelYOffset + r*size;
      
      // White background for panels
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(x, y, size, size);
      
      // Black outline
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, size, size);
      
      // Black label
      ctx.fillStyle = '#000000';
      ctx.fillText(`${c+1}.${r+1}`, x+size/2, y+size/2);
    }
  }
  
  // Draw connecting plates if enabled (reusing panelType from above)
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  
  if(useConnectingPlates) {
    const plateThickness = 4; // Thickness of plate indicator
    const plateLength = 12; // Length of 2-way plate indicator
    const plate4WaySize = 8; // Size of 4-way plate square
    
    // Determine if hanging (top bumpers) or ground stacking (bottom bumpers)
    const isHanging = showTopBumper;
    const isGroundStacking = showBottomBumper;
    
    // Draw 2-way plates (yellow) at perimeter intersections only
    
    // LEFT EDGE - vertical 2-way plates at panel joints
    for(let r = 0; r < ph - 1; r++) {
      const panelKey = `0,${r}`;
      const belowKey = `0,${r+1}`;
      if(!deletedPanels.has(panelKey) && !deletedPanels.has(belowKey)) {
        const x = 2; // Left edge
        const y = panelYOffset + (r + 1) * size - plateLength/2; // At the joint between panels
        
        ctx.fillStyle = '#FFD700'; // Gold/yellow for 2-way
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }
    
    // RIGHT EDGE - vertical 2-way plates at panel joints
    for(let r = 0; r < ph - 1; r++) {
      const panelKey = `${pw-1},${r}`;
      const belowKey = `${pw-1},${r+1}`;
      if(!deletedPanels.has(panelKey) && !deletedPanels.has(belowKey)) {
        const x = pw * size - plateThickness - 2; // Right edge
        const y = panelYOffset + (r + 1) * size - plateLength/2; // At the joint between panels
        
        ctx.fillStyle = '#FFD700'; // Gold/yellow for 2-way
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }
    
    // TOP EDGE (if ground stacking) - horizontal 2-way plates at panel joints
    if(isGroundStacking) {
      for(let c = 0; c < pw - 1; c++) {
        const panelKey = `${c},0`;
        const rightKey = `${c+1},0`;
        if(!deletedPanels.has(panelKey) && !deletedPanels.has(rightKey)) {
          const x = (c + 1) * size - plateLength/2; // At the joint between panels
          const y = panelYOffset + 2; // Top edge of panels
          
          ctx.fillStyle = '#FFD700'; // Gold/yellow for 2-way
          ctx.fillRect(x, y, plateLength, plateThickness);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plateLength, plateThickness);
        }
      }
    }
    
    // BOTTOM EDGE (if hanging) - horizontal 2-way plates at panel joints
    if(isHanging) {
      for(let c = 0; c < pw - 1; c++) {
        const panelKey = `${c},${ph-1}`;
        const rightKey = `${c+1},${ph-1}`;
        if(!deletedPanels.has(panelKey) && !deletedPanels.has(rightKey)) {
          const x = (c + 1) * size - plateLength/2; // At the joint between panels
          const y = panelYOffset + ph * size - plateThickness - 2; // Bottom edge of panels
          
          ctx.fillStyle = '#FFD700'; // Gold/yellow for 2-way
          ctx.fillRect(x, y, plateLength, plateThickness);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plateLength, plateThickness);
        }
      }
    }
    
    // CORNER 2-way plates connecting to bumpers
    // TOP-LEFT CORNER (if hanging)
    if(isHanging) {
      const topLeftKey = `0,0`;
      if(!deletedPanels.has(topLeftKey)) {
        // Horizontal plate at top-left
        const x = 2;
        const y = panelYOffset - plateThickness - 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateLength, plateThickness);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateLength, plateThickness);
      }
    }
    
    // TOP-RIGHT CORNER (if hanging)
    if(isHanging) {
      const topRightKey = `${pw-1},0`;
      if(!deletedPanels.has(topRightKey)) {
        // Horizontal plate at top-right
        const x = pw * size - plateLength - 2;
        const y = panelYOffset - plateThickness - 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateLength, plateThickness);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateLength, plateThickness);
      }
    }
    
    // BOTTOM-LEFT CORNER (if ground stacking)
    if(isGroundStacking) {
      const bottomLeftKey = `0,${ph-1}`;
      if(!deletedPanels.has(bottomLeftKey)) {
        // Horizontal plate at bottom-left
        const x = 2;
        const y = panelYOffset + ph * size + 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateLength, plateThickness);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateLength, plateThickness);
      }
    }
    
    // BOTTOM-RIGHT CORNER (if ground stacking)
    if(isGroundStacking) {
      const bottomRightKey = `${pw-1},${ph-1}`;
      if(!deletedPanels.has(bottomRightKey)) {
        // Horizontal plate at bottom-right
        const x = pw * size - plateLength - 2;
        const y = panelYOffset + ph * size + 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateLength, plateThickness);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateLength, plateThickness);
      }
    }
    
    // VERTICAL PLATES at edges where panels meet bumpers
    // TOP-LEFT vertical (if hanging)
    if(isHanging) {
      const topLeftKey = `0,0`;
      if(!deletedPanels.has(topLeftKey)) {
        const x = 2;
        const y = panelYOffset - plateLength/2 - 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }
    
    // TOP-RIGHT vertical (if hanging)
    if(isHanging) {
      const topRightKey = `${pw-1},0`;
      if(!deletedPanels.has(topRightKey)) {
        const x = pw * size - plateThickness - 2;
        const y = panelYOffset - plateLength/2 - 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }
    
    // BOTTOM-LEFT vertical (if ground stacking)
    if(isGroundStacking) {
      const bottomLeftKey = `0,${ph-1}`;
      if(!deletedPanels.has(bottomLeftKey)) {
        const x = 2;
        const y = panelYOffset + ph * size - plateLength/2 + 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }
    
    // BOTTOM-RIGHT vertical (if ground stacking)
    if(isGroundStacking) {
      const bottomRightKey = `${pw-1},${ph-1}`;
      if(!deletedPanels.has(bottomRightKey)) {
        const x = pw * size - plateThickness - 2;
        const y = panelYOffset + ph * size - plateLength/2 + 2;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(x, y, plateThickness, plateLength);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, plateThickness, plateLength);
      }
    }
    
    // Draw 4-way plates (red) at interior panel intersections
    for(let c = 0; c < pw - 1; c++) {
      for(let r = 0; r < ph - 1; r++) {
        const topLeft = `${c},${r}`;
        const topRight = `${c+1},${r}`;
        const bottomLeft = `${c},${r+1}`;
        const bottomRight = `${c+1},${r+1}`;
        
        // Only draw if all 4 panels exist (not deleted)
        if(!deletedPanels.has(topLeft) && !deletedPanels.has(topRight) &&
           !deletedPanels.has(bottomLeft) && !deletedPanels.has(bottomRight)) {
          const x = (c + 1) * size - plate4WaySize/2;
          const y = panelYOffset + (r + 1) * size - plate4WaySize/2;
          
          ctx.fillStyle = '#FF4444'; // Red for 4-way
          ctx.fillRect(x, y, plate4WaySize, plate4WaySize);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plate4WaySize, plate4WaySize);
        }
      }
    }
    
    // Draw 4-way plates (red) connecting panels to TOP BUMPERS (if hanging)
    // Align with interior panel intersections (columns between panels)
    // Show for any panel type that has bumpers (CB5 with 4-way, or DM2.6, etc.)
    if(isHanging && (showTopBumper)) {
      for(let c = 0; c < pw - 1; c++) {
        const topLeftKey = `${c},0`;
        const topRightKey = `${c+1},0`;
        if(!deletedPanels.has(topLeftKey) && !deletedPanels.has(topRightKey)) {
          const x = (c + 1) * size - plate4WaySize/2; // Align with interior intersections
          const y = panelYOffset - plate4WaySize/2; // Between bumper and panel
          
          ctx.fillStyle = '#FF4444'; // Red for 4-way
          ctx.fillRect(x, y, plate4WaySize, plate4WaySize);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plate4WaySize, plate4WaySize);
        }
      }
    }
    
    // Draw 4-way plates (red) connecting panels to BOTTOM BUMPERS (if ground stacking)
    // Align with interior panel intersections (columns between panels)
    // Show for any panel type that has bumpers (CB5 with 4-way, or DM2.6, etc.)
    if(isGroundStacking && (showBottomBumper)) {
      for(let c = 0; c < pw - 1; c++) {
        const bottomLeftKey = `${c},${ph-1}`;
        const bottomRightKey = `${c+1},${ph-1}`;
        if(!deletedPanels.has(bottomLeftKey) && !deletedPanels.has(bottomRightKey)) {
          const x = (c + 1) * size - plate4WaySize/2; // Align with interior intersections
          const y = panelYOffset + ph * size - plate4WaySize/2; // Between panel and bumper
          
          ctx.fillStyle = '#FF4444'; // Red for 4-way
          ctx.fillRect(x, y, plate4WaySize, plate4WaySize);
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, plate4WaySize, plate4WaySize);
        }
      }
    }
  }
  
  // Initialize bumpers if not already done
  if(bumpers.length === 0 && (showTopBumper || showBottomBumper)) {
    initializeBumpers();
  }
  
  // Draw ground support hardware (bridge clamps and ladders) if ground stacking
  const isGroundStacking = showBottomBumper;
  // Track which bumpers have ladders (for drawing ladder bases)
  const bumpersWithLadders = new Set();
  
  if(isGroundStacking) {
    const bridgeClampSize = 14; // Size of bridge clamp indicator
    const ladderWidth = 8; // Width of ladder piece
    const ladderHeightPanels = 2; // Each ladder piece spans 2 panels
    
    // Get columns that have bottom bumpers (ladders are bound to bumpers)
    const columnsWithBumpers = new Set();
    const bumperToColumnMap = new Map(); // Map bumper id to its ladder column
    
    bumpers.filter(b => b.position === 'bottom').forEach(bumper => {
      // For bottom bumpers, get the columns they cover
      const cols = getBumperColumns(bumper);
      if(cols.length > 0) {
        // Check if bumper has a custom ladder column setting
        let ladderCol;
        if(bumper.type === '2w' && bumper.ladderColumn === 'right') {
          // Use the right (second) column
          ladderCol = cols[1] !== undefined ? cols[1] : cols[0];
        } else {
          // Default: use the left (first) column
          ladderCol = cols[0];
        }
        columnsWithBumpers.add(ladderCol);
        bumperToColumnMap.set(bumper.id, ladderCol);
        bumpersWithLadders.add(bumper.id);
      }
    });
    
    // Draw REAR LADDER (cyan) - only in columns with bumpers, centered horizontally
    // Each ladder is 2 panels high, stacked from BOTTOM up
    // Ladders only cover complete 2-panel sections (odd top panel has no ladder)
    ctx.fillStyle = '#00CED1'; // Cyan for ladder pieces
    
    columnsWithBumpers.forEach(c => {
      // Find the topmost and bottommost non-deleted panel in this column
      let topRow = -1;
      let bottomRow = -1;
      
      for(let r = 0; r < ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          if(topRow === -1) topRow = r;
          bottomRow = r;
        }
      }
      
      // Draw ladders if there are panels in this column
      if(topRow !== -1 && bottomRow !== -1) {
        const totalPanelsInColumn = bottomRow - topRow + 1;
        // Only complete 2-panel sections get ladders (from bottom)
        const numLadders = Math.floor(totalPanelsInColumn / ladderHeightPanels);
        
        // Draw each ladder piece from bottom to top
        for(let ladderIndex = 0; ladderIndex < numLadders; ladderIndex++) {
          // Calculate which rows this ladder covers (from bottom)
          const ladderBottomRow = bottomRow - (ladderIndex * ladderHeightPanels);
          const ladderTopRow = ladderBottomRow - ladderHeightPanels + 1;
          
          // Skip if ladder would be above the topmost panel
          if(ladderTopRow < topRow) continue;
          
          const ladderX = c * size + size/2 - ladderWidth/2; // Centered in column
          const ladderTopY = panelYOffset + ladderTopRow * size + 4;
          const ladderHeight = ladderHeightPanels * size - 8;
          
          // Draw ladder as a rounded rectangle
          ctx.fillStyle = '#00CED1'; // Cyan
          ctx.beginPath();
          ctx.roundRect(ladderX, ladderTopY, ladderWidth, ladderHeight, 2);
          ctx.fill();
          
          // Black outline
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1.5;
          ctx.stroke();
          
          // Draw ladder rungs
          ctx.strokeStyle = '#008B8B'; // Darker cyan for rungs
          ctx.lineWidth = 1;
          const rungSpacing = size / 2;
          for(let y = ladderTopY + rungSpacing; y < ladderTopY + ladderHeight - 5; y += rungSpacing) {
            ctx.beginPath();
            ctx.moveTo(ladderX + 1, y);
            ctx.lineTo(ladderX + ladderWidth - 1, y);
            ctx.stroke();
          }
        }
      }
    });
    
    // Draw BRIDGE CLAMPS (purple) - only on columns with ladders (bound to bumpers)
    // In center of panels, every 2nd row from bottom (2nd, 4th, 6th, etc.)
    ctx.fillStyle = '#9932CC'; // Purple for bridge clamps
    columnsWithBumpers.forEach(c => {
      // Start from 2nd row from bottom (index ph-2), then every 2nd row going up
      for(let r = ph - 2; r >= 0; r -= 2) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          // Draw bridge clamp as a filled circle at center of panel
          ctx.beginPath();
          ctx.arc(c * size + size/2, panelYOffset + r * size + size/2, bridgeClampSize/2, 0, Math.PI * 2);
          ctx.fill();
          
          // Black outline
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
      }
    });
  }
  
  // Draw all bumpers and store their positions for interaction
  // Pass bumpersWithLadders so we can draw ladder bases inside bumpers
  drawAllBumpers(ctx, pw, ph, size, bumperHeight, fourWayHeight, fourWayGap, panelYOffset, bumpersWithLadders);
  
  // Update pickup weight summary
  updatePickupWeightSummary();
  
  // Setup interactivity for bumpers
  setupStructureCanvasInteractivity();
}

// Update the pickup weight summary display
function updatePickupWeightSummary() {
  const infoPanel = document.getElementById('structureInfoPanel');
  const weightsBox = document.getElementById('structureWeightsBox');
  const weightsContent = document.getElementById('structureWeightsContent');
  
  if(!infoPanel || !weightsContent) return;
  
  if(bumpers.length === 0) {
    infoPanel.style.display = 'none';
    return;
  }
  
  // Show the info panel
  infoPanel.style.display = 'grid';
  
  // Group bumpers by position
  const topBumpers = bumpers.filter(b => b.position === 'top');
  const bottomBumpers = bumpers.filter(b => b.position === 'bottom');
  
  // Helper function to check if a 2W bumper is under a 4W bumper
  function is2wUnder4w(bumper2w, position) {
    const fourWayBumpers = bumpers.filter(b => b.type === '4w' && b.position === position);
    for(const b4w of fourWayBumpers) {
      // 4W startCol/endCol are the centers of the 2W bumpers it connects
      // First 2W covers columns (startCol-1) to startCol
      // Second 2W covers columns (endCol-1) to endCol
      const col4wStart = b4w.startCol - 1;
      const col4wEnd = b4w.endCol;
      
      // Check if this 2W's columns are within the 4W's range
      if(bumper2w.startCol >= col4wStart && bumper2w.endCol <= col4wEnd) {
        return true;
      }
    }
    return false;
  }
  
  const wtUnit = getWeightUnitLabel();
  let html = '';
  let totalWeightKg = 0;
  
  // Show ALL top bumpers (but skip 2W bumpers that are under 4W bumpers)
  if(topBumpers.length > 0) {
    // Sort by type: 4W first, then 2W, then 1W
    const sortedTop = [...topBumpers].sort((a, b) => {
      const order = { '4w': 0, '2w': 1, '1w': 2 };
      return order[a.type] - order[b.type];
    });
    
    // Count by type for numbering
    const counts = { '4w': 0, '2w': 0, '1w': 0 };
    
    sortedTop.forEach((bumper) => {
      // Skip 2W bumpers that are under a 4W bumper (they're not pickup points)
      if(bumper.type === '2w' && is2wUnder4w(bumper, 'top')) {
        return; // Skip this bumper
      }
      
      counts[bumper.type]++;
      const weight = calculateBumperPickupWeight(bumper);
      totalWeightKg += weight.kg;
      const label = bumper.type === '4w' ? '4W' : bumper.type === '2w' ? '2W' : '1W';
      const color = bumper.type === '4w' ? '#FF6B35' : bumper.type === '2w' ? '#4CAF50' : '#2196F3';
      const weightDisplay = displayWeightUnit === 'lbs' ? weight.lbs.toFixed(0) : weight.kg.toFixed(0);
      html += `<div class="weight-row">
        <span class="weight-label" style="color: ${color};">${label} #${counts[bumper.type]}</span>
        <span class="weight-value">${weightDisplay} ${wtUnit}</span>
      </div>`;
    });
  }
  
  // Show ALL bottom bumpers (ground stacking) - skip 2W bumpers under 4W
  if(bottomBumpers.length > 0) {
    if(topBumpers.length > 0 && html.length > 0) {
      html += '<div style="border-top: 1px solid #444; margin: 6px 0;"></div>';
    }
    
    // Sort by type: 4W first, then 2W, then 1W
    const sortedBottom = [...bottomBumpers].sort((a, b) => {
      const order = { '4w': 0, '2w': 1, '1w': 2 };
      return order[a.type] - order[b.type];
    });
    
    // Count by type for numbering
    const counts = { '4w': 0, '2w': 0, '1w': 0 };
    
    sortedBottom.forEach((bumper) => {
      // Skip 2W bumpers that are under a 4W bumper (they're not pickup points)
      if(bumper.type === '2w' && is2wUnder4w(bumper, 'bottom')) {
        return; // Skip this bumper
      }
      
      counts[bumper.type]++;
      const weight = calculateBumperPickupWeight(bumper);
      totalWeightKg += weight.kg;
      const label = bumper.type === '4w' ? '4W' : bumper.type === '2w' ? '2W' : '1W';
      const color = bumper.type === '4w' ? '#FF6B35' : bumper.type === '2w' ? '#FF9800' : '#2196F3';
      const weightDisplay = displayWeightUnit === 'lbs' ? weight.lbs.toFixed(0) : weight.kg.toFixed(0);
      html += `<div class="weight-row">
        <span class="weight-label" style="color: ${color};">${label} #${counts[bumper.type]}</span>
        <span class="weight-value">${weightDisplay} ${wtUnit}</span>
      </div>`;
    });
  }
  
  // Add total
  const totalDisplay = displayWeightUnit === 'lbs' ? (totalWeightKg * KG_TO_LBS).toFixed(0) : totalWeightKg.toFixed(0);
  html += `<div class="weight-row" style="border-top: 1px solid #4a9eff; margin-top: 6px; padding-top: 6px;">
    <span class="weight-label" style="color: #fff;">Total</span>
    <span class="weight-value" style="color: #4a9eff;">${totalDisplay} ${wtUnit}</span>
  </div>`;
  
  weightsContent.innerHTML = html;
  
  // Also update the plates display in the same panel
  updateStructurePlatesDisplay();
}

// Update the connecting plates display in the structure info panel
function updateStructurePlatesDisplay() {
  const platesBox = document.getElementById('structurePlatesBox');
  const platesContent = document.getElementById('structurePlatesContent');
  
  if(!platesBox || !platesContent) return;
  
  const panelType = document.getElementById('panelType').value;
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const {pw, ph} = getEffectivePanelCountsForLayout();
  
  // Initialize plates data for storage
  let platesData = { total2way: 0, total4way: 0, totalPlateWeight: 0 };
  
  if(!useConnectingPlates || pw === 0 || ph === 0) {
    platesBox.style.display = 'none';
  } else {
    // Plate weights in kg
    const plate2wayKg = 0.141; // 0.31 lbs
    const plate4wayKg = 0.249; // 0.55 lbs
    
    const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
    platesData = plates; // Store the calculated values
    
    const wtUnit = getWeightUnitLabel();
    const weightDisplay = displayWeightUnit === 'lbs' 
      ? (plates.totalPlateWeight * KG_TO_LBS).toFixed(1) 
      : plates.totalPlateWeight.toFixed(1);
    
    let html = '';
    
    html += `<div class="plates-row">
      <span class="plates-label">2-Way (yellow)</span>
      <span class="plates-value">${plates.total2way}</span>
    </div>`;
    
    html += `<div class="plates-row">
      <span class="plates-label">4-Way (red)</span>
      <span class="plates-value">${plates.total4way}</span>
    </div>`;
    
    html += `<div class="plates-row plates-total">
      <span class="plates-label" style="color: #fff;">Total Weight</span>
      <span class="plates-value" style="color: #6fc276;">${weightDisplay} ${wtUnit}</span>
    </div>`;
    
    platesContent.innerHTML = html;
    platesBox.style.display = 'block';
  }
  
  // Store plates data for gear list
  if(screens[currentScreenId]) {
    if(!screens[currentScreenId].calculatedData) {
      screens[currentScreenId].calculatedData = {};
    }
    screens[currentScreenId].calculatedData.plates2way = platesData.total2way;
    screens[currentScreenId].calculatedData.plates4way = platesData.total4way;
    screens[currentScreenId].calculatedData.platesWeightKg = platesData.totalPlateWeight;
  }
  
  // Also update ground support hardware display
  updateGroundSupportDisplay();
}

// Update the ground support hardware display (ladders and bridge clamps)
function updateGroundSupportDisplay() {
  const groundSupportBox = document.getElementById('structureGroundSupportBox');
  const groundSupportContent = document.getElementById('structureGroundSupportContent');
  
  if(!groundSupportBox || !groundSupportContent) return;
  
  const isGroundStacking = showBottomBumper;
  const {pw, ph} = getEffectivePanelCountsForLayout();
  
  // Initialize ground support data for storage
  let groundSupportData = {
    totalRearTruss: 0,
    totalBaseTruss: 0,
    totalBridgeClamps: 0,
    totalRearBridgeClampAdapters: 0,
    totalPipes: 0,
    totalSwivelCheeseboroughs: 0,
    totalSandbags: 0,
    totalWeightKg: 0,
    totalWeightLbs: 0,
    pipeInfo: []
  };
  
  if(!isGroundStacking || pw === 0 || ph === 0) {
    groundSupportBox.style.display = 'none';
    // Store empty ground support data
    if(screens[currentScreenId]) {
      if(!screens[currentScreenId].calculatedData) {
        screens[currentScreenId].calculatedData = {};
      }
      screens[currentScreenId].calculatedData.groundSupport = groundSupportData;
    }
    updateTotalStructureWeight(); // Still update total even when ground support hidden
    return;
  }
  
  // Calculate ground support hardware
  const hardware = calculateGroundSupportHardware(pw, ph);
  groundSupportData = hardware; // Store calculated values
  
  // Store ground support data for gear list
  if(screens[currentScreenId]) {
    if(!screens[currentScreenId].calculatedData) {
      screens[currentScreenId].calculatedData = {};
    }
    screens[currentScreenId].calculatedData.groundSupport = groundSupportData;
  }
  
  if(hardware.totalRearTruss === 0 && hardware.totalBridgeClamps === 0 && hardware.totalBaseTruss === 0) {
    groundSupportBox.style.display = 'none';
    updateTotalStructureWeight(); // Still update total even when ground support hidden
    return;
  }
  
  const wtUnit = getWeightUnitLabel();
  let html = '';
  
  html += `<div class="plates-row">
    <span class="plates-label" style="color: #ffffff;">Rear Truss</span>
    <span class="plates-value">${hardware.totalRearTruss}</span>
  </div>`;
  
  html += `<div class="plates-row">
    <span class="plates-label" style="color: #ffffff;">Base Truss</span>
    <span class="plates-value">${hardware.totalBaseTruss}</span>
  </div>`;
  
  html += `<div class="plates-row">
    <span class="plates-label" style="color: #ffffff;">Bridge Clamps</span>
    <span class="plates-value">${hardware.totalBridgeClamps}</span>
  </div>`;
  
  if(hardware.totalRearBridgeClampAdapters > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Rear Bridge Clamp Adapter</span>
      <span class="plates-value">${hardware.totalRearBridgeClampAdapters}</span>
    </div>`;
  }
  
  if(hardware.totalPipes > 0) {
    // Show pipe count with unique length(s)
    const uniqueLengths = [...new Set(hardware.pipeInfo.map(p => p.pipeLengthFt))];
    const pipeLengthStr = uniqueLengths.map(l => l + 'ft').join(', ');
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Pipe (${pipeLengthStr})</span>
      <span class="plates-value">${hardware.totalPipes}</span>
    </div>`;
  }
  
  if(hardware.totalSwivelCheeseboroughs > 0) {
    html += `<div class="plates-row">
      <span class="plates-label" style="color: #ffffff;">Swivel Cheeseborough</span>
      <span class="plates-value">${hardware.totalSwivelCheeseboroughs}</span>
    </div>`;
  }
  
  html += `<div class="plates-row">
    <span class="plates-label" style="color: #ffffff;">Sandbags (50lb)</span>
    <span class="plates-value">${hardware.totalSandbags}</span>
  </div>`;
  
  // Add total weight
  const totalWeightDisplay = displayWeightUnit === 'lbs' 
    ? hardware.totalWeightLbs.toFixed(1) 
    : hardware.totalWeightKg.toFixed(1);
  
  html += `<div class="plates-row plates-total" style="border-top: 1px solid #00CED1; margin-top: 6px; padding-top: 6px;">
    <span class="plates-label" style="color: #fff;">Total Weight</span>
    <span class="plates-value" style="color: #00CED1;">${totalWeightDisplay} ${wtUnit}</span>
  </div>`;
  
  groundSupportContent.innerHTML = html;
  groundSupportBox.style.display = 'block';
  
  // Update total structure weight
  updateTotalStructureWeight();
}

// Update the total structure weight display (sum of pickup weights + plates + ground support)
function updateTotalStructureWeight() {
  const totalWeightBox = document.getElementById('structureTotalWeightBox');
  const totalWeightContent = document.getElementById('structureTotalWeightContent');
  
  if(!totalWeightBox || !totalWeightContent) return;
  
  // Helper function to check if a 2W bumper is under a 4W bumper
  function is2wUnder4w(bumper2w) {
    const fourWayBumpers = bumpers.filter(b => b.type === '4w' && b.position === bumper2w.position);
    for(const b4w of fourWayBumpers) {
      const col4wStart = b4w.startCol - 1;
      const col4wEnd = b4w.endCol;
      if(bumper2w.startCol >= col4wStart && bumper2w.endCol <= col4wEnd) {
        return true;
      }
    }
    return false;
  }
  
  // Calculate pickup weights total (excluding 2W bumpers under 4W bumpers)
  let pickupWeightKg = 0;
  bumpers.forEach(bumper => {
    // Skip 2W bumpers that are under a 4W bumper
    if(bumper.type === '2w' && is2wUnder4w(bumper)) {
      return;
    }
    const weight = calculateBumperPickupWeight(bumper);
    pickupWeightKg += weight.kg;
  });
  
  // Calculate connecting plates weight
  let platesWeightKg = 0;
  const panelType = document.getElementById('panelType').value;
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const {pw, ph} = getEffectivePanelCountsForLayout();
  
  if(useConnectingPlates && pw > 0 && ph > 0) {
    const plate2wayKg = 0.141;
    const plate4wayKg = 0.249;
    const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
    platesWeightKg = plates.totalPlateWeight || 0;
  }
  
  // Calculate ground support hardware weight
  let groundSupportWeightKg = 0;
  const isGroundStacking = showBottomBumper;
  
  if(isGroundStacking && pw > 0 && ph > 0) {
    const hardware = calculateGroundSupportHardware(pw, ph);
    groundSupportWeightKg = hardware.totalWeightKg || 0;
  }
  
  // Calculate total
  const totalWeightKg = pickupWeightKg + platesWeightKg + groundSupportWeightKg;
  
  // Only show if there's something to display
  if(totalWeightKg === 0 && bumpers.length === 0) {
    totalWeightBox.style.display = 'none';
    return;
  }
  
  const wtUnit = getWeightUnitLabel();
  const totalWeightLbs = totalWeightKg * KG_TO_LBS;
  
  let html = '';
  
  // Show breakdown
  const pickupDisplay = displayWeightUnit === 'lbs' 
    ? (pickupWeightKg * KG_TO_LBS).toFixed(0) 
    : pickupWeightKg.toFixed(0);
  html += `<div class="weight-row">
    <span class="weight-label" style="color: #4a9eff;">Pickup Points</span>
    <span class="weight-value">${pickupDisplay} ${wtUnit}</span>
  </div>`;
  
  if(platesWeightKg > 0) {
    const platesDisplay = displayWeightUnit === 'lbs' 
      ? (platesWeightKg * KG_TO_LBS).toFixed(1) 
      : platesWeightKg.toFixed(1);
    html += `<div class="weight-row">
      <span class="weight-label" style="color: #6fc276;">Connecting Plates</span>
      <span class="weight-value">${platesDisplay} ${wtUnit}</span>
    </div>`;
  }
  
  if(groundSupportWeightKg > 0) {
    const gsDisplay = displayWeightUnit === 'lbs' 
      ? (groundSupportWeightKg * KG_TO_LBS).toFixed(1) 
      : groundSupportWeightKg.toFixed(1);
    html += `<div class="weight-row">
      <span class="weight-label" style="color: #00CED1;">Ground Support</span>
      <span class="weight-value">${gsDisplay} ${wtUnit}</span>
    </div>`;
  }
  
  // Total
  const totalDisplay = displayWeightUnit === 'lbs' 
    ? totalWeightLbs.toFixed(0) 
    : totalWeightKg.toFixed(0);
  html += `<div class="weight-row" style="border-top: 1px solid #FFD700; margin-top: 6px; padding-top: 6px;">
    <span class="weight-label" style="color: #fff; font-weight: bold;">TOTAL</span>
    <span class="weight-value" style="color: #FFD700; font-weight: bold;">${totalDisplay} ${wtUnit}</span>
  </div>`;
  
  totalWeightContent.innerHTML = html;
  totalWeightBox.style.display = 'block';
}

// Calculate ground support hardware counts
function calculateGroundSupportHardware(pw, ph) {
  const ladderHeightPanels = 2;
  const maxPanelsBeforeSecondBase = 8; // If more than 8 panels high, add 2nd base
  
  // Hardware weights in lbs
  const weights = {
    rearTruss: 10.1,          // per rear truss piece (1000mm)
    baseTruss: 28.2,          // per base truss (1000mm)
    bridgeClamp: 2.2,         // per bridge clamp
    rearBridgeClampAdapter: 1.1, // per adapter (DM2.6 only)
    pipe: 5.0,                // per pipe
    swivelCheeseborough: 1.2, // per swivel cheeseborough
    sandbag: 50.0             // per sandbag (50lb sandbags)
  };
  
  let totalRearTruss = 0;
  let totalBridgeClamps = 0;
  let totalBaseTruss = 0;
  let totalSecondBases = 0; // Additional bases for tall walls
  let totalPipes = 0; // Pipes from top truss to 2nd base
  let totalSwivelCheeseboroughs = 0; // 2 per pipe
  let totalSandbags = 0;
  let totalRearBridgeClampAdapters = 0; // For DM2.6 only, 1 per bridge clamp
  
  const panelType = document.getElementById('panelType').value;
  const isDM26 = panelType === 'DM2_6';
  
  // Track bumpers and their ladder columns for sandbag calculation
  const bumperLadderInfo = []; // {bumper, ladderCol, panelsInColumn}
  
  // Track pipe lengths for columns that need them
  const pipeInfo = []; // {column, rearTrussCount, pipeLengthFt}
  
  // Get columns that have bottom bumpers (ladders are bound to bumpers)
  const columnsWithBumpers = new Set();
  
  bumpers.filter(b => b.position === 'bottom').forEach(bumper => {
    const cols = getBumperColumns(bumper);
    if(cols.length > 0) {
      // Check if bumper has a custom ladder column setting
      let ladderCol;
      if(bumper.type === '2w' && bumper.ladderColumn === 'right') {
        ladderCol = cols[1] !== undefined ? cols[1] : cols[0];
      } else {
        ladderCol = cols[0];
      }
      columnsWithBumpers.add(ladderCol);
      bumperLadderInfo.push({ bumper, ladderCol });
    }
  });
  
  // Count items per column
  columnsWithBumpers.forEach(c => {
    let topRow = -1;
    let bottomRow = -1;
    
    for(let r = 0; r < ph; r++) {
      const panelKey = `${c},${r}`;
      if(!deletedPanels.has(panelKey)) {
        if(topRow === -1) topRow = r;
        bottomRow = r;
      }
    }
    
    if(topRow !== -1 && bottomRow !== -1) {
      const totalPanelsInColumn = bottomRow - topRow + 1;
      const numTruss = Math.floor(totalPanelsInColumn / ladderHeightPanels);
      totalRearTruss += numTruss;
      
      // Check if we need a second base (more than 8 panels high)
      if(totalPanelsInColumn > maxPanelsBeforeSecondBase) {
        totalSecondBases++;
        totalPipes++; // 1 pipe per second base
        totalSwivelCheeseboroughs += 2; // 2 swivel cheeseboroughs per pipe
        
        // Calculate pipe length using Pythagorean theorem
        // Pipe goes diagonally from top rear truss to 2nd base truss
        // Each rear truss is 1000mm (1m) = 3.28 ft
        // Horizontal distance (base) = 2m = 6.56 ft
        // Vertical height = number of rear truss * 3.28 ft
        const horizontalDistFt = 6.56; // 2 meters in feet
        const verticalHeightFt = numTruss * 3.28; // Each truss is 1m = 3.28ft
        const diagonalFt = Math.sqrt(Math.pow(horizontalDistFt, 2) + Math.pow(verticalHeightFt, 2));
        const pipeLengthFt = Math.floor(diagonalFt); // Round down
        
        // Store pipe length info
        pipeInfo.push({
          column: c,
          rearTrussCount: numTruss,
          pipeLengthFt: pipeLengthFt
        });
      }
      
      // Store panel count for this column for sandbag calculation
      const info = bumperLadderInfo.find(bi => bi.ladderCol === c);
      if(info) {
        info.panelsInColumn = totalPanelsInColumn;
      }
    }
  });
  
  // Base truss = columns with bumpers (1 per column)
  // Plus second bases for tall walls
  totalBaseTruss = columnsWithBumpers.size + totalSecondBases;
  
  // Count bridge clamps - every 2nd row from bottom, only in columns with ladders
  columnsWithBumpers.forEach(c => {
    for(let r = ph - 2; r >= 0; r -= 2) {
      const panelKey = `${c},${r}`;
      if(!deletedPanels.has(panelKey)) {
        totalBridgeClamps++;
      }
    }
  });
  
  // Rear bridge clamp adapters for DM2.6 only (1 per bridge clamp)
  if(isDM26) {
    totalRearBridgeClampAdapters = totalBridgeClamps;
  }
  
  // Calculate sandbags: ((total weight of bumper) / 50lbs) x 1.25 = sandbags per column
  // Round up to nearest whole sandbag
  bumperLadderInfo.forEach(info => {
    const bumperWeight = calculateBumperPickupWeight(info.bumper);
    const weightLbs = bumperWeight.lbs;
    const sandbagWeight = 50; // lbs per sandbag
    const sandbagMultiplier = 1.25;
    const sandbagCount = Math.ceil((weightLbs / sandbagWeight) * sandbagMultiplier);
    totalSandbags += sandbagCount;
  });
  
  // Calculate total weight of all ground support hardware
  const totalWeightLbs = 
    (totalRearTruss * weights.rearTruss) +
    (totalBaseTruss * weights.baseTruss) +
    (totalBridgeClamps * weights.bridgeClamp) +
    (totalRearBridgeClampAdapters * weights.rearBridgeClampAdapter) +
    (totalPipes * weights.pipe) +
    (totalSwivelCheeseboroughs * weights.swivelCheeseborough) +
    (totalSandbags * weights.sandbag);
  
  const totalWeightKg = totalWeightLbs / KG_TO_LBS;
  
  return {
    totalRearTruss,
    totalBridgeClamps,
    totalBaseTruss,
    totalPipes,
    totalSwivelCheeseboroughs,
    totalSandbags,
    totalRearBridgeClampAdapters,
    totalWeightLbs,
    totalWeightKg,
    pipeInfo // Array of {column, rearTrussCount, pipeLengthFt}
  };
}

// Draw all bumpers from the bumpers array
function drawAllBumpers(ctx, pw, ph, size, bumperHeight, fourWayHeight, fourWayGap, panelYOffset, bumpersWithLadders = new Set()) {
  const use4Way = use4WayBumpersEnabled;
  const panelType = document.getElementById('panelType').value;
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  
  ctx.font = 'bold 10px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Draw each bumper
  bumpers.forEach(bumper => {
    let x, y, width, height;
    let label = '';
    let fillColor = '';
    
    if(bumper.type === '4w') {
      // 4-way bumper - spans from center of one 2W to center of next 2W
      // startCol and endCol are already the column positions (centers of 2W bumpers)
      const col1 = bumper.startCol;
      const col2 = bumper.endCol;
      
      x = col1 * size;  // Start at column 1, 5, 9... (centers of 2W bumpers)
      width = (col2 - col1) * size;  // Width of 2 columns
      height = fourWayHeight;
      
      if(bumper.position === 'top') {
        // 4W bumpers stay at top (they connect to the 2W bumpers which drop down)
        y = 0;
      } else {
        y = panelYOffset + (ph * size) + bumperHeight + fourWayGap;
      }
      
      fillColor = '#FF6B35'; // Orange
      label = '4W';
      
    } else if(bumper.type === '2w') {
      // 2-way bumper - spans 2 columns
      const col = bumper.startCol;
      x = col * size;
      width = size * 2; // Span 2 columns
      height = bumperHeight;
      
      if(bumper.position === 'top') {
        // For hanging bumpers, drop down to the first non-deleted row
        // Check both columns covered by this 2W bumper
        const row1 = getFirstNonDeletedRow(col, ph);
        const row2 = getFirstNonDeletedRow(col + 1, ph);
        const maxRow = Math.max(row1, row2); // Use the deeper one so bumper sits on both
        
        const baseY = use4Way && isCB5 ? (fourWayHeight + fourWayGap) : 0;
        y = baseY + (maxRow * size); // Drop down by the number of deleted rows
      } else {
        y = panelYOffset + (ph * size);
      }
      
      fillColor = '#4CAF50'; // Green for top, orange for bottom
      if(bumper.position === 'bottom') {
        fillColor = '#FF9800';
      }
      label = '2W';
      
    } else if(bumper.type === '1w') {
      // 1-way bumper - spans 1 column
      const col = bumper.startCol;
      x = col * size;
      width = size; // Span 1 column
      height = bumperHeight;
      
      if(bumper.position === 'top') {
        // For hanging bumpers, drop down to the first non-deleted row
        const firstRow = getFirstNonDeletedRow(col, ph);
        
        const baseY = use4Way && isCB5 ? (fourWayHeight + fourWayGap) : 0;
        y = baseY + (firstRow * size); // Drop down by the number of deleted rows
      } else {
        y = panelYOffset + (ph * size);
      }
      
      fillColor = '#2196F3'; // Blue for 1W
      label = '1W';
    }
    
    // Store position for interaction
    bumper.x = x;
    bumper.y = y;
    bumper.width = width;
    bumper.height = height;
    
    // Draw bumper
    ctx.fillStyle = fillColor;
    ctx.fillRect(x, y, width, height);
    
    // Draw LADDER BASE (dark blue) inside bumpers that have ladders
    // Only for bottom bumpers (ground support)
    // Position under the column where the ladder is (respects ladderColumn setting)
    if(bumper.position === 'bottom' && bumpersWithLadders.has(bumper.id)) {
      const ladderBaseWidth = size * 0.85; // Slightly less than panel width
      const ladderBaseHeight = 10; // Height of ladder base
      
      // Determine which column the ladder is in
      let ladderColOffset = 0; // Default: first column (left)
      if(bumper.type === '2w' && bumper.ladderColumn === 'right') {
        ladderColOffset = size; // Move to second column (right)
      }
      
      // Position under the correct column
      const ladderBaseX = x + ladderColOffset + (size - ladderBaseWidth) / 2;
      const ladderBaseY = y + (height - ladderBaseHeight) / 2; // Centered vertically in bumper
      
      // Draw ladder base rectangle
      ctx.fillStyle = '#00008B'; // Dark blue
      ctx.beginPath();
      ctx.roundRect(ladderBaseX, ladderBaseY, ladderBaseWidth, ladderBaseHeight, 3);
      ctx.fill();
      
      // Black outline
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    // Check if bumper is selected (manual mode uses selectedBumpers set)
    const isBumperSelected = (manualBumperMode && selectedBumpers.has(bumper.id)) || 
                              (selectedBumper && selectedBumper.id === bumper.id);
    
    // Add selection highlight
    if(isBumperSelected) {
      ctx.strokeStyle = '#00FF00';
      ctx.lineWidth = 3;
      ctx.strokeRect(x + 2, y + 2, width - 4, height - 4);
    }
    
    // Add hover highlight (only in manual mode)
    if(manualBumperMode && hoveredBumper && hoveredBumper.id === bumper.id && !isBumperSelected) {
      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);
      ctx.setLineDash([]);
    }
    
    // Draw border
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, width, height);
    
    // Calculate weight at center point of this bumper
    const pickupWeight = calculateBumperPickupWeight(bumper);
    
    // Draw label with weight
    ctx.fillStyle = '#FFFFFF';
    ctx.font = 'bold 10px Arial';
    ctx.fillText(label, x + width/2, y + height/2 - 6);
    
    // Draw weight below label using selected unit
    ctx.font = '9px Arial';
    const weightValue = displayWeightUnit === 'lbs' ? pickupWeight.lbs.toFixed(0) : pickupWeight.kg.toFixed(0);
    const weightText = `${weightValue}${displayWeightUnit}`;
    ctx.fillText(weightText, x + width/2, y + height/2 + 6);
  });
}

// Calculate the weight at the center pickup point of a bumper
function calculateBumperPickupWeight(bumper) {
  const panelType = document.getElementById('panelType').value;
  const p = panels[panelType];
  const ph = parseInt(document.getElementById('panelsHigh').value) || 0;
  const pw = parseInt(document.getElementById('panelsWide').value) || 0;
  
  if(!p) return { kg: 0, lbs: 0 };
  
  // Get correct panel weight based on connection method (air frame vs connecting plates)
  const useConnectingPlates = shouldUseConnectingPlates(panelType);
  const panelWeightKg = getPanelWeight(panelType, useConnectingPlates);
  
  let totalPanelWeightKg = 0;
  let bumperWeightLbs = 0;
  
  // Get bumper weights in lbs
  const bumper1wLbs = p.bumper_1w_lbs || 0;
  const bumper2wLbs = p.bumper_2w_lbs || 0;
  const bumper4wLbs = p.bumper_4w_lbs || 0;
  
  // First, get the columns this bumper directly covers
  let directColumns = [];
  
  // Calculate panel weight based on bumper type
  if(bumper.type === '4w') {
    // 4W bumper is the pickup point - it picks up 4 columns of panels + the 4W bar itself
    // The 2W bumpers underneath are structural only, not added to pickup weight
    // bumper.startCol = center of first 2W (e.g., 1 for first 4W)
    // bumper.endCol = center of second 2W (e.g., 3 for first 4W)
    // First 2W covers columns (startCol-1) to startCol
    // Second 2W covers columns (endCol-1) to endCol
    // So we need columns: (startCol-1) to endCol (inclusive)
    const colStart = bumper.startCol - 1; // e.g., 0 for first 4W
    const colEnd = bumper.endCol;         // e.g., 3 for first 4W (not 4!)
    
    console.log(`4W Bumper: startCol=${bumper.startCol}, endCol=${bumper.endCol}, calculating columns ${colStart} to ${colEnd}`);
    
    let panelCount = 0;
    for(let c = colStart; c <= colEnd; c++) {
      if(c >= 0) {
        directColumns.push(c);
        for(let r = 0; r < ph; r++) {
          const panelKey = `${c},${r}`;
          if(!deletedPanels.has(panelKey)) {
            totalPanelWeightKg += panelWeightKg;
            panelCount++;
          }
        }
      }
    }
    
    console.log(`4W Bumper picked up ${panelCount} panels at ${panelWeightKg}kg each = ${totalPanelWeightKg}kg panel weight`);
    
    // Add 4W hanging bar weight + 2x 2W bumpers (structural, part of the pickup assembly)
    bumperWeightLbs = bumper4wLbs + (2 * bumper2wLbs);
    console.log(`4W Bumper weight: ${bumper4wLbs}lbs + 2x ${bumper2wLbs}lbs = ${bumperWeightLbs}lbs total`);
    
  } else if(bumper.type === '2w') {
    // 2W bumper picks up 2 columns + itself
    const colStart = bumper.startCol;
    const colEnd = bumper.endCol;
    
    directColumns.push(colStart, colEnd);
    
    // For hanging bumpers, we need to calculate from the row the bumper is sitting on
    // (which accounts for dropped position due to deleted top panels)
    let startRow = 0;
    if(bumper.position === 'top') {
      // Find the first non-deleted row for both columns - bumper sits on the deeper one
      const row1 = getFirstNonDeletedRow(colStart, ph);
      const row2 = getFirstNonDeletedRow(colEnd, ph);
      startRow = Math.max(row1, row2);
    }
    
    for(let c = colStart; c <= colEnd; c++) {
      for(let r = startRow; r < ph; r++) {
        const panelKey = `${c},${r}`;
        if(!deletedPanels.has(panelKey)) {
          totalPanelWeightKg += panelWeightKg;
        }
      }
    }
    
    bumperWeightLbs = bumper2wLbs;
    
  } else if(bumper.type === '1w') {
    // 1W bumper picks up 1 column + itself
    const col = bumper.startCol;
    
    directColumns.push(col);
    
    // For hanging bumpers, calculate from the row the bumper is sitting on
    let startRow = 0;
    if(bumper.position === 'top') {
      startRow = getFirstNonDeletedRow(col, ph);
    }
    
    for(let r = startRow; r < ph; r++) {
      const panelKey = `${col},${r}`;
      if(!deletedPanels.has(panelKey)) {
        totalPanelWeightKg += panelWeightKg;
      }
    }
    
    bumperWeightLbs = bumper1wLbs;
  }
  
  // Now add weight from any orphaned columns that should transfer to this bumper
  const orphanedWeight = getOrphanedColumnWeightForBumper(bumper, pw, ph, panelWeightKg);
  totalPanelWeightKg += orphanedWeight;
  
  const panelWeightLbs = totalPanelWeightKg * 2.20462;
  const totalLbs = panelWeightLbs + bumperWeightLbs;
  const totalKg = totalLbs * 0.453592;
  
  return {
    kg: totalKg,
    lbs: totalLbs,
    panelWeight: totalPanelWeightKg,
    bumperWeight: bumperWeightLbs / 2.20462
  };
}

// Get the first non-deleted row for a column (for top bumpers)
function getFirstNonDeletedRow(column, ph) {
  for(let r = 0; r < ph; r++) {
    const panelKey = `${column},${r}`;
    if(!deletedPanels.has(panelKey)) {
      return r;
    }
  }
  return 0; // If all deleted, return 0
}

// Get the last non-deleted row for a column (for bottom bumpers)
function getLastNonDeletedRow(column, ph) {
  for(let r = ph - 1; r >= 0; r--) {
    const panelKey = `${column},${r}`;
    if(!deletedPanels.has(panelKey)) {
      return r;
    }
  }
  return ph - 1; // If all deleted, return last row
}

// Check if a column should have a bottom bumper (last row panel must exist)
function shouldHaveBottomBumper(column, ph) {
  const lastRow = ph - 1;
  const panelKey = `${column},${lastRow}`;
  return !deletedPanels.has(panelKey);
}

// Get which columns a bumper directly covers
function getBumperColumns(bumper) {
  if(bumper.type === '4w') {
    const colStart = bumper.startCol - 1;
    const colEnd = bumper.endCol;
    const cols = [];
    for(let c = colStart; c <= colEnd; c++) {
      if(c >= 0) cols.push(c);
    }
    return cols;
  } else if(bumper.type === '2w') {
    return [bumper.startCol, bumper.endCol];
  } else if(bumper.type === '1w') {
    return [bumper.startCol];
  }
  return [];
}

// Find all columns that have no bumper covering them (orphaned columns)
function getOrphanedColumns(pw, position) {
  const coveredColumns = new Set();
  
  // Get all columns covered by existing bumpers of the same position
  bumpers.filter(b => b.position === position).forEach(b => {
    getBumperColumns(b).forEach(col => coveredColumns.add(col));
  });
  
  // Find columns that are not covered
  const orphaned = [];
  for(let c = 0; c < pw; c++) {
    if(!coveredColumns.has(c)) {
      orphaned.push(c);
    }
  }
  
  return orphaned;
}

// Find the nearest bumper to a given column
function findNearestBumper(column, position) {
  const samePosiBumpers = bumpers.filter(b => b.position === position && (b.type === '1w' || b.type === '2w'));
  
  if(samePosiBumpers.length === 0) return null;
  
  let nearestBumper = null;
  let nearestDistance = Infinity;
  
  samePosiBumpers.forEach(b => {
    const bumperCols = getBumperColumns(b);
    // Find minimum distance from column to any column covered by this bumper
    bumperCols.forEach(bc => {
      const dist = Math.abs(column - bc);
      if(dist < nearestDistance) {
        nearestDistance = dist;
        nearestBumper = b;
      }
    });
  });
  
  return nearestBumper;
}

// Calculate weight from orphaned columns that should transfer to a specific bumper
function getOrphanedColumnWeightForBumper(bumper, pw, ph, panelWeightKg) {
  // Only calculate for 1w and 2w bumpers (4w bumpers pick up via their 2w sub-bumpers)
  if(bumper.type === '4w') return 0;
  
  const orphanedCols = getOrphanedColumns(pw, bumper.position);
  let additionalWeightKg = 0;
  
  orphanedCols.forEach(col => {
    // Find which bumper this orphaned column should transfer its weight to
    const nearestBumper = findNearestBumper(col, bumper.position);
    
    // If this bumper is the nearest one to this orphaned column, add the weight
    if(nearestBumper && nearestBumper.id === bumper.id) {
      // Calculate weight of panels in this orphaned column
      let startRow = 0;
      if(bumper.position === 'top') {
        startRow = getFirstNonDeletedRow(col, ph);
      }
      
      for(let r = startRow; r < ph; r++) {
        const panelKey = `${col},${r}`;
        if(!deletedPanels.has(panelKey)) {
          additionalWeightKg += panelWeightKg;
        }
      }
      
      console.log(`Orphaned column ${col} weight (${additionalWeightKg.toFixed(2)}kg) transferred to ${bumper.type} bumper #${bumper.id}`);
    }
  });
  
  return additionalWeightKg;
}

function drawBumpersAdaptive(ctx, pw, ph, size, bumperHeight, yBase, type) {
  const oneWColumn = type === 'top' ? topBumper1wColumn : bottomBumper1wColumn;
  
  // Determine if we need a 1w bumper
  const needsOneW = pw % 2 === 1;
  
  ctx.font = 'bold 12px Arial';
  
  if(!needsOneW) {
    // Even number of panels - just draw 2w bumpers
    for(let c = 0; c < pw; c += 2) {
      // Skip if this is a bottom bumper and either column has bottom row deleted
      if(type === 'bottom') {
        const hasBottomC = shouldHaveBottomBumper(c, ph);
        const hasBottomC1 = (c + 1 < pw) ? shouldHaveBottomBumper(c + 1, ph) : false;
        if(!hasBottomC || !hasBottomC1) {
          continue; // Skip this 2W bumper if either column has bottom row deleted
        }
      }
      
      // Find the appropriate Y position for this bumper pair
      let yOffset;
      if(type === 'top') {
        // Top bumpers: start at yBase, move down with deleted panels at the top
        const row1 = getFirstNonDeletedRow(c, ph);
        const row2 = c + 1 < pw ? getFirstNonDeletedRow(c + 1, ph) : row1;
        const maxRow = Math.max(row1, row2);
        // yBase is where bumpers should start (either 0 or after 4W bumpers)
        yOffset = yBase + (maxRow * size);
      } else {
        // Bottom bumpers: always at bottom (yBase = bottom of panels, so bumper starts at yBase)
        yOffset = yBase;
      }
      
      const x = c * size;
      const width = 2 * size;
      ctx.fillStyle = '#87CEEB'; // Sky blue for 2w
      ctx.fillRect(x, yOffset, width, bumperHeight);
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, yOffset, width, bumperHeight);
      ctx.fillStyle = '#000000';
      ctx.fillText('2W', x + width/2, yOffset + bumperHeight/2);
    }
  } else {
    // Odd number of panels - need to place 1w and redistribute 2w bumpers
    // Draw 1W bumper at specified position
    const oneWPos = oneWColumn >= 0 && oneWColumn < pw ? oneWColumn : (pw - 1);
    
    // Check if 1W bumper should be drawn (only for bottom bumpers, check if bottom row exists)
    const shouldDraw1W = type === 'top' || shouldHaveBottomBumper(oneWPos, ph);
    
    if(shouldDraw1W) {
      let yOffset1w;
      if(type === 'top') {
        const row = getFirstNonDeletedRow(oneWPos, ph);
        yOffset1w = yBase + (row * size);
      } else {
        // Bottom bumpers stay at bottom
        yOffset1w = yBase;
      }
      
      const x1w = oneWPos * size;
      ctx.fillStyle = '#FFD700'; // Gold for 1w
      ctx.fillRect(x1w, yOffset1w, size, bumperHeight);
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x1w, yOffset1w, size, bumperHeight);
      ctx.fillStyle = '#000000';
      ctx.fillText('1W', x1w + size/2, yOffset1w + bumperHeight/2);
    }
    
    // Now draw 2W bumpers, skipping the 1W position
    for(let c = 0; c < pw; c++) {
      // Skip if this is the 1W position
      if(c === oneWPos) continue;
      
      // Check if we can place a 2W bumper starting at this position
      if(c + 1 < pw && (c + 1) !== oneWPos) {
        // Skip if this is a bottom bumper and either column has bottom row deleted
        if(type === 'bottom') {
          const hasBottomC = shouldHaveBottomBumper(c, ph);
          const hasBottomC1 = shouldHaveBottomBumper(c + 1, ph);
          if(!hasBottomC || !hasBottomC1) {
            c++; // Still skip next column
            continue;
          }
        }
        
        // We can place a 2W bumper here
        let yOffset;
        if(type === 'top') {
          const row1 = getFirstNonDeletedRow(c, ph);
          const row2 = getFirstNonDeletedRow(c + 1, ph);
          const maxRow = Math.max(row1, row2);
          yOffset = yBase + (maxRow * size);
        } else {
          // Bottom bumpers stay at bottom
          yOffset = yBase;
        }
        
        const x = c * size;
        const width = 2 * size;
        ctx.fillStyle = '#87CEEB'; // Sky blue for 2w
        ctx.fillRect(x, yOffset, width, bumperHeight);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, yOffset, width, bumperHeight);
        ctx.fillStyle = '#000000';
        ctx.fillText('2W', x + width/2, yOffset + bumperHeight/2);
        
        // Skip the next column since we just covered it with a 2W
        c++;
      } else {
        // Can't place 2W, need to place 1W here (this handles the remaining columns)
        // Skip if this is a bottom bumper and this column has bottom row deleted
        if(type === 'bottom' && !shouldHaveBottomBumper(c, ph)) {
          continue;
        }
        
        let yOffset;
        if(type === 'top') {
          const row = getFirstNonDeletedRow(c, ph);
          yOffset = yBase + (row * size);
        } else {
          // Bottom bumpers stay at bottom
          yOffset = yBase;
        }
        
        const x = c * size;
        ctx.fillStyle = '#FFD700'; // Gold for remaining 1w
        ctx.fillRect(x, yOffset, size, bumperHeight);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, yOffset, size, bumperHeight);
        ctx.fillStyle = '#000000';
        ctx.fillText('1W', x + size/2, yOffset + bumperHeight/2);
      }
    }
  }
}

function draw4WayBumpers(ctx, pw, ph, size, bumperHeight, yBase, type) {
  const fourWayHeight = 20; // Height of 4-way bumper bar
  const fourWayGap = 5; // Gap between 2W and 4W bumpers
  const fourWayCount = Math.floor(pw / 4); // Each 4W covers 4 columns
  
  ctx.font = 'bold 10px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  for(let i = 0; i < fourWayCount; i++) {
    // Each 4-way bumper is centered over 4 columns with 0.5 panel offset on each side
    // First 4W: from column 0.5 to 4.5 (4 panel widths, centered over panels 1,2,3,4)
    // Second 4W: from column 4.5 to 8.5 (4 panel widths, centered over panels 5,6,7,8)
    // Third 4W: from column 8.5 to 12.5 (4 panel widths, centered over panels 9,10,11,12)
    
    // Start at 0.5, 4.5, 8.5, etc (i*4 + 0.5)
    // End at 4.5, 8.5, 12.5, etc (i*4 + 4.5)
    const x1 = (i * 4 + 0.5) * size;  // Start position
    const width = 4 * size;            // Width is exactly 4 panels
    
    // Position above or below the 2W bumpers
    let yOffset;
    if(type === 'top') {
      // Above the 2W bumpers - at the very top
      yOffset = 0;
    } else {
      // Below the 2W bumpers
      yOffset = yBase + bumperHeight + fourWayGap;
    }
    
    // Draw 4-way bumper
    ctx.fillStyle = '#FF6B35'; // Orange color for 4W
    ctx.fillRect(x1, yOffset, width, fourWayHeight);
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(x1, yOffset, width, fourWayHeight);
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText('4W', x1 + width/2, yOffset + fourWayHeight/2);
  }
}

function setupStructureCanvasInteractivity() {
  const canvas = document.getElementById('structureCanvas');
  if(!canvas) return;
  
  // Store reference but don't clone - cloning erases the canvas content!
  structureCanvas = canvas;
  
  // Remove existing listeners by using a flag to track if already set up
  if(canvas._structureListenersAttached) {
    return; // Already set up, don't duplicate listeners
  }
  canvas._structureListenersAttached = true;
  
  canvas.style.cursor = manualBumperMode ? 'pointer' : 'default';
  
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  let bumperDragStartCol = -1; // Track starting column for undo
  
  // Left click - select bumpers in manual mode
  canvas.addEventListener('mousedown', function(e) {
    if(e.button !== 0) return; // Only left click
    
    hideContextMenu();
    
    // Check for modifier keys (Ctrl on Windows/Linux, Cmd on Mac)
    const isMultiSelect = e.ctrlKey || e.metaKey || e.shiftKey;
    
    // Check if clicking on a bumper
    const bumper = getBumperAtMouse(canvas, e.clientX, e.clientY);
    
    if(bumper) {
      if(manualBumperMode) {
        // In manual mode - handle selection
        if(!isMultiSelect) {
          selectedBumpers.clear();
        }
        
        // Toggle bumper selection
        if(selectedBumpers.has(bumper.id)) {
          selectedBumpers.delete(bumper.id);
        } else {
          selectedBumpers.add(bumper.id);
        }
        
        selectedBumper = bumper;
        structureDraggingBumper = bumper;
        bumperDragStartCol = bumper.startCol; // Save start position for undo
        
        // Calculate drag offset
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        dragOffsetX = mouseX - bumper.x;
        dragOffsetY = mouseY - bumper.y;
        
        canvas.style.cursor = 'grabbing';
        updateStructureSelectionInfo();
        generateStructureLayout();
      } else {
        // Not in manual mode - no interaction
      }
      
      structureIsDragging = true;
      structureDragStartX = e.clientX;
      structureDragStartY = e.clientY;
      return;
    }
    
    // Clicked on empty space - clear selection in manual mode
    if(manualBumperMode && !isMultiSelect) {
      selectedBumpers.clear();
      selectedBumper = null;
      updateStructureSelectionInfo();
      generateStructureLayout();
    }
  });
  
  // Mouse move - drag bumper (only in manual mode)
  canvas.addEventListener('mousemove', function(e) {
    // Handle bumper dragging (only in manual mode)
    if(structureDraggingBumper && manualBumperMode) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
      const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
      
      const size = 50;
      const newCol = Math.floor((mouseX - dragOffsetX) / size);
      const pw = parseInt(document.getElementById('panelsWide').value) || 0;
      
      // Constrain to valid columns
      if(newCol >= 0 && newCol < pw) {
        const bumperWidth = structureDraggingBumper.endCol - structureDraggingBumper.startCol;
        const maxStartCol = Math.max(0, pw - 1 - bumperWidth);
        const constrainedCol = Math.max(0, Math.min(newCol, maxStartCol));
        
        if(constrainedCol !== structureDraggingBumper.startCol) {
          const colDelta = constrainedCol - structureDraggingBumper.startCol;
          structureDraggingBumper.startCol = constrainedCol;
          structureDraggingBumper.endCol = structureDraggingBumper.endCol + colDelta;
          
          generateStructureLayout();
        }
      }
      return;
    }
    
    // Show hover effects for bumpers (only in manual mode)
    if(manualBumperMode) {
      const bumper = getBumperAtMouse(canvas, e.clientX, e.clientY);
      
      if(bumper) {
        canvas.style.cursor = 'grab';
        if(!hoveredBumper || hoveredBumper.id !== bumper.id) {
          hoveredBumper = bumper;
          generateStructureLayout();
        }
      } else {
        canvas.style.cursor = 'default';
        if(hoveredBumper) {
          hoveredBumper = null;
          generateStructureLayout();
        }
      }
    } else {
      canvas.style.cursor = 'default';
    }
  });
  
  // Mouse up - end drag and save state if bumper was moved
  canvas.addEventListener('mouseup', function(e) {
    if(structureDraggingBumper && manualBumperMode) {
      // Check if bumper was actually moved
      if(bumperDragStartCol !== -1 && bumperDragStartCol !== structureDraggingBumper.startCol) {
        saveStructureState(); // Save state after move
      }
      
      structureDraggingBumper = null;
      bumperDragStartCol = -1;
      canvas.style.cursor = 'pointer';
      
      // Update weight and calculations
      updateWeightDisplay();
      calculate();
      updateStructureUndoRedoButtons();
    }
    structureIsDragging = false;
  });
  
  // Right click - context menu (only in manual mode)
  canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    
    if(!manualBumperMode) return;
    
    const bumper = getBumperAtMouse(canvas, e.clientX, e.clientY);
    
    if(bumper) {
      // If clicked bumper is not selected, select only it
      if(!selectedBumpers.has(bumper.id)) {
        selectedBumpers.clear();
        selectedBumpers.add(bumper.id);
        updateStructureSelectionInfo();
        generateStructureLayout();
      }
      
      // Show bumper context menu
      showBumperContextMenu(bumper, e.clientX, e.clientY);
      return;
    }
    
    // Check if clicking in a bumper area (top or bottom) for adding bumpers
    const rect = canvas.getBoundingClientRect();
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    
    const pw = parseInt(document.getElementById('panelsWide').value) || 0;
    const ph = parseInt(document.getElementById('panelsHigh').value) || 0;
    const size = 50;
    const bumperHeight = 40;
    const fourWayHeight = 20;
    const fourWayGap = 5;
    
    const use4Way = use4WayBumpersEnabled;
    const panelType = document.getElementById('panelType').value;
    const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
    
    let panelYOffset = 0;
    if(showTopBumper) {
      panelYOffset += bumperHeight;
      if(use4Way && isCB5) panelYOffset += fourWayHeight + fourWayGap;
    }
    
    const column = Math.floor(x / size);
    
    // Check if in top bumper area
    if(showTopBumper) {
      const topBumperEnd = panelYOffset;
      if(y < topBumperEnd && column >= 0 && column < pw) {
        showEmptyAreaContextMenu('top', column, e.clientX, e.clientY);
        return;
      }
    }
    
    // Check if in bottom bumper area
    if(showBottomBumper) {
      const bottomBumperStart = panelYOffset + (ph * size);
      const bottomBumperEnd = bottomBumperStart + bumperHeight + (use4Way && isCB5 ? fourWayHeight + fourWayGap : 0);
      if(y >= bottomBumperStart && y < bottomBumperEnd && column >= 0 && column < pw) {
        showEmptyAreaContextMenu('bottom', column, e.clientX, e.clientY);
        return;
      }
    }
  });
  
  // Mouse leave - clear hover and end drag
  canvas.addEventListener('mouseleave', function(e) {
    if(hoveredBumper) {
      hoveredBumper = null;
      generateStructureLayout();
    }
    if(structureDraggingBumper) {
      structureDraggingBumper = null;
    }
    structureIsDragging = false;
    canvas.style.cursor = manualBumperMode ? 'pointer' : 'default';
  });
}

// Show context menu for panels in structure view
// Draw green highlight on bumper being dragged - optimized version
function drawBumperDragHighlight(canvas, clientX, clientY) {
  if(!structureDraggingBumper || !structureOriginalImageData) return;
  
  const ctx = canvas.getContext('2d');
  const p = panels[document.getElementById('panelType').value];
  if(!p.width_m || !p.height_m) return;
  
  const {pw, ph} = getEffectivePanelCountsForLayout();
  const needsOneW = pw % 2 === 1;
  
  // Restore original canvas state
  ctx.putImageData(structureOriginalImageData, 0, 0);
  
  const size = 50;
  const bumperHeight = 40;
  const panelYOffset = showTopBumper ? bumperHeight : 0;
  const type = structureDraggingBumper.type;
  const draggedColumn = structureDraggingBumper.column;
  
  // Calculate the Y position of the bumper being dragged
  let yOffset;
  if(type === 'top') {
    if(structureDraggingBumper.is2W) {
      const row1 = getFirstNonDeletedRow(draggedColumn, ph);
      const row2 = draggedColumn + 1 < pw ? getFirstNonDeletedRow(draggedColumn + 1, ph) : row1;
      const maxRow = Math.max(row1, row2);
      yOffset = (panelYOffset - bumperHeight) + (maxRow * size);
    } else {
      const row = getFirstNonDeletedRow(draggedColumn, ph);
      yOffset = (panelYOffset - bumperHeight) + (row * size);
    }
  } else {
    const bottomYBase = panelYOffset + (ph * size);
    yOffset = bottomYBase;
  }
  
  // Draw green outline around the bumper being dragged
  ctx.strokeStyle = '#00FF00';
  ctx.lineWidth = 4;
  const x = draggedColumn * size;
  const width = structureDraggingBumper.is2W ? (2 * size) : size;
  ctx.strokeRect(x, yOffset, width, bumperHeight);
  
  // Get hover column
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const canvasX = (clientX - rect.left) * scaleX;
  const hoverColumn = Math.floor(canvasX / size);
  
  // Show preview outline where it will go
  if(hoverColumn >= 0 && hoverColumn < pw && hoverColumn !== draggedColumn) {
    const currentOneWPos = type === 'top' ? topBumper1wColumn : bottomBumper1wColumn;
    let canDropHere = false;
    let previewWidth = size;
    
    if(structureDraggingBumper.is2W) {
      // For 2W bumpers, only show preview if hovering directly over the 1W position (for swap)
      if(needsOneW && hoverColumn === currentOneWPos) {
        canDropHere = true;
        previewWidth = size; // Will show where the 1W will move to
      }
    } else if(structureDraggingBumper.isOneW) {
      // 1W bumpers can be moved anywhere
      canDropHere = true;
      previewWidth = size;
    }
    
    if(canDropHere) {
      let previewY;
      let previewX;
      
      if(structureDraggingBumper.is2W && hoverColumn === currentOneWPos) {
        // Show where the 1W will move to (the dragged 2W's first column)
        previewX = draggedColumn * size;
        if(type === 'top') {
          const row = getFirstNonDeletedRow(draggedColumn, ph);
          previewY = (panelYOffset - bumperHeight) + (row * size);
        } else {
          const bottomYBase = panelYOffset + (ph * size);
          previewY = bottomYBase;
        }
      } else {
        // Normal 1W move preview
        previewX = hoverColumn * size;
        if(type === 'top') {
          const row = getFirstNonDeletedRow(hoverColumn, ph);
          previewY = (panelYOffset - bumperHeight) + (row * size);
        } else {
          const bottomYBase = panelYOffset + (ph * size);
          previewY = bottomYBase;
        }
      }
      
      // Draw dashed green preview outline
      ctx.strokeStyle = '#00FF00';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 4]);
      ctx.strokeRect(previewX, previewY, previewWidth, bumperHeight);
      ctx.setLineDash([]);
      
      // Add helper text for 2W -> 1W swap
      if(structureDraggingBumper.is2W && needsOneW && hoverColumn === currentOneWPos) {
        ctx.fillStyle = '#00FF00';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('SWAP', hoverColumn * size + size/2, previewY - 8);
      }
    }
  }
}

function getBumperAtPosition(canvas, clientX, clientY) {
  const p = panels[document.getElementById('panelType').value];
  if(!p.width_m || !p.height_m) return null;
  
  const {pw, ph} = getEffectivePanelCountsForLayout();
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const canvasX = (clientX - rect.left) * scaleX;
  const canvasY = (clientY - rect.top) * scaleY;
  
  const size = 50;
  const bumperHeight = 40;
  const panelYOffset = showTopBumper ? bumperHeight : 0;
  const column = Math.floor(canvasX / size);
  
  if(column < 0 || column >= pw) return null;
  
  // Check top bumper
  if(showTopBumper) {
    const oneWPos = topBumper1wColumn >= 0 && topBumper1wColumn < pw ? topBumper1wColumn : (pw - 1);
    const needsOneW = pw % 2 === 1;
    
    // Check if clicking on the 1W bumper specifically
    if(needsOneW && column === oneWPos) {
      const row = getFirstNonDeletedRow(column, ph);
      const expectedY = (panelYOffset - bumperHeight) + (row * size);
      
      if(canvasY >= expectedY && canvasY <= expectedY + bumperHeight) {
        return {type: 'top', column: column, isOneW: true};
      }
    }
    
    // Check for 2W bumpers
    for(let c = 0; c < pw; c++) {
      if(needsOneW && c === oneWPos) continue;
      
      if(c + 1 < pw && (c + 1) !== oneWPos) {
        // This is a 2W bumper covering columns c and c+1
        if(column === c || column === c + 1) {
          const row1 = getFirstNonDeletedRow(c, ph);
          const row2 = getFirstNonDeletedRow(c + 1, ph);
          const maxRow = Math.max(row1, row2);
          const expectedY = (panelYOffset - bumperHeight) + (maxRow * size);
          
          if(canvasY >= expectedY && canvasY <= expectedY + bumperHeight) {
            return {type: 'top', column: c, isOneW: false, is2W: true};
          }
        }
        c++;
      } else if(!needsOneW && c + 1 >= pw) {
        if(column === c) {
          const row = getFirstNonDeletedRow(c, ph);
          const expectedY = (panelYOffset - bumperHeight) + (row * size);
          
          if(canvasY >= expectedY && canvasY <= expectedY + bumperHeight) {
            return {type: 'top', column: column, isOneW: false};
          }
        }
      }
    }
  }
  
  // Check bottom bumper
  if(showBottomBumper) {
    const oneWPos = bottomBumper1wColumn >= 0 && bottomBumper1wColumn < pw ? bottomBumper1wColumn : (pw - 1);
    const needsOneW = pw % 2 === 1;
    const bottomYBase = panelYOffset + (ph * size);
    const expectedY = bottomYBase; // Bottom bumpers always at yBase
    
    // Check if click is within bumper Y range
    if(canvasY >= expectedY && canvasY <= expectedY + bumperHeight) {
      // Check if clicking on the 1W bumper specifically
      if(needsOneW && column === oneWPos) {
        // Only return if this column should have a bottom bumper
        if(shouldHaveBottomBumper(oneWPos, ph)) {
          return {type: 'bottom', column: column, isOneW: true};
        }
      }
      
      // Check for 2W bumpers
      for(let c = 0; c < pw; c++) {
        if(needsOneW && c === oneWPos) continue;
        
        if(c + 1 < pw && (c + 1) !== oneWPos) {
          // This is a 2W bumper covering columns c and c+1
          if(column === c || column === c + 1) {
            // Only return if both columns should have bottom bumpers
            if(shouldHaveBottomBumper(c, ph) && shouldHaveBottomBumper(c + 1, ph)) {
              return {type: 'bottom', column: c, isOneW: false, is2W: true};
            }
          }
          c++;
        } else if(!needsOneW && c + 1 >= pw) {
          if(column === c) {
            // Only return if this column should have a bottom bumper
            if(shouldHaveBottomBumper(c, ph)) {
              return {type: 'bottom', column: column, isOneW: false};
            }
          }
        }
      }
    }
  }
  
  return null;
}

function updateBumpersBasedOnStructureType() {
  const structureType = document.getElementById('structureType').value;
  
  // Only set bumper flags if bumpers are enabled
  if(useBumpers) {
    if(structureType === 'hanging') {
      showTopBumper = true;
      showBottomBumper = false;
    } else { // ground stacking
      showTopBumper = false;
      showBottomBumper = true;
    }
  } else {
    // Bumpers disabled - ensure flags are false
    showTopBumper = false;
    showBottomBumper = false;
  }
  
  // Reinitialize bumpers when structure type changes
  initializeBumpers();
  
  updateStructureVisualization();
  updateWeightDisplay();
}

function toggleTopBumper() {
  // Deprecated - kept for backward compatibility
  showTopBumper = !showTopBumper;
  generateStructureLayout();
}

function toggleBottomBumper() {
  // Deprecated - kept for backward compatibility
  showBottomBumper = !showBottomBumper;
  generateStructureLayout();
}


// Interactive panel selection functions
function getPanelAtPosition(canvas, x, y) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const canvasX = (x - rect.left) * scaleX;
  const canvasY = (y - rect.top) * scaleY;
  
  const col = Math.floor(canvasX / panelSize);
  const row = Math.floor(canvasY / panelSize);
  
  if(col >= 0 && col < currentPw && row >= 0 && row < currentPh) {
    return {col, row, key: `${col},${row}`};
  }
  return null;
}

function getPanelsInRect(x1, y1, x2, y2) {
  const rect = currentCanvas.getBoundingClientRect();
  const scaleX = currentCanvas.width / rect.width;
  const scaleY = currentCanvas.height / rect.height;
  
  const canvasX1 = (Math.min(x1, x2) - rect.left) * scaleX;
  const canvasY1 = (Math.min(y1, y2) - rect.top) * scaleY;
  const canvasX2 = (Math.max(x1, x2) - rect.left) * scaleX;
  const canvasY2 = (Math.max(y1, y2) - rect.top) * scaleY;
  
  const col1 = Math.max(0, Math.floor(canvasX1 / panelSize));
  const row1 = Math.max(0, Math.floor(canvasY1 / panelSize));
  const col2 = Math.min(currentPw - 1, Math.floor(canvasX2 / panelSize));
  const row2 = Math.min(currentPh - 1, Math.floor(canvasY2 / panelSize));
  
  const panels = [];
  for(let c = col1; c <= col2; c++) {
    for(let r = row1; r <= row2; r++) {
      panels.push({col: c, row: r, key: `${c},${r}`});
    }
  }
  return panels;
}

function deleteSelectedPanels() {
  if(selectedPanels.size === 0) return;
  
  saveState(); // Save state before making changes
  
  selectedPanels.forEach(key => {
    deletedPanels.add(key);
  });
  selectedPanels.clear();
  
  // Save to current screen data so canvas view can see it
  if(screens[currentScreenId]) {
    screens[currentScreenId].data.deletedPanels = new Set(deletedPanels);
  }
  
  // Regenerate all layouts and recalculate
  calculate();
  
  // Update canvas view to reflect deleted panels
  showCanvasView();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
}

let canvasListenersSetup = false;

function setupStandardCanvasInteractivity() {
  const canvas = document.getElementById('standardCanvas');
  if(!canvas) return;
  
  // Only setup listeners once
  if(canvasListenersSetup) {
    currentCanvas = canvas;
    return;
  }
  
  canvasListenersSetup = true;
  currentCanvas = canvas;
  
  // Mouse down - start selection
  canvas.addEventListener('mousedown', function(e) {
    if(e.button !== 0) return; // Only left click
    
    const panel = getPanelAtPosition(canvas, e.clientX, e.clientY);
    if(!panel) return;
    
    // Check for modifier keys (Ctrl on Windows/Linux, Cmd on Mac)
    const isMultiSelect = e.ctrlKey || e.metaKey || e.shiftKey;
    
    if(!isMultiSelect) {
      selectedPanels.clear();
    }
    
    // Toggle selection of clicked panel
    if(selectedPanels.has(panel.key)) {
      selectedPanels.delete(panel.key);
    } else {
      selectedPanels.add(panel.key);
    }
    
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    
    generateLayout('standard');
  });
  
  // Mouse move - drag selection
  canvas.addEventListener('mousemove', function(e) {
    if(!isDragging) return;
    
    const dx = Math.abs(e.clientX - dragStartX);
    const dy = Math.abs(e.clientY - dragStartY);
    
    // Only do rect selection if dragged more than 5 pixels
    if(dx > 5 || dy > 5) {
      const panels = getPanelsInRect(dragStartX, dragStartY, e.clientX, e.clientY);
      
      const isMultiSelect = e.ctrlKey || e.metaKey || e.shiftKey;
      if(!isMultiSelect) {
        selectedPanels.clear();
      }
      
      panels.forEach(p => {
        selectedPanels.add(p.key);
      });
      
      generateLayout('standard');
    }
  });
  
  // Mouse up - end selection
  canvas.addEventListener('mouseup', function(e) {
    isDragging = false;
  });
  
  // Mouse leave - end drag
  canvas.addEventListener('mouseleave', function(e) {
    isDragging = false;
  });
  
  // Right click - context menu
  canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    
    const panel = getPanelAtPosition(canvas, e.clientX, e.clientY);
    if(!panel) return;
    
    // If clicked panel is not selected, select only it
    if(!selectedPanels.has(panel.key)) {
      selectedPanels.clear();
      selectedPanels.add(panel.key);
      generateLayout('standard');
    }
    
    // Show context menu
    showContextMenu(e.clientX, e.clientY);
  });
}

function showContextMenu(x, y) {
  // Remove existing menu if any
  const existingMenu = document.getElementById('panelContextMenu');
  if(existingMenu) existingMenu.remove();
  
  // Create context menu
  const menu = document.createElement('div');
  menu.id = 'panelContextMenu';
  menu.style.position = 'fixed';
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.style.background = '#2a2a2a';
  menu.style.border = '1px solid #555';
  menu.style.borderRadius = '4px';
  menu.style.padding = '4px 0';
  menu.style.zIndex = '10000';
  menu.style.minWidth = '200px';
  menu.style.boxShadow = '0 2px 8px rgba(0,0,0,0.5)';
  
  // Assign Circuit option
  const assignCircuitOption = document.createElement('div');
  assignCircuitOption.textContent = `Assign Circuit # to ${selectedPanels.size} panel(s)`;
  assignCircuitOption.style.padding = '8px 12px';
  assignCircuitOption.style.cursor = 'pointer';
  assignCircuitOption.style.color = '#e0e0e0';
  assignCircuitOption.style.fontSize = '13px';
  assignCircuitOption.style.borderBottom = '1px solid #444';
  assignCircuitOption.addEventListener('mouseover', function() {
    assignCircuitOption.style.background = '#0a66c2';
  });
  assignCircuitOption.addEventListener('mouseout', function() {
    assignCircuitOption.style.background = 'transparent';
  });
  assignCircuitOption.addEventListener('click', function() {
    menu.remove();
    showCircuitNumberPrompt();
  });
  
  // Assign Data Line option
  const assignDataLineOption = document.createElement('div');
  assignDataLineOption.textContent = `Assign Data Line # to ${selectedPanels.size} panel(s)`;
  assignDataLineOption.style.padding = '8px 12px';
  assignDataLineOption.style.cursor = 'pointer';
  assignDataLineOption.style.color = '#e0e0e0';
  assignDataLineOption.style.fontSize = '13px';
  assignDataLineOption.style.borderBottom = '1px solid #444';
  assignDataLineOption.addEventListener('mouseover', function() {
    assignDataLineOption.style.background = '#0a66c2';
  });
  assignDataLineOption.addEventListener('mouseout', function() {
    assignDataLineOption.style.background = 'transparent';
  });
  assignDataLineOption.addEventListener('click', function() {
    menu.remove();
    showDataLineNumberPrompt();
  });
  
  // Delete option
  const deleteOption = document.createElement('div');
  deleteOption.textContent = `Delete ${selectedPanels.size} panel(s)`;
  deleteOption.style.padding = '8px 12px';
  deleteOption.style.cursor = 'pointer';
  deleteOption.style.color = '#e0e0e0';
  deleteOption.style.fontSize = '13px';
  deleteOption.addEventListener('mouseover', function() {
    deleteOption.style.background = '#0a66c2';
  });
  deleteOption.addEventListener('mouseout', function() {
    deleteOption.style.background = 'transparent';
  });
  deleteOption.addEventListener('click', function() {
    deleteSelectedPanels();
    menu.remove();
  });
  
  menu.appendChild(assignCircuitOption);
  menu.appendChild(assignDataLineOption);
  menu.appendChild(deleteOption);
  document.body.appendChild(menu);
  
  // Close menu when clicking elsewhere
  setTimeout(() => {
    document.addEventListener('click', function closeMenu(e) {
      if(!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    });
  }, 10);
}

function showCircuitNumberPrompt() {
  const circuitNum = prompt(`Enter circuit number for ${selectedPanels.size} selected panel(s):\n\n(Enter a number 1-999, or leave blank to clear custom assignment)`);
  
  if(circuitNum === null) return; // User cancelled
  
  saveState(); // Save state before making changes
  
  if(circuitNum.trim() === '') {
    // Clear custom assignments for selected panels
    selectedPanels.forEach(key => {
      customCircuitAssignments.delete(key);
    });
  } else {
    const num = parseInt(circuitNum);
    if(isNaN(num) || num < 1 || num > 999) {
      alert('Please enter a valid circuit number between 1 and 999');
      return;
    }
    
    // Assign circuit number to selected panels
    selectedPanels.forEach(key => {
      customCircuitAssignments.set(key, num);
    });
  }
  
  selectedPanels.clear();
  calculate();
}

function showDataLineNumberPrompt() {
  const dataLineNum = prompt(`Enter data line number for ${selectedPanels.size} selected panel(s):\n\n(Enter a number 1-999, or leave blank to clear custom assignment)`);
  
  if(dataLineNum === null) return; // User cancelled
  
  saveState(); // Save state before making changes
  
  if(dataLineNum.trim() === '') {
    // Clear custom assignments for selected panels
    selectedPanels.forEach(key => {
      customDataLineAssignments.delete(key);
    });
  } else {
    const num = parseInt(dataLineNum);
    if(isNaN(num) || num < 1 || num > 999) {
      alert('Please enter a valid data line number between 1 and 999');
      return;
    }
    
    // Assign data line number to selected panels
    selectedPanels.forEach(key => {
      customDataLineAssignments.set(key, num);
    });
  }
  
  selectedPanels.clear();
  calculate();
}

function drawVArrowhead(ctx, x, y, angle, colorHex){
  const size = 12;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.strokeStyle = colorHex;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(-size, -size/2);
  ctx.lineTo(0, 0);
  ctx.lineTo(-size, size/2);
  ctx.stroke();
  ctx.restore();
}

// Calculate and update the suggested max panels per circuit based on power settings
function updateSuggestedCircuitLimit(){
  const p = panels[document.getElementById('panelType').value];
  if(!p || !p.power_max_w) {
    document.getElementById('maxPanelsPerCircuit').placeholder = "Auto";
    return;
  }
  
  const voltage = parseFloat(document.getElementById('voltage').value) || 208;
  const breaker = parseFloat(document.getElementById('breaker').value) || 20;
  // Derate removed - default to no derating
  const derate = 1.0; // Derating disabled
  const powerType = document.getElementById('powerType').value;
  
  const circuitCapacityW = voltage * breaker * derate;
  const perPanelW = powerType === 'max' ? p.power_max_w : (p.power_avg_w || p.power_max_w * 0.5);
  const powerBasedLimit = Math.max(1, Math.floor(circuitCapacityW / perPanelW));
  
  const input = document.getElementById('maxPanelsPerCircuit');
  if(input && !input.value) {
    input.placeholder = powerBasedLimit.toString();
  }
}

function updateSuggestedDataLimit(){
  const p=panels[document.getElementById('panelType').value];
  const pr=processors[document.getElementById('processor').value];
  if(!p.res_x || !p.res_y){ document.getElementById('maxPanelsPerData').placeholder = "Auto"; return; }
  
  // Check if CB5 half panel row is enabled
  // Using cb5HalfRowEnabled toggle state
  const hasCB5HalfRow = cb5HalfRowEnabled && document.getElementById('panelType').value === 'CB5_MKII';
  
  const pixelsPerPanel = p.res_x*p.res_y;
  const frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  const bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  const adjustedCapacity = calculateAdjustedPixelCapacity(pr, frameRate, bitDepth);
  
  // Calculate suggested panels per data line accounting for mixed panel types
  let capacityBasedLimit;
  if(hasCB5HalfRow) {
    // With half panels mixed in, use a conservative estimate
    // The actual number depends on the ratio, but to be safe we'll calculate
    // based on assuming roughly equal mix (or weighted average)
    const halfPanel = panels['CB5_MKII_HALF'];
    const halfPanelPixels = halfPanel.res_x * halfPanel.res_y;
    
    // Calculate both limits
    const fullPanelLimit = Math.floor(adjustedCapacity / pixelsPerPanel);
    const halfPanelLimit = Math.floor(adjustedCapacity / halfPanelPixels);
    
    // Use a weighted average based on typical usage:
    // Assuming most walls have more full panels than half panels (e.g., 4:1 ratio)
    // This gives a more realistic estimate than pure averaging
    const weightedPixelsPerPanel = (pixelsPerPanel * 0.8) + (halfPanelPixels * 0.2);
    capacityBasedLimit = Math.max(1, Math.floor(adjustedCapacity / weightedPixelsPerPanel));
  } else {
    capacityBasedLimit = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
  }
  
  // Use the panel-specific limit if available, otherwise use capacity-based calculation
  // NOTE: Don't use panel-specific limit when mixing full and half panels
  const panelSpecificLimit = (!hasCB5HalfRow && p.max_panels_per_data) ? p.max_panels_per_data : null;
  const suggested = panelSpecificLimit 
    ? Math.min(capacityBasedLimit, panelSpecificLimit)
    : capacityBasedLimit;
  
  const input = document.getElementById('maxPanelsPerData');
  if(!input.value){ input.placeholder = suggested; }
}

function showCanvasView(){
  // Clear any cached canvas image to ensure fresh render
  cachedCanvasImageData = null;
  
  // Reset viewport pan to show origin (0,0)
  if(canvasZoomLevel === 1.0) {
    canvasPanX = 0;
    canvasPanY = 0;
  }
  
  // Show canvas container early to ensure it's laid out before we draw
  const container = document.getElementById('canvasContainer');
  container.style.display = 'block';
  
  // Force browser reflow to ensure container is laid out
  void container.offsetHeight;
  
  const canvasSize = document.getElementById('canvasSize').value;
  
  // Get canvas resolution
  let canvasResX, canvasResY, canvasName;
  if(canvasSize === '4K_UHD'){
    canvasResX = 3840; canvasResY = 2160; canvasName = '4K UHD (3840x2160)';
  } else if(canvasSize === '4K_DCI'){
    canvasResX = 4096; canvasResY = 2160; canvasName = '4K DCI (4096x2160)';
  } else if(canvasSize === 'HD'){
    canvasResX = 1920; canvasResY = 1080; canvasName = 'HD (1920x1080)';
  } else if(canvasSize === 'custom'){
    canvasResX = parseInt(document.getElementById('customCanvasWidth').value) || 1920;
    canvasResY = parseInt(document.getElementById('customCanvasHeight').value) || 1080;
    canvasName = `Custom (${canvasResX}x${canvasResY})`;
  }
  
  const canvas = document.getElementById('canvasView');
  const ctx = canvas.getContext('2d');
  
  // Set canvas internal resolution (always full resolution for quality)
  canvas.width = canvasResX;
  canvas.height = canvasResY;
  
  // Explicitly position canvas at origin
  canvas.style.position = 'relative';
  canvas.style.left = '0px';
  canvas.style.top = '0px';
  canvas.style.margin = '0';
  canvas.style.padding = '0';
  
  // Calculate the base display size to fit in wrapper (800x450)
  const wrapperWidth = 800;
  const wrapperHeight = 450;
  const scaleX = wrapperWidth / canvasResX;
  const scaleY = wrapperHeight / canvasResY;
  const baseScale = Math.min(scaleX, scaleY);
  
  // Set canvas display size at base scale (fits in wrapper at 100% zoom)
  const displayWidth = canvasResX * baseScale;
  const displayHeight = canvasResY * baseScale;
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  
  console.log(`Canvas setup: internal=${canvasResX}x${canvasResY}, display=${displayWidth}x${displayHeight}, baseScale=${baseScale}`);
  console.log(`Viewport: zoom=${canvasZoomLevel}, panX=${canvasPanX}, panY=${canvasPanY}`);
  
  // Log actual DOM positions for debugging
  const canvasRect = canvas.getBoundingClientRect();
  const viewportEl = document.getElementById('canvasViewport');
  const viewportRect = viewportEl ? viewportEl.getBoundingClientRect() : null;
  const wrapperEl = document.getElementById('canvasViewWrapper');
  const wrapperRect = wrapperEl ? wrapperEl.getBoundingClientRect() : null;
  
  console.log('Canvas rect:', {x: canvasRect.x, y: canvasRect.y, width: canvasRect.width, height: canvasRect.height});
  if(viewportRect) console.log('Viewport rect:', {x: viewportRect.x, y: viewportRect.y, width: viewportRect.width, height: viewportRect.height});
  if(wrapperRect) console.log('Wrapper rect:', {x: wrapperRect.x, y: wrapperRect.y, width: wrapperRect.width, height: wrapperRect.height});
  if(viewportEl) console.log('Viewport transform:', viewportEl.style.transform);
  
  // Apply zoom and pan transform
  updateCanvasViewport();
  
  // Force multiple browser reflows to ensure proper rendering
  void canvas.offsetHeight;
  void canvas.offsetWidth;
  void canvas.getBoundingClientRect();
  
  // Force a style recalculation
  canvas.style.transform = canvas.style.transform;
  
  // Clear canvas with black background
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, canvasResX, canvasResY);
  
  // Sort screen IDs numerically
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numA - numB;
  });
  
  // Draw each visible screen
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    
    // Skip invisible screens
    if(!screen.visible) return;
    
    const screenData = screen.data;
    const panelType = screenData.panelType || 'CB5_MKII';
    const p = panels[panelType];
    
    if(!p || !p.width_m || !p.height_m || !p.res_x || !p.res_y) return;
    
    // Get panel dimensions for this screen
    const pw = screenData.panelsWide || 0;
    const ph = screenData.panelsHigh || 0;
    
    if(pw === 0 || ph === 0) return;
    
    // Check if CB5 half panel row is enabled for this screen
    const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';
    
    // Calculate wall resolution accounting for CB5 half panels
    let wallResX, wallResY;
    if(hasCB5HalfRow) {
      const halfPanel = panels['CB5_MKII_HALF'];
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y + halfPanel.res_y;
    } else {
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y;
    }
    
    // Ensure canvas position is a valid number, default to 0
    const offsetX = (typeof screenData.canvasX === 'number' && !isNaN(screenData.canvasX)) ? screenData.canvasX : 0;
    const offsetY = (typeof screenData.canvasY === 'number' && !isNaN(screenData.canvasY)) ? screenData.canvasY : 0;
    
    console.log(`showCanvasView rendering ${screenId}: offsetX=${offsetX}, offsetY=${offsetY}, screenData.canvasX=${screenData.canvasX}, screenData.canvasY=${screenData.canvasY}`);
    
    const totalRows = hasCB5HalfRow ? ph + 1 : ph;
    // Ensure deletedPanels is a Set (might be array from JSON load)
    let deletedPanelsForScreen = screenData.deletedPanels;
    if(deletedPanelsForScreen && !(deletedPanelsForScreen instanceof Set)) {
      deletedPanelsForScreen = new Set(deletedPanelsForScreen);
    }
    if(!deletedPanelsForScreen) {
      deletedPanelsForScreen = new Set();
    }
    
    // Pre-calculate colors and halfPanel outside loop
    const primaryColor = screen.color || '#808080';
    const secondaryColor = screen.color2 || darkenColor(primaryColor, 30);
    const halfPanel = panels['CB5_MKII_HALF'];
    
    // Draw panels for this screen - optimized loop
    for(let c = 0; c < pw; c++){
      const xBase = offsetX + (c * p.res_x);
      
      for(let r = 0; r < totalRows; r++){
        const panelKey = `${c},${r}`;
        
        // Skip deleted panels
        if(deletedPanelsForScreen.has(panelKey)) continue;
        
        // Determine if this is the half panel row
        const isHalfPanelRow = hasCB5HalfRow && (r === ph);
        
        // Calculate panel pixel dimensions
        const panelResX = isHalfPanelRow ? halfPanel.res_x : p.res_x;
        const panelResY = isHalfPanelRow ? halfPanel.res_y : p.res_y;
        
        // Calculate Y position
        const y = offsetY + (r * p.res_y);
        
        // Skip if out of view
        if(xBase >= canvasResX || y >= canvasResY || xBase + panelResX <= 0 || y + panelResY <= 0) continue;
        
        // Use alternating colors for checkerboard pattern
        const fillColor = ((c + r) % 2 === 0) ? primaryColor : secondaryColor;
        ctx.fillStyle = fillColor;
        ctx.fillRect(xBase, y, panelResX, panelResY);
        
        // Off-white outline for visibility
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 2;
        ctx.strokeRect(xBase, y, panelResX, panelResY);
        
        // Draw panel label
        ctx.fillStyle = getContrastColor(fillColor);
        const fontSize = Math.max(12, Math.min(panelResX, panelResY) / 4);
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${c+1}.${r+1}`, xBase + panelResX/2, y + panelResY/2);
      }
    }
    
    // Add X/Y coordinates in top-left corner (if enabled for this screen)
    if(screen.showCoordinates !== false) {
      const coordFontSize = Math.max(14, Math.min(p.res_x, p.res_y) / 6);
      ctx.font = `bold ${coordFontSize}px Arial`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      
      const coordPadding = 8;
      const textX = offsetX + coordPadding;
      const textY = offsetY + coordPadding;
      const lineHeight = coordFontSize + 4;
      
      // Semi-transparent dark background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(textX - 4, textY - 4, 80, lineHeight * 2 + 4);
      
      // Draw coordinates
      ctx.fillStyle = '#f0f0f0';
      ctx.fillText(`X: ${screenData.canvasX || 0}`, textX, textY);
      ctx.fillText(`Y: ${screenData.canvasY || 0}`, textX, textY + lineHeight);
    }
    
    // Add screen name overlay - simplified shadow
    const screenName = screen.name;
    if(screenName) {
      const wallCenterX = offsetX + (wallResX / 2);
      const wallCenterY = offsetY + (wallResY / 2);
      const baseFontSize = Math.min(wallResX, wallResY) * 0.15;
      
      ctx.font = `bold ${baseFontSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Simple shadow (reduced from 13 to 4 draws)
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillText(screenName, wallCenterX + 3, wallCenterY + 3);
      ctx.fillText(screenName, wallCenterX - 2, wallCenterY + 2);
      
      // Yellow text on top
      ctx.fillStyle = '#FFFF00';
      ctx.fillText(screenName, wallCenterX, wallCenterY);
    }
    
    // Add screen resolution at bottom-left (if enabled for this screen) - simplified shadow
    if(screen.showPixelDimensions !== false) {
      const resFontSize = Math.max(14, Math.min(wallResX, wallResY) * 0.06);
      ctx.font = `bold ${resFontSize}px Arial`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      
      const resTextX = offsetX + 10;
      const resTextY = offsetY + wallResY - 10;
      const resText = `${wallResX} Ã— ${wallResY}`;
      
      // Simple shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillText(resText, resTextX + 2, resTextY + 2);
      
      // Yellow text
      ctx.fillStyle = '#FFFF00';
      ctx.fillText(resText, resTextX, resTextY);
    }
  });
  
  // Update info display
  let totalWalls = 0;
  let totalPanels = 0;
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    if(screen.visible && screen.data.panelsWide > 0 && screen.data.panelsHigh > 0) {
      totalWalls++;
      totalPanels += screen.data.panelsWide * screen.data.panelsHigh;
    }
  });
  
  document.getElementById('canvasInfo').innerHTML = 
    `Canvas Resolution: ${canvasResX} Ã— ${canvasResY} px<br>` +
    `Visible Screens: ${totalWalls}<br>` +
    `Total Panels: ${totalPanels}`;
  
  // Cache the canvas state for quick selection highlighting
  cachedCanvasImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  
  // Setup canvas view interactivity
  setupCanvasViewInteractivity();
  
  // Force browser repaint using multiple techniques
  const viewport = document.getElementById('canvasViewport');
  if(viewport) {
    // Method 1: willChange hint
    viewport.style.willChange = 'transform';
    void viewport.offsetHeight;
    viewport.style.willChange = 'auto';
    
    // Method 2: Force repaint by toggling visibility
    const originalDisplay = viewport.style.display;
    viewport.style.display = 'none';
    void viewport.offsetHeight; // Force reflow
    viewport.style.display = originalDisplay || '';
  }
  
  // Method 3: Force repaint on canvas with opacity trick
  canvas.style.opacity = '0.9999';
  void canvas.offsetHeight;
  canvas.style.opacity = '1';
  
  // Method 4: Force a transform update on viewport
  if(viewport) {
    const currentTransform = viewport.style.transform;
    viewport.style.transform = 'none';
    void viewport.offsetHeight;
    viewport.style.transform = currentTransform;
  }
  
  // WORKAROUND: Second render after delay
  if(!isSecondRenderPass) {
    isSecondRenderPass = true;
    setTimeout(() => {
      showCanvasView();
      isSecondRenderPass = false;
    }, 50);
  }
}

// Cached canvas image for fast selection highlighting
let cachedCanvasImageData = null;
let canvasViewDragging = false;
let canvasViewDragStartX = 0;
let canvasViewDragStartY = 0;
let canvasViewStartOffsetX = 0;
let canvasViewStartOffsetY = 0;
let canvasViewOriginalImageData = null;
let canvasViewFocused = false;
let canvasViewKeyPressed = new Set();
let canvasViewKeyInterval = null;
let canvasViewRedrawTimeout = null;
let isSecondRenderPass = false; // Flag to prevent infinite recursion
let draggedScreenId = null; // Track which screen is being dragged
let selectedCanvasScreenId = null; // Track which screen is selected (highlighted)

// Draw selection highlight on canvas without full redraw
function drawSelectionHighlight() {
  if(!selectedCanvasScreenId || !screens[selectedCanvasScreenId]) return;
  
  const canvas = document.getElementById('canvasView');
  if(!canvas) return;
  const ctx = canvas.getContext('2d');
  
  const selectedScreen = screens[selectedCanvasScreenId];
  if(!selectedScreen.visible) return;
  
  const screenData = selectedScreen.data;
  const panelType = screenData.panelType || 'CB5_MKII';
  const p = panels[panelType];
  
  if(!p || !p.res_x || !p.res_y || !screenData.panelsWide || !screenData.panelsHigh) return;
  
  const offsetX = screenData.canvasX || 0;
  const offsetY = screenData.canvasY || 0;
  
  // Check if CB5 half panel row is enabled for this screen
  const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';
  
  // Calculate wall resolution accounting for CB5 half panels
  let wallResX, wallResY;
  if(hasCB5HalfRow) {
    const halfPanel = panels['CB5_MKII_HALF'];
    wallResX = screenData.panelsWide * p.res_x;
    wallResY = screenData.panelsHigh * p.res_y + halfPanel.res_y;
  } else {
    wallResX = screenData.panelsWide * p.res_x;
    wallResY = screenData.panelsHigh * p.res_y;
  }
  
  // Draw thick cyan highlight border
  ctx.strokeStyle = '#00FFFF';
  ctx.lineWidth = 6;
  ctx.setLineDash([]);
  ctx.strokeRect(offsetX - 3, offsetY - 3, wallResX + 6, wallResY + 6);
  
  // Draw inner white border for contrast
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 2;
  ctx.strokeRect(offsetX - 6, offsetY - 6, wallResX + 12, wallResY + 12);
}

// Helper function to detect which screen is clicked
function getScreenAtPosition(mouseX, mouseY) {
  // Check screens in reverse order (top screen first)
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numB - numA; // Reverse order
  });
  
  for(const screenId of screenIds) {
    const screen = screens[screenId];
    
    if(!screen.visible) continue;
    
    const screenData = screen.data;
    const panelType = screenData.panelType || 'CB5_MKII';
    const p = panels[panelType];
    
    if(!p || !p.res_x || !p.res_y) continue;
    
    const pw = screenData.panelsWide || 0;
    const ph = screenData.panelsHigh || 0;
    
    if(pw === 0 || ph === 0) continue;
    
    // Check if CB5 half panel row is enabled for this screen
    const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';
    
    // Calculate wall resolution accounting for CB5 half panels
    let wallResX, wallResY;
    if(hasCB5HalfRow) {
      const halfPanel = panels['CB5_MKII_HALF'];
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y + halfPanel.res_y;
    } else {
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y;
    }
    
    const offsetX = screenData.canvasX || 0;
    const offsetY = screenData.canvasY || 0;
    
    // Check if click is within this screen's bounds
    if(mouseX >= offsetX && mouseX <= offsetX + wallResX &&
       mouseY >= offsetY && mouseY <= offsetY + wallResY) {
      return screenId;
    }
  }
  
  return null;
}


function setupCanvasViewInteractivity() {
  const canvas = document.getElementById('canvasView');
  if(!canvas) return;
  
  // Initialize history with current position if history is empty
  if(canvasMoveHistory.length === 0) {
    const initialState = {
      x: parseInt(document.getElementById('canvasX').value) || 0,
      y: parseInt(document.getElementById('canvasY').value) || 0
    };
    canvasMoveHistory.push(initialState);
    canvasMoveHistoryIndex = 0;
    updateCanvasUndoRedoButtons();
  }
  
  // Remove old listeners if they exist
  canvas.onmousedown = null;
  canvas.onmousemove = null;
  canvas.onmouseup = null;
  canvas.onmouseleave = null;
  canvas.onkeydown = null;
  canvas.onkeyup = null;
  
  canvas.style.cursor = 'grab';
  canvas.tabIndex = 0; // Make canvas focusable
  
  // Add click to focus for keyboard controls
  canvas.addEventListener('click', function(e) {
    canvas.focus();
    canvasViewFocused = true;
  });
  
  canvas.addEventListener('focus', function(e) {
    canvasViewFocused = true;
    // Save original state when focusing
    const ctx = canvas.getContext('2d');
    canvasViewOriginalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  });
  
  canvas.addEventListener('blur', function(e) {
    canvasViewFocused = false;
    canvasViewOriginalImageData = null;
    canvasViewKeyPressed.clear();
    if(canvasViewKeyInterval) {
      clearInterval(canvasViewKeyInterval);
      canvasViewKeyInterval = null;
    }
  });
  
  // Keyboard arrow controls
  canvas.addEventListener('keydown', function(e) {
    if(!canvasViewFocused) return;
    
    if(['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      e.preventDefault();
      
      // Only move if this key wasn't already pressed (prevents repeat events)
      if(!canvasViewKeyPressed.has(e.key)) {
        canvasViewKeyPressed.add(e.key);
        moveCanvasWithKeys(); // Move once per key press
      }
    }
  });
  
  canvas.addEventListener('keyup', function(e) {
    if(['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      e.preventDefault();
      canvasViewKeyPressed.delete(e.key);
      
      // If no more arrow keys pressed, do final redraw with selection highlight
      if(canvasViewKeyPressed.size === 0) {
        // Debounce the redraw - only redraw after 300ms of no key presses
        if(canvasViewRedrawTimeout) {
          clearTimeout(canvasViewRedrawTimeout);
        }
        canvasViewRedrawTimeout = setTimeout(function() {
          showCanvasView();
          // Re-draw selection highlight if there's a selected screen
          if(selectedCanvasScreenId) {
            drawSelectionHighlight();
          }
        }, 300);
      }
    }
  });
  
  function moveCanvasWithKeys() {
    if(canvasViewKeyPressed.size === 0) return;
    
    // Determine which screen to move: selected screen or current screen
    const screenToMove = selectedCanvasScreenId || currentScreenId;
    if(!screenToMove || !screens[screenToMove]) return;
    
    // Get increment value directly - this is the exact pixel amount to move
    const increment = parseInt(document.getElementById('arrowKeyIncrement').value) || 10;
    
    // Get current position from the screen data
    let currentX = screens[screenToMove].data.canvasX || 0;
    let currentY = screens[screenToMove].data.canvasY || 0;
    
    // Apply movement for each pressed key
    if(canvasViewKeyPressed.has('ArrowLeft')) {
      currentX -= increment;
    }
    if(canvasViewKeyPressed.has('ArrowRight')) {
      currentX += increment;
    }
    if(canvasViewKeyPressed.has('ArrowUp')) {
      currentY -= increment;
    }
    if(canvasViewKeyPressed.has('ArrowDown')) {
      currentY += increment;
    }
    
    // Update the screen's position
    screens[screenToMove].data.canvasX = currentX;
    screens[screenToMove].data.canvasY = currentY;
    
    // Update the input values
    document.getElementById('canvasX').value = currentX;
    document.getElementById('canvasY').value = currentY;
    
    // If moving current screen, also update global variables
    if(screenToMove === currentScreenId) {
      canvasOffsetX = currentX;
      canvasOffsetY = currentY;
    }
    
    // Save state after moving
    saveCanvasMoveState();
    
    // Redraw the canvas to show updated position
    showCanvasView();
    
    // Re-draw selection highlight if there's a selected screen
    if(selectedCanvasScreenId) {
      drawSelectionHighlight();
    }
  }
  
  function drawCanvasPreviewWithGuides(newOffsetX, newOffsetY, snapMode) {
    if(!draggedScreenId || !screens[draggedScreenId]) return;
    
    const screen = screens[draggedScreenId];
    const screenData = screen.data;
    const panelType = screenData.panelType || 'CB5_MKII';
    const p = panels[panelType];
    if(!p || !p.res_x || !p.res_y) return;
    
    const pw = screenData.panelsWide || 0;
    const ph = screenData.panelsHigh || 0;
    
    // Check if CB5 half panel row is enabled for this screen
    const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';
    
    // Calculate wall resolution accounting for CB5 half panels
    let wallResX, wallResY;
    if(hasCB5HalfRow) {
      const halfPanel = panels['CB5_MKII_HALF'];
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y + halfPanel.res_y;
    } else {
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y;
    }
    
    const pixelWidth = p.res_x;
    const pixelHeight = p.res_y;
    const ctx = canvas.getContext('2d');
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    
    // Restore original image
    if(canvasViewOriginalImageData) {
      ctx.putImageData(canvasViewOriginalImageData, 0, 0);
    }
    
    // Draw snap guide lines if in markers mode - YELLOW and THICKER
    if(snapMode === 'markers') {
      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 4]);
      
      // Vertical guide lines - edges (0, 1) and center (1/2)
      const xPositions = [0, 1/2, 1];
      xPositions.forEach(ratio => {
        const x = canvasWidth * ratio;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvasHeight);
        ctx.stroke();
      });
      
      // Horizontal guide lines - edges (0, 1) and center (1/2)
      const yPositions = [0, 1/2, 1];
      yPositions.forEach(ratio => {
        const y = canvasHeight * ratio;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvasWidth, y);
        ctx.stroke();
      });
      
      ctx.setLineDash([]);
    }
    
    // Draw wall preview outline (solid green, THICKER)
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 5;
    ctx.setLineDash([]);
    ctx.strokeRect(newOffsetX, newOffsetY, wallResX, wallResY);
    
    // Draw X pattern across the wall
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 3;
    ctx.beginPath();
    // Top-left to bottom-right
    ctx.moveTo(newOffsetX, newOffsetY);
    ctx.lineTo(newOffsetX + wallResX, newOffsetY + wallResY);
    // Top-right to bottom-left
    ctx.moveTo(newOffsetX + wallResX, newOffsetY);
    ctx.lineTo(newOffsetX, newOffsetY + wallResY);
    ctx.stroke();
    
    // Draw corner panels (one panel at each corner)
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 3;
    
    // Top-left panel
    if(newOffsetX + pixelWidth > 0 && newOffsetY + pixelHeight > 0) {
      ctx.strokeRect(newOffsetX, newOffsetY, pixelWidth, pixelHeight);
    }
    
    // Top-right panel
    if(newOffsetX + wallResX - pixelWidth < canvasWidth && newOffsetY + pixelHeight > 0) {
      ctx.strokeRect(newOffsetX + wallResX - pixelWidth, newOffsetY, pixelWidth, pixelHeight);
    }
    
    // Bottom-left panel
    if(newOffsetX + pixelWidth > 0 && newOffsetY + wallResY - pixelHeight < canvasHeight) {
      ctx.strokeRect(newOffsetX, newOffsetY + wallResY - pixelHeight, pixelWidth, pixelHeight);
    }
    
    // Bottom-right panel
    if(newOffsetX + wallResX - pixelWidth < canvasWidth && newOffsetY + wallResY - pixelHeight < canvasHeight) {
      ctx.strokeRect(newOffsetX + wallResX - pixelWidth, newOffsetY + wallResY - pixelHeight, pixelWidth, pixelHeight);
    }
    
    // Draw center lines through the wall (yellow)
    const centerX = newOffsetX + wallResX / 2;
    const centerY = newOffsetY + wallResY / 2;
    
    ctx.strokeStyle = '#FFFF00';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 3]);
    
    // Vertical center line
    ctx.beginPath();
    ctx.moveTo(centerX, newOffsetY);
    ctx.lineTo(centerX, newOffsetY + wallResY);
    ctx.stroke();
    
    // Horizontal center line
    ctx.beginPath();
    ctx.moveTo(newOffsetX, centerY);
    ctx.lineTo(newOffsetX + wallResX, centerY);
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // Draw center crosshair for markers mode
    if(snapMode === 'markers') {
      if(centerX >= 0 && centerX <= canvasWidth && centerY >= 0 && centerY <= canvasHeight) {
        ctx.strokeStyle = '#FFFF00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }
  
  canvas.addEventListener('mousedown', function(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;
    
    // Detect which screen was clicked
    const clickedScreenId = getScreenAtPosition(mouseX, mouseY);
    
    if(clickedScreenId) {
      const screen = screens[clickedScreenId];
      const offsetX = screen.data.canvasX || 0;
      const offsetY = screen.data.canvasY || 0;
      
      // Set as selected screen IMMEDIATELY
      selectedCanvasScreenId = clickedScreenId;
      
      // Update X/Y input boxes to show selected screen's position
      document.getElementById('canvasX').value = offsetX;
      document.getElementById('canvasY').value = offsetY;
      
      draggedScreenId = clickedScreenId;
      canvasViewDragging = true;
      canvasViewDragStartX = mouseX;
      canvasViewDragStartY = mouseY;
      canvasViewStartOffsetX = offsetX;
      canvasViewStartOffsetY = offsetY;
      
      // Focus the canvas
      canvas.focus();
      
      // Use cached canvas image for instant highlight (no full redraw)
      const ctx = canvas.getContext('2d');
      if(cachedCanvasImageData) {
        ctx.putImageData(cachedCanvasImageData, 0, 0);
      }
      drawSelectionHighlight();
      
      // Save this state (with highlight) for drag preview
      canvasViewOriginalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      canvas.style.cursor = 'grabbing';
      e.preventDefault();
    } else {
      // Clicked on empty area - deselect
      if(selectedCanvasScreenId) {
        selectedCanvasScreenId = null;
        // Restore cached image without highlight
        const ctx = canvas.getContext('2d');
        if(cachedCanvasImageData) {
          ctx.putImageData(cachedCanvasImageData, 0, 0);
        }
      }
    }
  });
  
  canvas.addEventListener('mousemove', function(e) {
    if(!canvasViewDragging || !draggedScreenId) return;
    
    const screen = screens[draggedScreenId];
    if(!screen) return;
    
    const screenData = screen.data;
    const panelType = screenData.panelType || 'CB5_MKII';
    const p = panels[panelType];
    if(!p || !p.res_x || !p.res_y) return;
    
    const pw = screenData.panelsWide || 0;
    const ph = screenData.panelsHigh || 0;
    
    // Check if CB5 half panel row is enabled for this screen
    const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';
    
    // Calculate wall resolution accounting for CB5 half panels
    let wallResX, wallResY;
    if(hasCB5HalfRow) {
      const halfPanel = panels['CB5_MKII_HALF'];
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y + halfPanel.res_y;
    } else {
      wallResX = pw * p.res_x;
      wallResY = ph * p.res_y;
    }
    
    const pixelWidth = p.res_x;
    const pixelHeight = p.res_y;
    
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;
    
    const deltaX = mouseX - canvasViewDragStartX;
    const deltaY = mouseY - canvasViewDragStartY;
    
    let newOffsetX = canvasViewStartOffsetX + deltaX;
    let newOffsetY = canvasViewStartOffsetY + deltaY;
    
    // Get snap mode (checkbox)
    const snapEnabled = snapModeEnabled;
    const snapMode = snapEnabled ? 'markers' : 'none';
    const snapThreshold = 20; // Reduced from 30 to be less sticky
    
    if(snapMode === 'markers') {
      // Snap to canvas position markers - now snaps edges and center only
      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      
      // Calculate all wall positions
      const wallLeft = newOffsetX;
      const wallRight = newOffsetX + wallResX;
      const wallTop = newOffsetY;
      const wallBottom = newOffsetY + wallResY;
      const wallCenterX = newOffsetX + wallResX / 2;
      const wallCenterY = newOffsetY + wallResY / 2;
      
      // X-axis markers - center only
      const xMarkers = [
        canvasWidth / 2            // Center
      ];
      
      // X-axis edge markers (prioritized)
      const xEdgeMarkers = [
        0,                          // Left edge
        canvasWidth                 // Right edge
      ];
      
      // Y-axis markers - center only
      const yMarkers = [
        canvasHeight / 2           // Center
      ];
      
      // Y-axis edge markers (prioritized)
      const yEdgeMarkers = [
        0,                          // Top edge
        canvasHeight                // Bottom edge
      ];
      
      // Find best X snap (check left edge, right edge, and center)
      let bestXSnap = null;
      let minXDist = Infinity;
      
      // First check center marker
      xMarkers.forEach(marker => {
        // Check left edge
        const leftDist = Math.abs(wallLeft - marker);
        if(leftDist < minXDist && leftDist < snapThreshold) {
          minXDist = leftDist;
          bestXSnap = {marker: marker, edge: 'left'};
        }
        
        // Check right edge
        const rightDist = Math.abs(wallRight - marker);
        if(rightDist < minXDist && rightDist < snapThreshold) {
          minXDist = rightDist;
          bestXSnap = {marker: marker, edge: 'right'};
        }
        
        // Check center
        const centerDist = Math.abs(wallCenterX - marker);
        if(centerDist < minXDist && centerDist < snapThreshold) {
          minXDist = centerDist;
          bestXSnap = {marker: marker, edge: 'center'};
        }
      });
      
      // Then check edge markers with priority (they override fractional if within threshold)
      xEdgeMarkers.forEach(marker => {
        // Check left edge - prioritized
        const leftDist = Math.abs(wallLeft - marker);
        if(leftDist < snapThreshold) {
          if(!bestXSnap || leftDist <= minXDist) {
            minXDist = leftDist;
            bestXSnap = {marker: marker, edge: 'left', priority: true};
          }
        }
        
        // Check right edge - prioritized
        const rightDist = Math.abs(wallRight - marker);
        if(rightDist < snapThreshold) {
          if(!bestXSnap || rightDist <= minXDist) {
            minXDist = rightDist;
            bestXSnap = {marker: marker, edge: 'right', priority: true};
          }
        }
        
        // Check center
        const centerDist = Math.abs(wallCenterX - marker);
        if(centerDist < snapThreshold) {
          if(!bestXSnap || centerDist <= minXDist) {
            minXDist = centerDist;
            bestXSnap = {marker: marker, edge: 'center', priority: true};
          }
        }
      });
      
      // Apply X snap
      if(bestXSnap) {
        if(bestXSnap.edge === 'left') {
          newOffsetX = bestXSnap.marker;
        } else if(bestXSnap.edge === 'right') {
          newOffsetX = bestXSnap.marker - wallResX;
        } else if(bestXSnap.edge === 'center') {
          newOffsetX = bestXSnap.marker - wallResX / 2;
        }
      }
      
      // Find best Y snap (check top edge, bottom edge, and center)
      let bestYSnap = null;
      let minYDist = Infinity;
      
      // First check center marker
      yMarkers.forEach(marker => {
        // Check top edge
        const topDist = Math.abs(wallTop - marker);
        if(topDist < minYDist && topDist < snapThreshold) {
          minYDist = topDist;
          bestYSnap = {marker: marker, edge: 'top'};
        }
        
        // Check bottom edge
        const bottomDist = Math.abs(wallBottom - marker);
        if(bottomDist < minYDist && bottomDist < snapThreshold) {
          minYDist = bottomDist;
          bestYSnap = {marker: marker, edge: 'bottom'};
        }
        
        // Check center
        const centerDist = Math.abs(wallCenterY - marker);
        if(centerDist < minYDist && centerDist < snapThreshold) {
          minYDist = centerDist;
          bestYSnap = {marker: marker, edge: 'center'};
        }
      });
      
      // Then check edge markers with priority (they override fractional if within threshold)
      yEdgeMarkers.forEach(marker => {
        // Check top edge - prioritized
        const topDist = Math.abs(wallTop - marker);
        if(topDist < snapThreshold) {
          if(!bestYSnap || topDist <= minYDist) {
            minYDist = topDist;
            bestYSnap = {marker: marker, edge: 'top', priority: true};
          }
        }
        
        // Check bottom edge - prioritized
        const bottomDist = Math.abs(wallBottom - marker);
        if(bottomDist < snapThreshold) {
          if(!bestYSnap || bottomDist <= minYDist) {
            minYDist = bottomDist;
            bestYSnap = {marker: marker, edge: 'bottom', priority: true};
          }
        }
        
        // Check center
        const centerDist = Math.abs(wallCenterY - marker);
        if(centerDist < snapThreshold) {
          if(!bestYSnap || centerDist <= minYDist) {
            minYDist = centerDist;
            bestYSnap = {marker: marker, edge: 'center', priority: true};
          }
        }
      });
      
      // Apply Y snap
      if(bestYSnap) {
        if(bestYSnap.edge === 'top') {
          newOffsetY = bestYSnap.marker;
        } else if(bestYSnap.edge === 'bottom') {
          newOffsetY = bestYSnap.marker - wallResY;
        } else if(bestYSnap.edge === 'center') {
          newOffsetY = bestYSnap.marker - wallResY / 2;
        }
      }
    }
    
    // Screen-to-screen snapping - snap to other visible screens' edges
    if(snapEnabled) {
      const screenSnapThreshold = 25; // Pixels threshold for screen snapping
      
      // Calculate current wall bounds
      const wallLeft = newOffsetX;
      const wallRight = newOffsetX + wallResX;
      const wallTop = newOffsetY;
      const wallBottom = newOffsetY + wallResY;
      
      let bestScreenXSnap = null;
      let minScreenXDist = Infinity;
      let bestScreenYSnap = null;
      let minScreenYDist = Infinity;
      
      // Check against all other visible screens
      Object.keys(screens).forEach(otherScreenId => {
        if(otherScreenId === draggedScreenId) return; // Skip self
        
        const otherScreen = screens[otherScreenId];
        if(!otherScreen.visible) return; // Skip invisible screens
        
        const otherData = otherScreen.data;
        const otherPanelType = otherData.panelType || 'CB5_MKII';
        const otherPanel = panels[otherPanelType];
        
        if(!otherPanel || !otherPanel.res_x || !otherPanel.res_y) return;
        
        const otherPw = otherData.panelsWide || 0;
        const otherPh = otherData.panelsHigh || 0;
        
        if(otherPw === 0 || otherPh === 0) return;
        
        // Check if other screen has CB5 half panel row
        const otherHasCB5HalfRow = otherData.addCB5HalfRow && otherPanelType === 'CB5_MKII';
        
        let otherWallResX, otherWallResY;
        if(otherHasCB5HalfRow) {
          const halfPanel = panels['CB5_MKII_HALF'];
          otherWallResX = otherPw * otherPanel.res_x;
          otherWallResY = otherPh * otherPanel.res_y + halfPanel.res_y;
        } else {
          otherWallResX = otherPw * otherPanel.res_x;
          otherWallResY = otherPh * otherPanel.res_y;
        }
        
        const otherLeft = otherData.canvasX || 0;
        const otherRight = otherLeft + otherWallResX;
        const otherTop = otherData.canvasY || 0;
        const otherBottom = otherTop + otherWallResY;
        
        // X-axis snapping: check if walls are vertically overlapping (or close)
        const verticalOverlap = !(wallBottom < otherTop - 50 || wallTop > otherBottom + 50);
        
        if(verticalOverlap) {
          // Snap dragged wall's right edge to other wall's left edge
          const rightToLeftDist = Math.abs(wallRight - otherLeft);
          if(rightToLeftDist < minScreenXDist && rightToLeftDist < screenSnapThreshold) {
            minScreenXDist = rightToLeftDist;
            bestScreenXSnap = { target: otherLeft, edge: 'right' };
          }
          
          // Snap dragged wall's left edge to other wall's right edge
          const leftToRightDist = Math.abs(wallLeft - otherRight);
          if(leftToRightDist < minScreenXDist && leftToRightDist < screenSnapThreshold) {
            minScreenXDist = leftToRightDist;
            bestScreenXSnap = { target: otherRight, edge: 'left' };
          }
          
          // Snap left edges together
          const leftToLeftDist = Math.abs(wallLeft - otherLeft);
          if(leftToLeftDist < minScreenXDist && leftToLeftDist < screenSnapThreshold) {
            minScreenXDist = leftToLeftDist;
            bestScreenXSnap = { target: otherLeft, edge: 'left' };
          }
          
          // Snap right edges together
          const rightToRightDist = Math.abs(wallRight - otherRight);
          if(rightToRightDist < minScreenXDist && rightToRightDist < screenSnapThreshold) {
            minScreenXDist = rightToRightDist;
            bestScreenXSnap = { target: otherRight, edge: 'right' };
          }
        }
        
        // Y-axis snapping: check if walls are horizontally overlapping (or close)
        const horizontalOverlap = !(wallRight < otherLeft - 50 || wallLeft > otherRight + 50);
        
        if(horizontalOverlap) {
          // Snap dragged wall's bottom edge to other wall's top edge
          const bottomToTopDist = Math.abs(wallBottom - otherTop);
          if(bottomToTopDist < minScreenYDist && bottomToTopDist < screenSnapThreshold) {
            minScreenYDist = bottomToTopDist;
            bestScreenYSnap = { target: otherTop, edge: 'bottom' };
          }
          
          // Snap dragged wall's top edge to other wall's bottom edge
          const topToBottomDist = Math.abs(wallTop - otherBottom);
          if(topToBottomDist < minScreenYDist && topToBottomDist < screenSnapThreshold) {
            minScreenYDist = topToBottomDist;
            bestScreenYSnap = { target: otherBottom, edge: 'top' };
          }
          
          // Snap top edges together
          const topToTopDist = Math.abs(wallTop - otherTop);
          if(topToTopDist < minScreenYDist && topToTopDist < screenSnapThreshold) {
            minScreenYDist = topToTopDist;
            bestScreenYSnap = { target: otherTop, edge: 'top' };
          }
          
          // Snap bottom edges together
          const bottomToBottomDist = Math.abs(wallBottom - otherBottom);
          if(bottomToBottomDist < minScreenYDist && bottomToBottomDist < screenSnapThreshold) {
            minScreenYDist = bottomToBottomDist;
            bestScreenYSnap = { target: otherBottom, edge: 'bottom' };
          }
        }
      });
      
      // Apply screen X snap (prioritize screen snapping over canvas markers)
      if(bestScreenXSnap) {
        if(bestScreenXSnap.edge === 'left') {
          newOffsetX = bestScreenXSnap.target;
        } else if(bestScreenXSnap.edge === 'right') {
          newOffsetX = bestScreenXSnap.target - wallResX;
        }
      }
      
      // Apply screen Y snap
      if(bestScreenYSnap) {
        if(bestScreenYSnap.edge === 'top') {
          newOffsetY = bestScreenYSnap.target;
        } else if(bestScreenYSnap.edge === 'bottom') {
          newOffsetY = bestScreenYSnap.target - wallResY;
        }
      }
    }
    
    // Update the dragged screen's canvas position
    if(draggedScreenId && screens[draggedScreenId]) {
      screens[draggedScreenId].data.canvasX = Math.round(newOffsetX);
      screens[draggedScreenId].data.canvasY = Math.round(newOffsetY);
      
      // If this is the current screen, also update global variables
      if(draggedScreenId === currentScreenId) {
        canvasOffsetX = Math.round(newOffsetX);
        canvasOffsetY = Math.round(newOffsetY);
      }
      
      // Always update the X/Y input fields for the selected/dragged screen
      document.getElementById('canvasX').value = Math.round(newOffsetX);
      document.getElementById('canvasY').value = Math.round(newOffsetY);
    }
    
    // Draw preview with snap guides
    drawCanvasPreviewWithGuides(newOffsetX, newOffsetY, snapMode);
  });
  
  canvas.addEventListener('mouseup', function(e) {
    if(canvasViewDragging) {
      const wasDraggingCurrentScreen = (draggedScreenId === currentScreenId);
      
      canvasViewDragging = false;
      draggedScreenId = null;
      canvas.style.cursor = 'grab';
      canvasViewOriginalImageData = null;
      
      // Only save current screen data if we weren't dragging the current screen
      // (to avoid overwriting the position we just set during drag)
      if(!wasDraggingCurrentScreen) {
        saveCurrentScreenData();
      }
      
      // Full redraw with actual content
      showCanvasView();
      
      // Re-draw selection highlight if there's a selected screen
      if(selectedCanvasScreenId) {
        drawSelectionHighlight();
      }
      
      // Save state after drag completes
      saveCanvasMoveState();
    }
  });
  
  canvas.addEventListener('mouseleave', function(e) {
    if(canvasViewDragging) {
      const wasDraggingCurrentScreen = (draggedScreenId === currentScreenId);
      
      canvasViewDragging = false;
      draggedScreenId = null;
      canvas.style.cursor = 'grab';
      canvasViewOriginalImageData = null;
      
      // Only save current screen data if we weren't dragging the current screen
      if(!wasDraggingCurrentScreen) {
        saveCurrentScreenData();
      }
      
      // Full redraw with actual content
      showCanvasView();
      
      // Re-draw selection highlight if there's a selected screen
      if(selectedCanvasScreenId) {
        drawSelectionHighlight();
      }
      
      // Save state after drag completes
      saveCanvasMoveState();
    }
  });
}

// Canvas Zoom Functions
function zoomCanvas(delta) {
  const oldZoom = canvasZoomLevel;
  canvasZoomLevel = Math.max(0.5, Math.min(5.0, canvasZoomLevel + delta));
  
  if(canvasZoomLevel !== oldZoom) {
    // Constrain pan when zooming out
    constrainCanvasPan();
    updateCanvasViewport();
    
    // Re-draw selection highlight if there's a selected screen
    if(selectedCanvasScreenId) {
      drawSelectionHighlight();
    }
  }
}

function setCanvasZoom(percent) {
  const value = parseFloat(percent);
  if(isNaN(value)) return;
  
  canvasZoomLevel = Math.max(0.5, Math.min(5.0, value / 100));
  constrainCanvasPan();
  updateCanvasViewport();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
}

function resetCanvasZoom() {
  canvasZoomLevel = 1.0;
  canvasPanX = 0;
  canvasPanY = 0;
  updateCanvasViewport();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
}

function updateCanvasViewport() {
  const viewport = document.getElementById('canvasViewport');
  const zoomInput = document.getElementById('canvasZoomInput');
  
  if(viewport) {
    // First reset to identity transform to clear any stale state
    viewport.style.transform = 'none';
    void viewport.offsetHeight; // Force reflow
    
    // Now apply the actual transform
    viewport.style.transform = `translate(${canvasPanX}px, ${canvasPanY}px) scale(${canvasZoomLevel})`;
    void viewport.offsetHeight; // Force reflow again
  }
  
  if(zoomInput) {
    zoomInput.value = Math.round(canvasZoomLevel * 100);
  }
}

function constrainCanvasPan() {
  const canvas = document.getElementById('canvasView');
  const wrapper = document.getElementById('canvasViewWrapper');
  if(!canvas || !wrapper) return;
  
  const wrapperWidth = 800;
  const wrapperHeight = 450;
  
  // Get canvas display size
  const canvasWidth = parseFloat(canvas.style.width) || wrapperWidth;
  const canvasHeight = parseFloat(canvas.style.height) || wrapperHeight;
  
  // Calculate scaled size
  const scaledWidth = canvasWidth * canvasZoomLevel;
  const scaledHeight = canvasHeight * canvasZoomLevel;
  
  // Calculate pan limits
  const minPanX = Math.min(0, wrapperWidth - scaledWidth);
  const minPanY = Math.min(0, wrapperHeight - scaledHeight);
  const maxPanX = 0;
  const maxPanY = 0;
  
  // Constrain pan
  canvasPanX = Math.max(minPanX, Math.min(maxPanX, canvasPanX));
  canvasPanY = Math.max(minPanY, Math.min(maxPanY, canvasPanY));
}

// Add mouse wheel zoom support
function initCanvasWheelZoom() {
  const wrapper = document.getElementById('canvasViewWrapper');
  if(!wrapper) return;
  
  wrapper.addEventListener('wheel', function(e) {
    // Only zoom if Ctrl key is held, otherwise allow normal scroll
    if(e.ctrlKey) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.25 : 0.25;
      zoomCanvas(delta);
    }
  }, { passive: false });
}

// Initialize canvas panning
function initCanvasPanning() {
  const wrapper = document.getElementById('canvasViewWrapper');
  const viewport = document.getElementById('canvasViewport');
  if(!wrapper || !viewport) return;
  
  wrapper.addEventListener('mousedown', function(e) {
    // Only pan if zoomed in and not dragging a screen
    if(canvasZoomLevel > 1 && !canvasViewDragging) {
      // Check if we clicked on a screen (let screen dragging take priority)
      const canvas = document.getElementById('canvasView');
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const mouseX = (e.clientX - rect.left) * scaleX;
      const mouseY = (e.clientY - rect.top) * scaleY;
      
      // Check if mouse is over any screen
      let overScreen = false;
      Object.keys(screens).forEach(screenId => {
        const screen = screens[screenId];
        if(!screen.visible) return;
        const screenData = screen.data;
        const p = panels[screenData.panelType || 'CB5_MKII'];
        if(!p) return;
        
        const pw = screenData.panelsWide || 0;
        const ph = screenData.panelsHigh || 0;
        const canvasX = screenData.canvasX || 0;
        const canvasY = screenData.canvasY || 0;
        
        let wallResX = pw * p.res_x;
        let wallResY = ph * p.res_y;
        if(screenData.addCB5HalfRow && screenData.panelType === 'CB5_MKII') {
          wallResY += panels['CB5_MKII_HALF'].res_y;
        }
        
        if(mouseX >= canvasX && mouseX <= canvasX + wallResX &&
           mouseY >= canvasY && mouseY <= canvasY + wallResY) {
          overScreen = true;
        }
      });
      
      if(!overScreen) {
        isPanningCanvas = true;
        panStartX = e.clientX - canvasPanX;
        panStartY = e.clientY - canvasPanY;
        viewport.style.cursor = 'grabbing';
        e.preventDefault();
      }
    }
  });
  
  document.addEventListener('mousemove', function(e) {
    if(isPanningCanvas) {
      canvasPanX = e.clientX - panStartX;
      canvasPanY = e.clientY - panStartY;
      constrainCanvasPan();
      updateCanvasViewport();
    }
  });
  
  document.addEventListener('mouseup', function(e) {
    if(isPanningCanvas) {
      isPanningCanvas = false;
      viewport.style.cursor = 'grab';
    }
  });
}

function exportPDF(){
  try {
    // Save current screen data first to ensure all toggle states are persisted
    saveCurrentScreenData();
    
    if(!window.jspdf || !window.html2canvas){
      alert('PDF export libraries not loaded. Please check your internet connection and refresh the page.');
      return;
    }
    
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 10;
    let yOffset = margin;
    
    // Save current screen so we can restore it later
    const originalScreenId = currentScreenId;
    
    // Create and show loading overlay to hide screen switching
    const overlay = document.createElement('div');
    overlay.id = 'pdfExportOverlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(26, 26, 26, 1.0);
      z-index: 10000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif;
    `;
    overlay.innerHTML = `
      <div style="font-size: 24px; margin-bottom: 20px;">Generating PDF...</div>
      <div id="pdfProgress" style="font-size: 16px; color: #888;">Preparing...</div>
      <div style="width: 200px; height: 4px; background: #333; border-radius: 2px; margin-top: 20px; overflow: hidden;">
        <div id="pdfProgressBar" style="width: 0%; height: 100%; background: #4CAF50; transition: width 0.3s;"></div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    function updateProgress(text, percent) {
      const progressText = document.getElementById('pdfProgress');
      const progressBar = document.getElementById('pdfProgressBar');
      if(progressText) progressText.textContent = text;
      if(progressBar) progressBar.style.width = percent + '%';
    }
    
    function removeOverlay() {
      const overlay = document.getElementById('pdfExportOverlay');
      if(overlay) overlay.remove();
    }
    
    function checkPageBreak(heightNeeded) {
      if (yOffset + heightNeeded > pageHeight - margin) {
        pdf.addPage();
        yOffset = margin;
        return true;
      }
      return false;
    }
    
    // Title page
    pdf.setFontSize(16);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(0, 0, 0);
    pdf.text('LED Wall Calculator Report', margin, yOffset);
    
    // Add timestamp to the right of the title
    pdf.setFontSize(9);
    pdf.setFont(undefined, 'normal');
    pdf.setTextColor(100, 100, 100);
    const timestamp = new Date().toLocaleString();
    const timestampText = `Generated: ${timestamp}`;
    const timestampWidth = pdf.getTextWidth(timestampText);
    pdf.text(timestampText, pageWidth - margin - timestampWidth, yOffset);
    yOffset += 10;
    
    // Get all screen IDs sorted
    const screenIds = Object.keys(screens).sort((a, b) => {
      const numA = parseInt(a.split('_')[1]);
      const numB = parseInt(b.split('_')[1]);
      return numA - numB;
    });
    
    // ========== CALCULATE PROCESSOR GROUPS ACROSS ALL SCREENS ==========
    // Group screens by processor type and calculate combined totals
    const processorGroups = {}; // { processorType: { screens: [], totalMainPorts: 0, hasAnyRedundancy: false, firstScreenId: null } }
    
    screenIds.forEach(screenId => {
      const screen = screens[screenId];
      if(!screen || !screen.data) return;
      
      const processorType = screen.data.processor || 'Brompton_SX40';
      const calcData = screen.calculatedData || {};
      const dataLines = calcData.dataLines || 0;
      const hasRedundancy = screen.data.redundancy || false;
      const hasProcessorRedundancy = screen.data.processorRedundancy || false;
      
      if(!processorGroups[processorType]) {
        processorGroups[processorType] = {
          screens: [],
          totalMainPorts: 0,
          hasAnyRedundancy: false,
          hasAnyProcessorRedundancy: false,
          firstScreenId: screenId,
          firstScreenName: screen.name
        };
      }
      
      processorGroups[processorType].screens.push({
        screenId: screenId,
        screenName: screen.name,
        mainPorts: dataLines,
        hasRedundancy: hasRedundancy
      });
      processorGroups[processorType].totalMainPorts += dataLines;
      if(hasRedundancy) {
        processorGroups[processorType].hasAnyRedundancy = true;
      }
      if(hasProcessorRedundancy) {
        processorGroups[processorType].hasAnyProcessorRedundancy = true;
      }
    });
    
    // Calculate processor and distribution box counts for each group
    // IMPORTANT: For redundancy, we double the distribution box count (not the port count)
    // because each XD/distro box is dedicated to either main OR backup - can't mix
    // For processor redundancy, we double the processor count at the end
    Object.keys(processorGroups).forEach(processorType => {
      const group = processorGroups[processorType];
      const totalMainPorts = group.totalMainPorts;
      const hasRedundancy = group.hasAnyRedundancy;
      const hasProcessorRedundancy = group.hasAnyProcessorRedundancy;
      
      let processorCount = 0;
      let distBoxCount = 0;
      let distBoxName = '';
      
      if(processorType === 'Brompton_SX40') {
        // SX40: Each XD has 10 ports, each SX40 supports 4 XDs
        // Calculate XDs needed for main lines first
        const mainXDs = totalMainPorts > 0 ? Math.ceil(totalMainPorts / 10) : 0;
        // If redundancy, double the XD count (separate XDs for backup)
        distBoxCount = hasRedundancy ? mainXDs * 2 : mainXDs;
        processorCount = distBoxCount > 0 ? Math.ceil(distBoxCount / 4) : 0;
        distBoxName = 'XD';
      } else if(processorType === 'Brompton_S8') {
        // S8: 8 ports per processor
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        processorCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 8) : 0;
        distBoxCount = 0;
      } else if(processorType === 'Brompton_M2') {
        // M2: 4 ports per processor
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        processorCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 4) : 0;
        distBoxCount = 0;
      } else if(processorType === 'Brompton_S4') {
        // S4: 4 ports per processor
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        processorCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 4) : 0;
        distBoxCount = 0;
      } else if(processorType === 'NovaStar_MX40_Pro') {
        // MX40 Pro: 20 ports per processor, uses CVT distribution
        const mainCVTs = totalMainPorts > 0 ? Math.ceil(totalMainPorts / 10) : 0;
        distBoxCount = hasRedundancy ? mainCVTs * 2 : mainCVTs;
        processorCount = distBoxCount > 0 ? Math.ceil(distBoxCount / 2) : 0;
        distBoxName = 'CVT';
      } else {
        // Default/custom processor - use per-screen calculation
        const totalPortsNeeded = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
        processorCount = totalPortsNeeded > 0 ? Math.ceil(totalPortsNeeded / 8) : group.screens.length;
        distBoxCount = 0;
      }
      
      // If processor redundancy is enabled, double the processor count
      if(hasProcessorRedundancy && processorCount > 0) {
        processorCount *= 2;
      }
      
      group.processorCount = processorCount;
      group.distBoxCount = distBoxCount;
      group.distBoxName = distBoxName;
      // Store for display purposes
      group.totalPorts = hasRedundancy ? totalMainPorts * 2 : totalMainPorts;
    });
    
    console.log('Processor groups calculated:', processorGroups);
    
    // Add summary of all screens (count only, no names)
    pdf.setFontSize(10);
    pdf.setFont(undefined, 'bold');
    pdf.setTextColor(0, 0, 0);
    pdf.text(`Total Screens: ${screenIds.length}`, margin, yOffset);
    yOffset += 10;
    
    // Process each screen
    let screenIndex = 0;
    
    function processNextScreen() {
      if(screenIndex >= screenIds.length) {
        // All screens processed, now add canvas view as last page
        addCanvasViewPage();
        return;
      }
      
      const screenId = screenIds[screenIndex];
      const screen = screens[screenId];
      
      updateProgress(`Processing screen ${screenIndex + 1} of ${screenIds.length}: ${screen.name}`, 
        Math.round((screenIndex / screenIds.length) * 80));
      
      // Switch to this screen to load its data
      switchToScreen(screenId);
      
      // Wait for calculate to complete, then capture
      setTimeout(() => {
        // Add page break before each screen (except first)
        if(screenIndex > 0) {
          pdf.addPage();
          yOffset = margin;
        }
        
        // Screen header (matches gear list title style)
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.setTextColor(0, 0, 0);
        pdf.text(`Screen ${screenIndex + 1}: ${screen.name}`, margin, yOffset);
        yOffset += 10;
        
        // Output results as text directly (no html2canvas)
        const resultsEl = document.getElementById('results');
        if(resultsEl && resultsEl.innerText && resultsEl.innerText.trim() !== '') {
          // Get text content from the results div
          const resultsText = resultsEl.innerText;
          const lines = resultsText.split('\n');
          
          pdf.setFontSize(9);
          pdf.setTextColor(0, 0, 0);
          
          lines.forEach(line => {
            const trimmedLine = line.trim();
            if(!trimmedLine) {
              yOffset += 2; // Small gap for empty lines
              return;
            }
            
            // Check for section titles (underlined in original)
            if(trimmedLine === 'WALL' || trimmedLine === 'POWER (MAX)' || trimmedLine === 'POWER (AVG)' || trimmedLine === 'DATA') {
              checkPageBreak(8);
              yOffset += 2;
              pdf.setFontSize(10);
              pdf.setFont(undefined, 'bold');
              pdf.text(trimmedLine, margin, yOffset);
              // Draw underline
              const textWidth = pdf.getTextWidth(trimmedLine);
              pdf.line(margin, yOffset + 1, margin + textWidth, yOffset + 1);
              pdf.setFont(undefined, 'normal');
              pdf.setFontSize(9);
              yOffset += 5;
            } else {
              checkPageBreak(5);
              // Split line at colon to bold the label
              const colonIndex = trimmedLine.indexOf(':');
              if(colonIndex > 0) {
                const label = trimmedLine.substring(0, colonIndex + 1);
                const value = trimmedLine.substring(colonIndex + 1);
                pdf.setFont(undefined, 'normal');
                pdf.text(label, margin, yOffset);
                const labelWidth = pdf.getTextWidth(label);
                pdf.text(value, margin + labelWidth, yOffset);
              } else {
                pdf.text(trimmedLine, margin, yOffset);
              }
              yOffset += 4;
            }
          });
          
          yOffset += 6;
        }
        
        // Add layout views for this screen
        addScreenLayouts(screenId, screen.name);
      }, 50);
    }
    
    function addScreenLayouts(screenId, screenName) {
      // Structure View will be on its own page, so exclude from main layouts
      const layouts = [
        { containerId: 'standardContainer', canvasId: 'standardCanvas', title: 'Standard Layout' },
        { containerId: 'powerContainer', canvasId: 'powerCanvas', title: 'Power Layout' },
        { containerId: 'dataContainer', canvasId: 'dataCanvas', title: 'Data Layout' }
      ];
      
      let layoutIndex = 0;
      
      function addNextLayout() {
        if(layoutIndex >= layouts.length) {
          // All main layouts done, now add Structure View page
          addStructureViewPage(screenId, screenName, function() {
            // After structure view, add gear list page
            addGearListPage(screenId, screenName, processorGroups, function() {
              // After gear list, move to next screen
              screenIndex++;
              processNextScreen();
            });
          });
          return;
        }
        
        const layout = layouts[layoutIndex];
        const container = document.getElementById(layout.containerId);
        const canvas = document.getElementById(layout.canvasId);
        
        if(container && container.style.display !== 'none' && canvas && canvas.width > 0) {
          const canvasImg = canvas.toDataURL('image/png');
          
          // Fixed WIDTH for all layouts, height scales proportionally
          const fixedWidth = 114; // mm - same width for all layouts
          const maxHeight = 70;   // mm - maximum height cap
          
          // Calculate height maintaining aspect ratio
          const aspectRatio = canvas.height / canvas.width;
          let imgWidth = fixedWidth;
          let imgHeight = fixedWidth * aspectRatio;
          
          // Cap height if too tall (for very vertical layouts)
          if(imgHeight > maxHeight) {
            imgHeight = maxHeight;
            imgWidth = maxHeight / aspectRatio;
          }
          
          // Check if we need a new page
          const neededHeight = imgHeight + 14;
          if(yOffset + neededHeight > pageHeight - margin) {
            pdf.addPage();
            yOffset = margin;
          }
          
          // Add layout title
          pdf.setFontSize(11);
          pdf.setTextColor(0, 0, 0);
          pdf.text(layout.title, margin, yOffset);
          yOffset += 6;
          
          // Add layout image - width is consistent, height varies by aspect ratio
          pdf.addImage(canvasImg, 'PNG', margin, yOffset, imgWidth, imgHeight);
          yOffset += imgHeight + 4;
          
          yOffset += 4;
        }
        
        layoutIndex++;
        setTimeout(addNextLayout, 10);
      }
      
      addNextLayout();
    }
    
    // Add dedicated Structure View page
    function addStructureViewPage(screenId, screenName, callback) {
      const container = document.getElementById('structureContainer');
      const canvas = document.getElementById('structureCanvas');
      
      if(!container || container.style.display === 'none' || !canvas || canvas.width === 0) {
        // No structure view, skip to callback
        if(callback) setTimeout(callback, 10);
        return;
      }
      
      try {
        // Start new page for Structure View
        pdf.addPage();
        yOffset = margin;
        
        // Page title
        pdf.setFontSize(14);
        pdf.setFont(undefined, 'bold');
        pdf.setTextColor(0, 0, 0);
        pdf.text('Structure View', margin, yOffset);
        yOffset += 8;
        
        // Add structure canvas image
        const canvasImg = canvas.toDataURL('image/png');
        const fixedWidth = 160; // Wider for structure view page
        const maxHeight = 80;
        
        const aspectRatio = canvas.height / canvas.width;
        let imgWidth = fixedWidth;
        let imgHeight = fixedWidth * aspectRatio;
        
        if(imgHeight > maxHeight) {
          imgHeight = maxHeight;
          imgWidth = maxHeight / aspectRatio;
        }
        
        pdf.addImage(canvasImg, 'PNG', margin, yOffset, imgWidth, imgHeight);
        yOffset += imgHeight + 8;
        
        // Now add the structure info in a clean 2-column layout below
        const hasPickupWeights = bumpers.length > 0;
        const panelType = document.getElementById('panelType').value;
        const useConnectingPlates = shouldUseConnectingPlates(panelType);
        const platesBox = document.getElementById('structurePlatesBox');
        const hasConnectingPlates = useConnectingPlates && platesBox && platesBox.style.display !== 'none';
        const isGroundStacking = showBottomBumper;
        const {pw, ph} = getEffectivePanelCountsForLayout();
        
        // Column positions for structure info
        const col1X = margin;
        const col2X = margin + 95; // Second column starts 95mm from margin
        const colLabelX = 2;
        const colValueX = 48;
        
        let col1Y = yOffset;
        let col2Y = yOffset;
        
        const wtUnit = displayWeightUnit === 'lbs' ? 'lbs' : 'kg';
        
        // ========== COLUMN 1 ==========
        
        // Pickup Weights
        let pickupWeightKg = 0;
        if(hasPickupWeights) {
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'bold');
          pdf.text('Pickup Weights', col1X, col1Y);
          col1Y += 5;
          
          const topBumpers = bumpers.filter(b => b.position === 'top');
          const bottomBumpers = bumpers.filter(b => b.position === 'bottom');
          
          // Helper function to check if a 2W bumper is under a 4W bumper
          function is2wUnder4wPdf(bumper2w, position) {
            const fourWayBumpers = bumpers.filter(b => b.type === '4w' && b.position === position);
            for(const b4w of fourWayBumpers) {
              const col4wStart = b4w.startCol - 1;
              const col4wEnd = b4w.endCol;
              if(bumper2w.startCol >= col4wStart && bumper2w.endCol <= col4wEnd) {
                return true;
              }
            }
            return false;
          }
          
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          
          // Top bumpers (skip 2W under 4W)
          if(topBumpers.length > 0) {
            const sortedTop = [...topBumpers].sort((a, b) => {
              const order = { '4w': 0, '2w': 1, '1w': 2 };
              return order[a.type] - order[b.type];
            });
            const counts = { '4w': 0, '2w': 0, '1w': 0 };
            sortedTop.forEach((bumper) => {
              // Skip 2W bumpers under 4W bumpers
              if(bumper.type === '2w' && is2wUnder4wPdf(bumper, 'top')) {
                return;
              }
              counts[bumper.type]++;
              const weight = calculateBumperPickupWeight(bumper);
              pickupWeightKg += weight.kg;
              const label = bumper.type === '4w' ? '4W' : bumper.type === '2w' ? '2W' : '1W';
              const weightDisplay = displayWeightUnit === 'lbs' ? weight.lbs.toFixed(0) : weight.kg.toFixed(0);
              pdf.text(`${label} #${counts[bumper.type]}`, col1X + colLabelX, col1Y);
              pdf.text(`${weightDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            });
          }
          
          // Bottom bumpers (skip 2W under 4W)
          if(bottomBumpers.length > 0) {
            const sortedBottom = [...bottomBumpers].sort((a, b) => {
              const order = { '4w': 0, '2w': 1, '1w': 2 };
              return order[a.type] - order[b.type];
            });
            const counts = { '4w': 0, '2w': 0, '1w': 0 };
            sortedBottom.forEach((bumper) => {
              // Skip 2W bumpers under 4W bumpers
              if(bumper.type === '2w' && is2wUnder4wPdf(bumper, 'bottom')) {
                return;
              }
              counts[bumper.type]++;
              const weight = calculateBumperPickupWeight(bumper);
              pickupWeightKg += weight.kg;
              const label = bumper.type === '4w' ? '4W' : bumper.type === '2w' ? '2W' : '1W';
              const weightDisplay = displayWeightUnit === 'lbs' ? weight.lbs.toFixed(0) : weight.kg.toFixed(0);
              pdf.text(`${label} #${counts[bumper.type]}`, col1X + colLabelX, col1Y);
              pdf.text(`${weightDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            });
          }
          
          // Total line
          pdf.setDrawColor(100, 100, 100);
          pdf.line(col1X + colLabelX, col1Y, col1X + colValueX, col1Y);
          col1Y += 3;
          pdf.setFont(undefined, 'bold');
          pdf.text('Total', col1X + colLabelX, col1Y);
          const totalPickupDisplay = displayWeightUnit === 'lbs' ? (pickupWeightKg * KG_TO_LBS).toFixed(0) : pickupWeightKg.toFixed(0);
          pdf.text(`${totalPickupDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
          pdf.setFont(undefined, 'normal');
          col1Y += 6;
        }
        
        // Ground Support Hardware (in column 1, below pickup weights)
        let groundSupportWeightKg = 0;
        if(isGroundStacking && pw > 0 && ph > 0) {
          const hardware = calculateGroundSupportHardware(pw, ph);
          
          if(hardware.totalRearTruss > 0 || hardware.totalBridgeClamps > 0 || hardware.totalBaseTruss > 0) {
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Ground Support Hardware', col1X, col1Y);
            col1Y += 5;
            
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            
            if(hardware.totalRearTruss > 0) {
              pdf.text('Rear Truss', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalRearTruss.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalBaseTruss > 0) {
              pdf.text('Base Truss', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalBaseTruss.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalBridgeClamps > 0) {
              pdf.text('Bridge Clamps', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalBridgeClamps.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalRearBridgeClampAdapters > 0) {
              pdf.text('Rear Bridge Clamp Adapter', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalRearBridgeClampAdapters.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalPipes > 0) {
              const uniqueLengths = [...new Set(hardware.pipeInfo.map(p => p.pipeLengthFt))];
              const pipeLengthStr = uniqueLengths.map(l => l + 'ft').join(', ');
              pdf.text('Pipe (' + pipeLengthStr + ')', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalPipes.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalSwivelCheeseboroughs > 0) {
              pdf.text('Swivel Cheeseborough', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalSwivelCheeseboroughs.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            if(hardware.totalSandbags > 0) {
              pdf.text('Sandbags (50lb)', col1X + colLabelX, col1Y);
              pdf.text(hardware.totalSandbags.toString(), col1X + colValueX, col1Y, { align: 'right' });
              col1Y += 3.5;
            }
            
            // Total weight
            pdf.setDrawColor(100, 100, 100);
            pdf.line(col1X + colLabelX, col1Y, col1X + colValueX, col1Y);
            col1Y += 3;
            pdf.setFont(undefined, 'bold');
            pdf.text('Total Weight', col1X + colLabelX, col1Y);
            groundSupportWeightKg = hardware.totalWeightKg;
            const gsWeightDisplay = displayWeightUnit === 'lbs' ? hardware.totalWeightLbs.toFixed(1) : hardware.totalWeightKg.toFixed(1);
            pdf.text(`${gsWeightDisplay} ${wtUnit}`, col1X + colValueX, col1Y, { align: 'right' });
            pdf.setFont(undefined, 'normal');
            col1Y += 6;
          }
        }
        
        // ========== COLUMN 2 ==========
        
        // Connecting Plates
        let platesWeightKg = 0;
        if(hasConnectingPlates && pw > 0 && ph > 0) {
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'bold');
          pdf.text('Connecting Plates', col2X, col2Y);
          col2Y += 5;
          
          const plate2wayKg = 0.141;
          const plate4wayKg = 0.249;
          const plates = calculateConnectingPlates(pw, ph, plate2wayKg, plate4wayKg);
          platesWeightKg = plates.totalPlateWeight;
          
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          
          if(plates.total2way > 0) {
            pdf.text('2-Way (yellow)', col2X + colLabelX, col2Y);
            pdf.text(plates.total2way.toString(), col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          if(plates.total4way > 0) {
            pdf.text('4-Way (red)', col2X + colLabelX, col2Y);
            pdf.text(plates.total4way.toString(), col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          
          pdf.setDrawColor(100, 100, 100);
          pdf.line(col2X + colLabelX, col2Y, col2X + colValueX, col2Y);
          col2Y += 3;
          pdf.setFont(undefined, 'bold');
          pdf.text('Total Weight', col2X + colLabelX, col2Y);
          const platesWeightDisplay = displayWeightUnit === 'lbs' ? (platesWeightKg * KG_TO_LBS).toFixed(1) : platesWeightKg.toFixed(1);
          pdf.text(`${platesWeightDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
          pdf.setFont(undefined, 'normal');
          col2Y += 6;
        }
        
        // Total Structure Weight (in column 2, below connecting plates)
        const totalStructureWeightKg = pickupWeightKg + platesWeightKg + groundSupportWeightKg;
        if(totalStructureWeightKg > 0) {
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'bold');
          pdf.text('Total Structure Weight', col2X, col2Y);
          col2Y += 5;
          
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          
          if(pickupWeightKg > 0) {
            pdf.text('Pickup Points', col2X + colLabelX, col2Y);
            const pickupDisplay = displayWeightUnit === 'lbs' ? (pickupWeightKg * KG_TO_LBS).toFixed(0) : pickupWeightKg.toFixed(0);
            pdf.text(`${pickupDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          if(platesWeightKg > 0) {
            pdf.text('Connecting Plates', col2X + colLabelX, col2Y);
            const platesDisplay = displayWeightUnit === 'lbs' ? (platesWeightKg * KG_TO_LBS).toFixed(1) : platesWeightKg.toFixed(1);
            pdf.text(`${platesDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          if(groundSupportWeightKg > 0) {
            pdf.text('Ground Support', col2X + colLabelX, col2Y);
            const gsDisplay = displayWeightUnit === 'lbs' ? (groundSupportWeightKg * KG_TO_LBS).toFixed(1) : groundSupportWeightKg.toFixed(1);
            pdf.text(`${gsDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
            col2Y += 3.5;
          }
          
          pdf.setDrawColor(100, 100, 100);
          pdf.line(col2X + colLabelX, col2Y, col2X + colValueX, col2Y);
          col2Y += 3;
          pdf.setFont(undefined, 'bold');
          pdf.text('Total', col2X + colLabelX, col2Y);
          const totalDisplay = displayWeightUnit === 'lbs' ? (totalStructureWeightKg * KG_TO_LBS).toFixed(0) : totalStructureWeightKg.toFixed(0);
          pdf.text(`${totalDisplay} ${wtUnit}`, col2X + colValueX, col2Y, { align: 'right' });
          pdf.setFont(undefined, 'normal');
          col2Y += 4;
        }
        
        yOffset = Math.max(col1Y, col2Y) + 4;
        
      } catch(err) {
        console.error('Error adding structure view page:', err);
      }
      
      if(callback) setTimeout(callback, 10);
    }
    
    // Add gear list page for a screen
    function addGearListPage(screenId, screenName, processorGroups, callback) {
      console.log('addGearListPage called:', screenId, screenName);
      try {
        // Start new page for gear list
        pdf.addPage();
        yOffset = margin;
        
        // Title
        pdf.setFontSize(16);
        pdf.setFont(undefined, 'bold');
        pdf.setTextColor(0, 0, 0);
        pdf.text(`Gear List - ${screenName}`, margin, yOffset);
        yOffset += 10;
        
        console.log('Title added, yOffset:', yOffset);
        
        // Get screen data directly
        const screen = screens[screenId];
        if(!screen || !screen.data) {
          console.error('No screen data found for:', screenId);
          if(callback) setTimeout(callback, 10);
          return;
        }
        
        const data = screen.data;
        const calcData = screen.calculatedData || {};
        console.log('Screen data:', data);
        console.log('Calculated data:', calcData);
        
        const panelType = data.panelType || 'CB5_MKII';
        const p = panels[panelType];
        
        const pw = parseInt(data.panelsWide) || 0;
        const ph = parseInt(data.panelsHigh) || 0;
        
        // Check if this is the first screen (for SDI/HDMI/UG which only appear once)
        const isFirstScreen = (screenIndex === 0);
        
        // Check if canvas is 4K (need 12G SDI cables)
        const canvasSize = data.canvasSize || '4K_UHD';
        const is4KCanvas = (canvasSize === '4K_UHD' || canvasSize === '4K_DCI');
        
        // ========== PROCESSOR GROUP INFO FOR THIS SCREEN ==========
        const processorType = data.processor || 'Brompton_SX40';
        const processorGroup = processorGroups[processorType] || null;
        const isFirstScreenInGroup = processorGroup && processorGroup.firstScreenId === screenId;
        
        // ========== READ FROM CALCULATED DATA ==========
        
        // Equipment - use combined processor group data instead of per-screen
        const processorName = calcData.processorName || '';
        const activePanels = calcData.activePanels || calcData.panelCount || 0;
        
        // Rigging Hardware - read from calculatedData (set by calculate())
        const bumper1wCount = calcData.bumper1wCount || 0;
        const bumper2wCount = calcData.bumper2wCount || 0;
        const bumper4wCount = calcData.bumper4wCount || 0;
        
        // Connecting Plates - read from calculatedData (set by updateStructurePlatesDisplay())
        const plates2way = calcData.plates2way || 0;
        const plates4way = calcData.plates4way || 0;
        
        // Ground Support - read from calculatedData (set by updateGroundSupportDisplay())
        const groundSupport = calcData.groundSupport || {
          totalRearTruss: 0,
          totalBaseTruss: 0,
          totalBridgeClamps: 0,
          totalRearBridgeClampAdapters: 0,
          totalSandbags: 0,
          totalSwivelCheeseboroughs: 0,
          totalPipes: 0,
          pipeInfo: []
        };
        
        // Power - read from calculatedData (set by calculate())
        const socaCount = calcData.socaCount || 0;
        const circuitsNeeded = calcData.circuitsNeeded || 0;
        const columnsPerCircuit = calcData.columnsPerCircuit || 1;
        
        // ========== CALCULATE DATA CROSS JUMPERS ==========
        // Count column transitions for each data line
        let dataCrossJumperCount = 0;
        
        if(pw > 0 && ph > 0) {
          // Get data calculation parameters from screen data
          const pr = processors[data.processor] || processors['Brompton_SX40'];
          const portCapacity = pr ? pr.base_pixels_1g : 525000;
          const frameRate = parseInt(data.frameRate) || 60;
          const bitDepth = parseInt(data.bitDepth) || 8;
          
          // Calculate adjusted port capacity
          let adjustedCapacity = portCapacity;
          if(frameRate > 60) {
            adjustedCapacity = Math.floor(portCapacity * (60 / frameRate));
          }
          if(bitDepth > 8) {
            adjustedCapacity = Math.floor(adjustedCapacity * (8 / bitDepth));
          }
          
          // Calculate panels per data line
          const pixelsPerPanel = p ? (p.res_x * p.res_y) : 1;
          const capacityBasedPanelsPerData = Math.max(1, Math.floor(adjustedCapacity / pixelsPerPanel));
          const panelSpecificDataLimit = p ? p.max_panels_per_data : null;
          const suggestedPanelsPerData = panelSpecificDataLimit 
            ? Math.min(capacityBasedPanelsPerData, panelSpecificDataLimit)
            : capacityBasedPanelsPerData;
          const userMaxPanelsPerData = parseInt(data.maxPanelsPerData) || 0;
          const panelsPerDataLine = userMaxPanelsPerData > 0 ? userMaxPanelsPerData : suggestedPanelsPerData;
          
          const startDir = data.dataStartDir || 'top';
          const customDataLines = data.customDataLineAssignments;
          const hasCustomDataLines = customDataLines && customDataLines.size > 0;
          const deletedPanels = data.deletedPanels;
          
          if(startDir === 'all_top' || startDir === 'all_bottom') {
            // Each column is its own data line - no cross jumpers needed
            dataCrossJumperCount = 0;
          } else {
            // Serpentine layout - need to track which columns each data line spans
            // Build a map of data line -> set of columns it spans
            const dataLineColumns = new Map(); // dataLineNumber -> Set of column numbers
            
            // Collect custom data line numbers in use
            const usedCustomDataLines = new Set();
            if(hasCustomDataLines) {
              for(let c = 0; c < pw; c++) {
                for(let r = 0; r < ph; r++) {
                  const panelKey = `${c},${r}`;
                  const isDeleted = deletedPanels && deletedPanels.has && deletedPanels.has(panelKey);
                  if(!isDeleted && customDataLines.has(panelKey)) {
                    usedCustomDataLines.add(customDataLines.get(panelKey) - 1);
                  }
                }
              }
            }
            
            let autoDataLineCounter = 0;
            let panelsInCurrentAutoDataLine = 0;
            
            // Skip initial custom data lines
            while(usedCustomDataLines.has(autoDataLineCounter)) {
              autoDataLineCounter++;
            }
            
            // Build serpentine path and track columns per data line
            let serpentineGoingDown = (startDir === 'top');
            for(let c = 0; c < pw; c++) {
              const rows = serpentineGoingDown 
                ? Array.from({length: ph}, (_, i) => i) 
                : Array.from({length: ph}, (_, i) => ph - 1 - i);
              
              for(const r of rows) {
                const panelKey = `${c},${r}`;
                if(deletedPanels && deletedPanels.has && deletedPanels.has(panelKey)) continue;
                
                let dataLine;
                if(hasCustomDataLines && customDataLines.has(panelKey)) {
                  dataLine = customDataLines.get(panelKey) - 1;
                } else {
                  // Find next available data line number
                  while(usedCustomDataLines.has(autoDataLineCounter)) {
                    autoDataLineCounter++;
                  }
                  
                  dataLine = autoDataLineCounter;
                  panelsInCurrentAutoDataLine++;
                  
                  // Move to next data line when we reach the limit
                  if(panelsInCurrentAutoDataLine >= panelsPerDataLine) {
                    autoDataLineCounter++;
                    panelsInCurrentAutoDataLine = 0;
                    
                    while(usedCustomDataLines.has(autoDataLineCounter)) {
                      autoDataLineCounter++;
                    }
                  }
                }
                
                // Track which column this data line spans
                if(!dataLineColumns.has(dataLine)) {
                  dataLineColumns.set(dataLine, new Set());
                }
                dataLineColumns.get(dataLine).add(c);
              }
              
              serpentineGoingDown = !serpentineGoingDown;
            }
            
            // Count cross jumpers: for each data line, count (columns spanned - 1)
            dataLineColumns.forEach((columns, dataLine) => {
              const columnCount = columns.size;
              if(columnCount > 1) {
                dataCrossJumperCount += (columnCount - 1);
              }
            });
          }
        }
        
        // Pipe length string
        let pipeLengthStr = '';
        if(groundSupport.totalPipes > 0 && groundSupport.pipeInfo && groundSupport.pipeInfo.length > 0) {
          const uniqueLengths = [...new Set(groundSupport.pipeInfo.map(pi => pi.pipeLengthFt))];
          pipeLengthStr = ' (' + uniqueLengths.map(l => l + 'ft').join(', ') + ')';
        }
        
        // === TWO-COLUMN LAYOUT SETUP ===
        const colWidth = 90; // Width of each column in mm
        const col1X = margin;
        const col2X = margin + colWidth + 5; // 5mm gap between columns
        const lineHeight = 4.5;
        const labelValueGap = 2; // Gap between label and value (closer)
        const sectionGap = 2;
        
        let currentCol = 1;
        let col1Y = yOffset;
        let col2Y = yOffset;
        const startY = yOffset;
        
        function getCurrentY() {
          return currentCol === 1 ? col1Y : col2Y;
        }
        
        function setCurrentY(y) {
          if(currentCol === 1) col1Y = y;
          else col2Y = y;
        }
        
        function getLabelX() {
          return currentCol === 1 ? col1X : col2X;
        }
        
        function addLine(label, value) {
          // Skip items with value 0 or empty
          if(value === '0' || value === '' || value === null || value === undefined) {
            return;
          }
          const y = getCurrentY();
          if(y > pageHeight - margin - 10) {
            // Column overflow - would need new page, but we're designing to fit
            return;
          }
          pdf.setFontSize(9);
          pdf.setFont(undefined, 'normal');
          pdf.setTextColor(0, 0, 0);
          const labelX = getLabelX();
          pdf.text(label, labelX, y);
          // Value right after label with small gap
          const labelWidth = pdf.getTextWidth(label);
          pdf.text(String(value), labelX + labelWidth + labelValueGap, y);
          setCurrentY(y + lineHeight);
        }
        
        function addSectionHeader(title) {
          const y = getCurrentY();
          if(y > pageHeight - margin - 15) {
            return;
          }
          setCurrentY(y + sectionGap);
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(0, 0, 0);
          pdf.text(title, getLabelX(), getCurrentY());
          setCurrentY(getCurrentY() + 5);
        }
        
        function switchToColumn2() {
          currentCol = 2;
          col2Y = startY; // Start at same Y as column 1
        }
        
        console.log('Gear List Debug:', {
          panelType, pw, ph, activePanels,
          bumper1wCount, bumper2wCount, bumper4wCount,
          plates2way, plates4way,
          processorName, processorGroup, isFirstScreenInGroup,
          isFirstScreen, is4KCanvas
        });
        
        // ========== COLUMN 1 ==========
        
        // === EQUIPMENT SECTION ===
        addSectionHeader('Equipment');
        
        // Processor and Distribution Box - show combined totals on first screen of each processor group
        if(isFirstScreenInGroup && processorGroup) {
          const groupProcessorCount = processorGroup.processorCount || 0;
          const groupDistBoxCount = processorGroup.distBoxCount || 0;
          const distBoxName = processorGroup.distBoxName || 'Distribution Box';
          const totalPorts = processorGroup.totalPorts || 0;
          const screensInGroup = processorGroup.screens.length;
          
          // Show processor count with name
          if(groupProcessorCount > 0) {
            addLine('Processor:', `${groupProcessorCount}x ${processorName}`);
          } else {
            addLine('Processor:', '');
          }
          
          // Show distribution box count with name (XD, CVT, etc.)
          if(groupDistBoxCount > 0) {
            addLine(`${distBoxName}:`, groupDistBoxCount.toString());
          }
          
          // Add note if multiple screens share this processor
          if(screensInGroup > 1) {
            const otherScreenNames = processorGroup.screens
              .filter(s => s.screenId !== screenId)
              .map(s => s.screenName)
              .join(', ');
            pdf.setFontSize(7);
            pdf.setTextColor(100, 100, 100);
            pdf.text(`(Combined for ${screensInGroup} screens: ${screenName}, ${otherScreenNames})`, getLabelX(), getCurrentY());
            pdf.setTextColor(0, 0, 0);
            pdf.setFontSize(9);
            setCurrentY(getCurrentY() + 3);
          }
        } else if(processorGroup) {
          // This screen is tied to another screen's processor
          addLine('Processor:', `See ${processorGroup.firstScreenName}`);
          pdf.setFontSize(7);
          pdf.setTextColor(100, 100, 100);
          pdf.text(`(Tied to ${processorName} on ${processorGroup.firstScreenName})`, getLabelX(), getCurrentY());
          pdf.setTextColor(0, 0, 0);
          pdf.setFontSize(9);
          setCurrentY(getCurrentY() + 3);
        } else {
          // Fallback - no group info
          addLine('Processor:', processorName || '');
        }
        
        addLine('Panel Count:', activePanels.toString());
        
        // === RIGGING SECTION ===
        addSectionHeader('Rigging Hardware');
        addLine('1W Bumpers:', bumper1wCount.toString());
        addLine('2W Bumpers:', bumper2wCount.toString());
        addLine('4W Bumpers:', bumper4wCount.toString());
        addLine('4W Connecting Plates:', plates4way.toString());
        addLine('2W Connecting Plates:', plates2way.toString());
        
        // 5/8" Shackles and Cheeseye - only for CB5, CB5 Half, MC7, and AMT 8.3 (hanging only)
        const needsShacklesAndCheeseye = ['CB5_MKII', 'CB5_MKII_HALF', 'MC7H', 'INFILED_AMT8_3'].includes(panelType);
        const isHanging = data.structureType === 'hanging';
        
        if(needsShacklesAndCheeseye && isHanging && useBumpers) {
          let shackleCount = 0;
          let cheeseyeCount = 0;
          
          if(panelType === 'INFILED_AMT8_3') {
            // AMT 8.3: 1 per 1W bumper, 2 per 2W bumper
            shackleCount = bumper1wCount + (bumper2wCount * 2);
            cheeseyeCount = bumper1wCount + (bumper2wCount * 2);
          } else {
            // CB5, CB5 Half, MC7: 1 per 1W bumper, 1 per 2W bumper
            shackleCount = bumper1wCount + bumper2wCount;
            cheeseyeCount = bumper1wCount + bumper2wCount;
          }
          
          if(shackleCount > 0) {
            addLine('5/8" Shackles:', shackleCount.toString());
          }
          if(cheeseyeCount > 0) {
            addLine('Cheeseye:', cheeseyeCount.toString());
          }
        }
        
        // === GROUND SUPPORT SECTION ===
        addSectionHeader('Ground Support');
        addLine('Rear Truss:', groundSupport.totalRearTruss.toString());
        addLine('Base Truss:', groundSupport.totalBaseTruss.toString());
        addLine('Bridge Clamps:', groundSupport.totalBridgeClamps.toString());
        addLine('Rear Bridge Adapter:', groundSupport.totalRearBridgeClampAdapters.toString());
        addLine('Sandbags:', groundSupport.totalSandbags.toString());
        addLine('Swivel Cheeseborough:', groundSupport.totalSwivelCheeseboroughs.toString());
        addLine('Pipe' + pipeLengthStr + ':', groundSupport.totalPipes.toString());
        
        // === DATA CABLES SECTION (now includes Cat6) ===
        addSectionHeader('Data Cables');
        // Get cable lengths from panel specs
        const dataJumperLen = p && p.data_jumper_ft ? p.data_jumper_ft : '';
        const dataCrossJumperLen = p && p.data_cross_jumper_ft ? p.data_cross_jumper_ft : '';
        const jumpersBuiltin = p && p.jumpers_builtin;
        
        // Only show data jumpers if not built-in to panel
        if(!jumpersBuiltin && dataJumperLen) {
          addLine(`Data Jumpers ${dataJumperLen}:`, activePanels.toString());
        }
        if(dataCrossJumperLen && dataCrossJumperCount > 0) {
          addLine(`Data Cross Jumpers ${dataCrossJumperLen}:`, dataCrossJumperCount.toString());
        }
        // Cat5 Couplers - needed for CB5, CB5 Half, MC7 panels
        // Count = data cross jumpers (column transitions) + data lines (one per line to connect to distro)
        if(jumpersBuiltin) {
          const dataLinesCount = calcData.dataLines || 0;
          const totalCat5Couplers = dataCrossJumperCount + dataLinesCount;
          if(totalCat5Couplers > 0) {
            addLine('Cat5 Couplers:', totalCat5Couplers.toString());
          }
        }
        addLine("200' Cat6:", '');
        addLine("100' Cat6:", '');
        addLine("50' Cat6:", '');
        addLine("25' Cat6:", '');
        addLine("10' Cat6:", '');
        addLine("5' Cat6:", '');
        
        // === POWER CABLES SECTION ===
        addSectionHeader('Power Cables');
        // Get power jumper length from panel specs
        const powerJumperLen = p && p.power_jumper_ft ? p.power_jumper_ft : '';
        
        // Only show power jumpers if not built-in to panel
        if(!jumpersBuiltin && powerJumperLen) {
          addLine(`Power Jumpers ${powerJumperLen}:`, activePanels.toString());
        }
        addLine('Soca Splays:', socaCount.toString());
        addLine("100' Soca:", '');
        addLine("75' Soca:", '');
        addLine("50' Soca:", '');
        addLine("25' Soca:", '');
        addLine("50' True1:", '');
        addLine("25' True1:", (socaCount * 2).toString());
        addLine("10' True1:", (socaCount * 2).toString());
        addLine("5' True1:", (socaCount * 4).toString());
        addLine("3' True1:", '');
        addLine('True1 Twofer:', columnsPerCircuit > 1 ? (circuitsNeeded * columnsPerCircuit).toString() : '');
        
        // ========== COLUMN 2 ==========
        switchToColumn2();
        
        // === SIGNAL CABLES SECTION (only on first screen) ===
        if(isFirstScreen) {
          addSectionHeader('Signal Cables');
          addLine("500' Fiber Opticon:", '');
          addLine('Fiber 4ch Opticon Splay:', '');
          
          const processorCount = processorGroup ? processorGroup.processorCount : 0;
          const sdiPerProcessor = processorCount * 2;
          if(is4KCanvas) {
            // 4K canvas needs 12G SDI cables (25ft or longer only)
            addLine("100' 12G SDI:", sdiPerProcessor.toString());
            addLine("75' 12G SDI:", '');
            addLine("50' 12G SDI:", sdiPerProcessor.toString());
            addLine("25' 12G SDI:", sdiPerProcessor.toString());
          } else {
            // HD canvas uses regular SDI
            addLine("100' SDI:", sdiPerProcessor.toString());
            addLine("75' SDI:", '');
            addLine("50' SDI:", sdiPerProcessor.toString());
            addLine("25' SDI:", sdiPerProcessor.toString());
            addLine("10' SDI:", '6');
            addLine("3' SDI:", '6');
          }
          
          // HDMI
          addLine("25' HDMI:", '6');
          addLine("10' HDMI:", '6');
          addLine("6' HDMI:", '6');
        }
        
        // === UTILITY SECTION (only on first screen) ===
        if(isFirstScreen) {
          addSectionHeader('Utility');
          addLine("UG 10':", '8');
          addLine("UG 25':", '6');
          addLine("UG 50':", '6');
          addLine('UG Twofers:', '8');
          addLine('Power Bars:', '8');
        }
        
        // === SPARES SECTION ===
        addSectionHeader('SPARES');
        addLine('Spare Soca Splays:', '');
        addLine('Spare Panel Count:', '');
        // Only show spare jumpers if not built-in to panel
        if(!jumpersBuiltin && dataJumperLen) {
          addLine(`Spare Data Jumpers ${dataJumperLen}:`, '');
        }
        if(dataCrossJumperLen) {
          addLine(`Spare Data Cross Jumpers ${dataCrossJumperLen}:`, '');
        }
        // Spare Cat5 couplers only for panels with built-in jumpers
        if(jumpersBuiltin) {
          addLine('Spare Cat5 Couplers:', '');
        }
        if(!jumpersBuiltin && powerJumperLen) {
          addLine(`Spare Power Jumpers ${powerJumperLen}:`, '');
        }
        addLine('Spare Soca:', '');
        addLine('Spare Data:', '');
        addLine('Spare Fiber:', '');
        
        // Set final yOffset to the max of both columns
        yOffset = Math.max(col1Y, col2Y);
        
        console.log('Gear list completed, final yOffset:', yOffset);
        
      } catch(e) {
        console.error('Error generating gear list:', e);
        console.error('Stack trace:', e.stack);
      }
      
      // Call callback when done
      console.log('Calling gear list callback');
      if(callback) setTimeout(callback, 10);
    }
    
    function addCanvasViewPage() {
      updateProgress('Adding canvas view...', 90);
      
      // Restore original screen
      switchToScreen(originalScreenId);
      
      setTimeout(() => {
        const canvasContainer = document.getElementById('canvasContainer');
        const canvasView = document.getElementById('canvasView');
        
        if(canvasContainer && canvasContainer.style.display !== 'none' && canvasView && canvasView.width > 0) {
          pdf.addPage();
          yOffset = margin;
          
          // Title
          pdf.setFontSize(16);
          pdf.setFont(undefined, 'bold');
          pdf.setTextColor(0, 0, 0);
          pdf.text('Canvas View - All Screens', margin, yOffset);
          yOffset += 6;
          
          // Canvas Resolution
          const canvasSize = document.getElementById('canvasSize').value;
          let canvasResX, canvasResY;
          if(canvasSize === 'custom') {
            canvasResX = parseInt(document.getElementById('customCanvasWidth').value) || 1920;
            canvasResY = parseInt(document.getElementById('customCanvasHeight').value) || 1080;
          } else if(canvasSize === '4K_UHD') {
            canvasResX = 3840; canvasResY = 2160;
          } else if(canvasSize === '4K_DCI') {
            canvasResX = 4096; canvasResY = 2160;
          } else if(canvasSize === 'HD') {
            canvasResX = 1920; canvasResY = 1080;
          } else {
            canvasResX = 1920; canvasResY = 1080;
          }
          
          pdf.setFontSize(10);
          pdf.setFont(undefined, 'normal');
          pdf.text(`Canvas Resolution: ${canvasResX} Ã— ${canvasResY} px`, margin, yOffset);
          yOffset += 8;
          
          // Add canvas view image
          const canvasImg = canvasView.toDataURL('image/png');
          const maxWidth = pageWidth - 2 * margin;
          const canvasAspect = canvasView.height / canvasView.width;
          
          // Calculate image size - leave room for screen list below
          let imgWidth = maxWidth;
          let imgHeight = imgWidth * canvasAspect;
          const maxImgHeight = 120; // mm - limit height to leave room for screen info
          
          if(imgHeight > maxImgHeight) {
            imgHeight = maxImgHeight;
            imgWidth = imgHeight / canvasAspect;
          }
          
          pdf.addImage(canvasImg, 'PNG', margin, yOffset, imgWidth, imgHeight);
          yOffset += imgHeight + 10;
          
          // Add screen list below canvas
          const screenIds = Object.keys(screens).sort((a, b) => {
            const numA = parseInt(a.split('_')[1]);
            const numB = parseInt(b.split('_')[1]);
            return numA - numB;
          });
          
          screenIds.forEach((screenId, index) => {
            const screen = screens[screenId];
            if(!screen.visible) return;
            
            const screenData = screen.data;
            const panelType = screenData.panelType || 'CB5_MKII';
            const p = panels[panelType];
            
            if(!p || !p.res_x || !p.res_y) return;
            
            const pw = screenData.panelsWide || 0;
            const ph = screenData.panelsHigh || 0;
            
            if(pw === 0 || ph === 0) return;
            
            // Check if CB5 half panel row is enabled
            const hasCB5HalfRow = screenData.addCB5HalfRow && panelType === 'CB5_MKII';
            
            // Calculate wall resolution
            let wallResX, wallResY;
            if(hasCB5HalfRow) {
              const halfPanel = panels['CB5_MKII_HALF'];
              wallResX = pw * p.res_x;
              wallResY = ph * p.res_y + halfPanel.res_y;
            } else {
              wallResX = pw * p.res_x;
              wallResY = ph * p.res_y;
            }
            
            const canvasX = screenData.canvasX || 0;
            const canvasY = screenData.canvasY || 0;
            const panelDesc = hasCB5HalfRow ? `${pw} Ã— ${ph} + half row panels` : `${pw} Ã— ${ph} panels`;
            
            // Check for page break
            if(yOffset + 20 > pageHeight - margin) {
              pdf.addPage();
              yOffset = margin;
            }
            
            // Screen name
            pdf.setFontSize(11);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(0, 0, 0);
            pdf.text(screen.name, margin, yOffset);
            yOffset += 5;
            
            // Wall Resolution
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'normal');
            pdf.text(`Wall Resolution: ${wallResX} Ã— ${wallResY} px (${panelDesc})`, margin, yOffset);
            yOffset += 4;
            
            // Position
            pdf.text(`Position: X=${canvasX}px, Y=${canvasY}px`, margin, yOffset);
            yOffset += 6;
          });
        }
        
        updateProgress('Saving PDF...', 100);
        
        // Save the PDF
        const date = new Date().toISOString().slice(0,10);
        const configName = document.getElementById('configName').value.trim();
        const filename = configName 
          ? `${configName}_${date}.pdf` 
          : `LED_Wall_Calculator_${date}.pdf`;
        pdf.save(filename);
        
        // Remove overlay after a short delay
        setTimeout(removeOverlay, 100);
      }, 150);
    }
    
    // Start processing
    processNextScreen();
    
  } catch(err) {
    console.error('PDF export error:', err);
    alert('Error exporting PDF: ' + err.message);
    // Make sure to remove overlay on error
    const overlay = document.getElementById('pdfExportOverlay');
    if(overlay) overlay.remove();
  }
}

function exportCanvas(){
  try {
    const canvas = document.getElementById('canvasView');
    if(canvas.width === 0 || document.getElementById('canvasContainer').style.display === 'none'){
      alert('Please generate a canvas view first by clicking "Calculate".');
      return;
    }
    
    const format = document.getElementById('canvasExportFormat').value;
    
    // Get the canvas size label
    const canvasSizeSelect = document.getElementById('canvasSize');
    const canvasSizeValue = canvasSizeSelect.value;
    let canvasSizeLabel;
    
    // For custom size, use the actual dimensions
    if(canvasSizeValue === 'custom') {
      canvasSizeLabel = `${canvas.width}x${canvas.height}`;
    } else {
      // Clean up the label (e.g., "4K UHD (3840x2160)" -> "4K_UHD_3840x2160")
      canvasSizeLabel = canvasSizeSelect.options[canvasSizeSelect.selectedIndex].text
        .replace(/\s+/g, '_')
        .replace(/[()]/g, '');
    }
    
    const filenameInput = document.getElementById('canvasExportFilename');
    let customName = filenameInput ? filenameInput.value.trim() : '';
    
    // Always include canvas size in filename
    let filename;
    if(customName) {
      // If custom name provided, append canvas size
      filename = `${customName}_${canvasSizeLabel}`;
    } else {
      // Default name with canvas size
      filename = `LED_Wall_Canvas_${canvasSizeLabel}`;
    }
    
    // Clean filename of invalid characters
    filename = filename.replace(/[<>:"/\\|?*]/g, '_');
    
    // Create a clean canvas without selection highlight for export
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvas.width;
    exportCanvas.height = canvas.height;
    const exportCtx = exportCanvas.getContext('2d');
    
    // Use cached image data (without highlight) if available, otherwise use current canvas
    if(cachedCanvasImageData) {
      exportCtx.putImageData(cachedCanvasImageData, 0, 0);
    } else {
      exportCtx.drawImage(canvas, 0, 0);
    }
    
    // Export the clean canvas
    if(format === 'pdf'){
      alert('PDF export requires external libraries. Please select PNG or JPEG format instead.');
      return;
    } else if(format === 'jpeg'){
      const link = document.createElement('a');
      link.download = filename + '.jpg';
      link.href = exportCanvas.toDataURL('image/jpeg', 0.95);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } else if(format === 'png'){
      const link = document.createElement('a');
      link.download = filename + '.png';
      link.href = exportCanvas.toDataURL('image/png');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  } catch(err) {
    alert('Error exporting canvas: ' + err.message);
    console.error('Export error:', err);
  }
}

function setupLive(){
  const liveIds = ['panelType','processor','powerType','panelsWide','panelsHigh','voltage','breaker','phase','maxPanelsPerCircuit','maxPanelsPerData','dataStartDir','showArrows','canvasSize','canvasX','canvasY','wallWidth','wallHeight','frameRate','bitDepth','redundancy','customCanvasWidth','customCanvasHeight','addCB5HalfRow'];
  
  liveIds.forEach(id => {
    const el = document.getElementById(id);
    if(!el) {
      return;
    }
    
    // Add event listener to trigger canvas update when value changes
    const eventType = (el.type === 'checkbox' || el.tagName === 'SELECT') ? 'change' : 'input';
    el.addEventListener(eventType, function() {
      // Update current screen data when inputs change
      saveCurrentScreenData();
      // Trigger recalculation which will update all views including canvas
      calculate();
    });
  });
}

// Custom Panel Modal
function openCustomPanelModal(editKey = null) {
  const modal = document.getElementById('customPanelModal');
  const title = document.getElementById('customPanelModalTitle');
  
  if(editKey) {
    title.textContent = 'Edit Custom Panel';
    const panel = customPanels[editKey];
    document.getElementById('customPanelBrand').value = panel.brand || '';
    document.getElementById('customPanelName').value = panel.name || '';
    document.getElementById('customPanelPixelPitch').value = panel.pixel_pitch_mm || '';
    document.getElementById('customPanelWidth').value = (panel.width_m * 1000) || '';
    document.getElementById('customPanelHeight').value = (panel.height_m * 1000) || '';
    document.getElementById('customPanelDepth').value = panel.depth_mm || '';
    document.getElementById('customPanelResX').value = panel.res_x || '';
    document.getElementById('customPanelResY').value = panel.res_y || '';
    document.getElementById('customPanelPowerMax').value = panel.power_max_w || '';
    document.getElementById('customPanelPowerAvg').value = panel.power_avg_w || '';
    document.getElementById('customPanelBrightness').value = panel.brightness_nits || '';
    document.getElementById('customPanelMaxHanging').value = panel.max_hanging || '';
    document.getElementById('customPanelMaxStacking').value = panel.max_stacking || '';
    document.getElementById('customPanelWeight').value = panel.weight_kg || '';
    document.getElementById('customPanelRemovableFrame').checked = panel.removable_frame || false;
    document.getElementById('customPanelFrameWeight').value = panel.frame_weight_kg || '';
    document.getElementById('customPanelWeightNoFrame').value = panel.weight_no_frame_kg || '';
    document.getElementById('customPanel1wBumper').value = panel.bumper_1w_lbs || '';
    document.getElementById('customPanel2wBumper').value = panel.bumper_2w_lbs || '';
    
    modal.dataset.editKey = editKey;
  } else {
    title.textContent = 'Add Custom Panel';
    // Clear all fields
    document.getElementById('customPanelBrand').value = '';
    document.getElementById('customPanelName').value = '';
    document.getElementById('customPanelPixelPitch').value = '';
    document.getElementById('customPanelWidth').value = '';
    document.getElementById('customPanelHeight').value = '';
    document.getElementById('customPanelDepth').value = '';
    document.getElementById('customPanelResX').value = '';
    document.getElementById('customPanelResY').value = '';
    document.getElementById('customPanelPowerMax').value = '';
    document.getElementById('customPanelPowerAvg').value = '';
    document.getElementById('customPanelBrightness').value = '';
    document.getElementById('customPanelMaxHanging').value = '';
    document.getElementById('customPanelMaxStacking').value = '';
    document.getElementById('customPanelWeight').value = '';
    document.getElementById('customPanelRemovableFrame').checked = false;
    document.getElementById('customPanelFrameWeight').value = '';
    document.getElementById('customPanelWeightNoFrame').value = '';
    document.getElementById('customPanel1wBumper').value = '';
    document.getElementById('customPanel2wBumper').value = '';
    
    delete modal.dataset.editKey;
  }
  
  modal.classList.add('active');
  updateFrameWeightFields();
}

function closeCustomPanelModal() {
  const modal = document.getElementById('customPanelModal');
  modal.classList.remove('active');
}

function updateFrameWeightFields() {
  const hasFrame = document.getElementById('customPanelRemovableFrame').checked;
  const frameFields = document.getElementById('frameWeightFields');
  frameFields.style.display = hasFrame ? 'block' : 'none';
}

function saveCustomPanel() {
  const brand = document.getElementById('customPanelBrand').value.trim();
  const name = document.getElementById('customPanelName').value.trim();
  
  if(!brand || !name) {
    alert('Please enter brand and name');
    return;
  }
  
  const modal = document.getElementById('customPanelModal');
  const editKey = modal.dataset.editKey;
  const key = editKey || `CUSTOM_${brand.replace(/\s+/g, '_')}_${name.replace(/\s+/g, '_')}`;
  
  const panel = {
    brand: brand,
    name: name,
    pixel_pitch_mm: parseFloat(document.getElementById('customPanelPixelPitch').value) || null,
    width_m: parseFloat(document.getElementById('customPanelWidth').value) / 1000 || null,
    height_m: parseFloat(document.getElementById('customPanelHeight').value) / 1000 || null,
    depth_mm: parseFloat(document.getElementById('customPanelDepth').value) || null,
    res_x: parseInt(document.getElementById('customPanelResX').value) || null,
    res_y: parseInt(document.getElementById('customPanelResY').value) || null,
    power_max_w: parseFloat(document.getElementById('customPanelPowerMax').value) || null,
    power_avg_w: parseFloat(document.getElementById('customPanelPowerAvg').value) || null,
    brightness_nits: parseInt(document.getElementById('customPanelBrightness').value) || null,
    max_hanging: parseInt(document.getElementById('customPanelMaxHanging').value) || null,
    max_stacking: parseInt(document.getElementById('customPanelMaxStacking').value) || null,
    weight_kg: parseFloat(document.getElementById('customPanelWeight').value) || null,
    removable_frame: document.getElementById('customPanelRemovableFrame').checked,
    frame_weight_kg: parseFloat(document.getElementById('customPanelFrameWeight').value) || null,
    weight_no_frame_kg: parseFloat(document.getElementById('customPanelWeightNoFrame').value) || null,
    bumper_1w_lbs: parseFloat(document.getElementById('customPanel1wBumper').value) || null,
    bumper_2w_lbs: parseFloat(document.getElementById('customPanel2wBumper').value) || null,
    bumper_4w_lbs: 66.15, // Default 4W bumper weight
    custom: true
  };
  
  customPanels[key] = panel;
  saveCustomPanels();
  updatePanelDropdowns();
  
  // Select the new/edited panel
  const panelSelect = document.getElementById('panelType');
  if(panelSelect) {
    panelSelect.value = key;
  }
  
  closeCustomPanelModal();
  alert(`Custom panel "${brand} ${name}" saved successfully!`);
}

// Custom Processor Modal
function openCustomProcessorModal(editKey = null) {
  const modal = document.getElementById('customProcessorModal');
  const title = document.getElementById('customProcessorModalTitle');
  
  if(editKey) {
    title.textContent = 'Edit Custom Processor';
    const proc = customProcessors[editKey];
    document.getElementById('customProcessorName').value = proc.name || '';
    document.getElementById('customProcessor10gPorts').value = proc.ports_10g || 0;
    document.getElementById('customProcessor1gPorts').value = proc.ports_1g || 0;
    document.getElementById('customProcessorPixelsPer1g').value = proc.base_pixels_1g || '';
    document.getElementById('customProcessorPixelsPer10g').value = proc.pixels_per_10g || '';
    
    modal.dataset.editKey = editKey;
  } else {
    title.textContent = 'Add Custom Processor';
    document.getElementById('customProcessorName').value = '';
    document.getElementById('customProcessor10gPorts').value = 0;
    document.getElementById('customProcessor1gPorts').value = 0;
    document.getElementById('customProcessorPixelsPer1g').value = '';
    document.getElementById('customProcessorPixelsPer10g').value = '';
    
    delete modal.dataset.editKey;
  }
  
  modal.classList.add('active');
}

function closeCustomProcessorModal() {
  const modal = document.getElementById('customProcessorModal');
  modal.classList.remove('active');
}

function saveCustomProcessor() {
  const name = document.getElementById('customProcessorName').value.trim();
  
  if(!name) {
    alert('Please enter processor name');
    return;
  }
  
  const modal = document.getElementById('customProcessorModal');
  const editKey = modal.dataset.editKey;
  const key = editKey || `CUSTOM_${name.replace(/\s+/g, '_')}`;
  
  const ports10g = parseInt(document.getElementById('customProcessor10gPorts').value) || 0;
  const ports1g = parseInt(document.getElementById('customProcessor1gPorts').value) || 0;
  const pixelsPer1g = parseInt(document.getElementById('customProcessorPixelsPer1g').value) || 525000;
  const pixelsPer10g = parseInt(document.getElementById('customProcessorPixelsPer10g').value) || 0;
  
  const totalPixels = (ports1g * pixelsPer1g) + (ports10g * (pixelsPer10g || pixelsPer1g * 4));
  
  const processor = {
    name: name,
    ports_10g: ports10g,
    ports_1g: ports1g,
    base_pixels_1g: pixelsPer1g,
    base_framerate: 60,
    base_bitdepth: 8,
    pixels_per_10g: pixelsPer10g || null,
    total_pixels: totalPixels,
    outputs: `${ports1g > 0 ? ports1g + ' Ã— 1G' : ''}${ports1g > 0 && ports10g > 0 ? ' + ' : ''}${ports10g > 0 ? ports10g + ' Ã— 10G' : ''}`,
    custom: true
  };
  
  customProcessors[key] = processor;
  saveCustomProcessors();
  updateProcessorDropdowns();
  
  // Select the new/edited processor
  const processorSelect = document.getElementById('processor');
  if(processorSelect) {
    processorSelect.value = key;
  }
  
  closeCustomProcessorModal();
  alert(`Custom processor "${name}" saved successfully!`);
}

// Delete custom panel
function deleteCustomPanel(key) {
  const panel = customPanels[key];
  if(confirm(`Delete custom panel "${panel.brand} ${panel.name}"?`)) {
    delete customPanels[key];
    saveCustomPanels();
    updatePanelDropdowns();
    closeManageCustomModal();
  }
}

// Delete custom processor
function deleteCustomProcessor(key) {
  const proc = customProcessors[key];
  if(confirm(`Delete custom processor "${proc.name}"?`)) {
    delete customProcessors[key];
    saveCustomProcessors();
    updateProcessorDropdowns();
    closeManageCustomModal();
  }
}

// Manage Custom Items Modal
function openManageCustomModal(type) {
  const modal = document.getElementById('manageCustomModal');
  const title = document.getElementById('manageCustomModalTitle');
  const content = document.getElementById('manageCustomContent');
  
  if(type === 'panels') {
    title.textContent = 'Manage Custom Panels';
    let html = '';
    
    if(Object.keys(customPanels).length === 0) {
      html = '<p style="color: #888; text-align: center; padding: 20px;">No custom panels saved yet.</p>';
    } else {
      html = '<div class="custom-item-list">';
      Object.keys(customPanels).forEach(key => {
        const panel = customPanels[key];
        html += `
          <div class="custom-item">
            <div class="custom-item-name">${panel.brand} ${panel.name}</div>
            <div class="custom-item-actions">
              <button class="btn-small" onclick="openCustomPanelModal('${key}')">Edit</button>
              <button class="btn-small danger" onclick="deleteCustomPanel('${key}')">Delete</button>
            </div>
          </div>
        `;
      });
      html += '</div>';
    }
    
    content.innerHTML = html;
  } else if(type === 'processors') {
    title.textContent = 'Manage Custom Processors';
    let html = '';
    
    if(Object.keys(customProcessors).length === 0) {
      html = '<p style="color: #888; text-align: center; padding: 20px;">No custom processors saved yet.</p>';
    } else {
      html = '<div class="custom-item-list">';
      Object.keys(customProcessors).forEach(key => {
        const proc = customProcessors[key];
        html += `
          <div class="custom-item">
            <div class="custom-item-name">${proc.name}</div>
            <div class="custom-item-actions">
              <button class="btn-small" onclick="openCustomProcessorModal('${key}')">Edit</button>
              <button class="btn-small danger" onclick="deleteCustomProcessor('${key}')">Delete</button>
            </div>
          </div>
        `;
      });
      html += '</div>';
    }
    
    content.innerHTML = html;
  }
  
  modal.classList.add('active');
}

function closeManageCustomModal() {
  const modal = document.getElementById('manageCustomModal');
  modal.classList.remove('active');
}

// Setup removable frame checkbox listener
document.addEventListener('DOMContentLoaded', function() {
  const frameCheckbox = document.getElementById('customPanelRemovableFrame');
  if(frameCheckbox) {
    frameCheckbox.addEventListener('change', updateFrameWeightFields);
  }
});

// ==================== END CUSTOM MODAL FUNCTIONS ====================

// Canvas movement history functions
function saveCanvasMoveState() {
  // Save positions of ALL screens
  const state = {
    screenPositions: {}
  };
  
  // Store each screen's position
  Object.keys(screens).forEach(screenId => {
    const screen = screens[screenId];
    state.screenPositions[screenId] = {
      x: screen.data.canvasX || 0,
      y: screen.data.canvasY || 0
    };
  });
  
  // Also store which screen is selected
  state.selectedScreenId = selectedCanvasScreenId;
  
  // Remove any states after current index (user made a new move after undoing)
  canvasMoveHistory = canvasMoveHistory.slice(0, canvasMoveHistoryIndex + 1);
  
  // Add new state
  canvasMoveHistory.push(state);
  
  // Limit history size
  if(canvasMoveHistory.length > MAX_CANVAS_HISTORY) {
    canvasMoveHistory.shift();
  } else {
    canvasMoveHistoryIndex++;
  }
  
  updateCanvasUndoRedoButtons();
}

function undoCanvasMove() {
  // Need at least 2 states to undo (current + previous)
  if(canvasMoveHistoryIndex <= 0) return;
  
  // Move back one step
  canvasMoveHistoryIndex--;
  
  // Restore the state at this index
  const previousState = canvasMoveHistory[canvasMoveHistoryIndex];
  
  // Restore all screen positions
  if(previousState.screenPositions) {
    Object.keys(previousState.screenPositions).forEach(screenId => {
      if(screens[screenId]) {
        screens[screenId].data.canvasX = previousState.screenPositions[screenId].x;
        screens[screenId].data.canvasY = previousState.screenPositions[screenId].y;
      }
    });
  } else {
    // Legacy format - single x/y (for backwards compatibility)
    if(selectedCanvasScreenId && screens[selectedCanvasScreenId]) {
      screens[selectedCanvasScreenId].data.canvasX = previousState.x;
      screens[selectedCanvasScreenId].data.canvasY = previousState.y;
    } else if(screens[currentScreenId]) {
      screens[currentScreenId].data.canvasX = previousState.x;
      screens[currentScreenId].data.canvasY = previousState.y;
    }
  }
  
  // Update X/Y inputs to show selected or current screen position
  const displayScreenId = selectedCanvasScreenId || currentScreenId;
  if(screens[displayScreenId]) {
    document.getElementById('canvasX').value = screens[displayScreenId].data.canvasX || 0;
    document.getElementById('canvasY').value = screens[displayScreenId].data.canvasY || 0;
    
    // Update global variables if it's the current screen
    if(displayScreenId === currentScreenId) {
      canvasOffsetX = screens[displayScreenId].data.canvasX || 0;
      canvasOffsetY = screens[displayScreenId].data.canvasY || 0;
    }
  }
  
  // Redraw canvas
  showCanvasView();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
  
  updateCanvasUndoRedoButtons();
}

function redoCanvasMove() {
  // Check if we can redo
  if(canvasMoveHistoryIndex >= canvasMoveHistory.length - 1) return;
  
  // Move forward one step
  canvasMoveHistoryIndex++;
  
  // Restore the state at this index
  const nextState = canvasMoveHistory[canvasMoveHistoryIndex];
  
  // Restore all screen positions
  if(nextState.screenPositions) {
    Object.keys(nextState.screenPositions).forEach(screenId => {
      if(screens[screenId]) {
        screens[screenId].data.canvasX = nextState.screenPositions[screenId].x;
        screens[screenId].data.canvasY = nextState.screenPositions[screenId].y;
      }
    });
  } else {
    // Legacy format - single x/y (for backwards compatibility)
    if(selectedCanvasScreenId && screens[selectedCanvasScreenId]) {
      screens[selectedCanvasScreenId].data.canvasX = nextState.x;
      screens[selectedCanvasScreenId].data.canvasY = nextState.y;
    } else if(screens[currentScreenId]) {
      screens[currentScreenId].data.canvasX = nextState.x;
      screens[currentScreenId].data.canvasY = nextState.y;
    }
  }
  
  // Update X/Y inputs to show selected or current screen position
  const displayScreenId = selectedCanvasScreenId || currentScreenId;
  if(screens[displayScreenId]) {
    document.getElementById('canvasX').value = screens[displayScreenId].data.canvasX || 0;
    document.getElementById('canvasY').value = screens[displayScreenId].data.canvasY || 0;
    
    // Update global variables if it's the current screen
    if(displayScreenId === currentScreenId) {
      canvasOffsetX = screens[displayScreenId].data.canvasX || 0;
      canvasOffsetY = screens[displayScreenId].data.canvasY || 0;
    }
  }
  
  // Redraw canvas
  showCanvasView();
  
  // Re-draw selection highlight if there's a selected screen
  if(selectedCanvasScreenId) {
    drawSelectionHighlight();
  }
  
  updateCanvasUndoRedoButtons();
}

function updateCanvasUndoRedoButtons() {
  const undoBtn = document.getElementById('canvasUndoBtn');
  const redoBtn = document.getElementById('canvasRedoBtn');
  
  if(undoBtn) {
    undoBtn.disabled = canvasMoveHistoryIndex <= 0;
  }
  if(redoBtn) {
    redoBtn.disabled = canvasMoveHistoryIndex >= canvasMoveHistory.length - 1;
  }
}

// Save/Load configuration functions
function saveConfiguration() {
  const configName = document.getElementById('configName').value.trim() || 'LED_Wall_Config';
  
  // Save current screen data first
  saveCurrentScreenData();
  
  // Prepare screens data for saving (convert Sets to Arrays)
  const screensData = {};
  Object.keys(screens).forEach(screenId => {
    const screen = screens[screenId];
    const data = screen.data;
    
    // Safely convert deletedPanels
    let deletedPanelsArray = [];
    if(data.deletedPanels instanceof Set) {
      deletedPanelsArray = Array.from(data.deletedPanels);
    } else if(Array.isArray(data.deletedPanels)) {
      deletedPanelsArray = data.deletedPanels;
    }
    
    // Safely convert customCircuitAssignments
    let circuitAssignmentsArray = [];
    if(data.customCircuitAssignments instanceof Map) {
      circuitAssignmentsArray = Array.from(data.customCircuitAssignments.entries());
    } else if(Array.isArray(data.customCircuitAssignments)) {
      circuitAssignmentsArray = data.customCircuitAssignments;
    }
    
    // Safely convert customDataLineAssignments
    let dataLineAssignmentsArray = [];
    if(data.customDataLineAssignments instanceof Map) {
      dataLineAssignmentsArray = Array.from(data.customDataLineAssignments.entries());
    } else if(Array.isArray(data.customDataLineAssignments)) {
      dataLineAssignmentsArray = data.customDataLineAssignments;
    }
    
    // Build data object explicitly without spread to avoid Set/Map issues
    screensData[screenId] = {
      name: screen.name,
      color: screen.color,
      color2: screen.color2,
      visible: screen.visible,
      data: {
        panelsWide: data.panelsWide,
        panelsHigh: data.panelsHigh,
        wallWidth: data.wallWidth,
        wallHeight: data.wallHeight,
        lengthUnit: data.lengthUnit,
        weightUnit: data.weightUnit,
        dimensionMode: data.dimensionMode,
        panelType: data.panelType,
        voltage: data.voltage,
        breaker: data.breaker,
        phase: data.phase,
        powerType: data.powerType,
        maxPanelsPerCircuit: data.maxPanelsPerCircuit,
        processor: data.processor,
        frameRate: data.frameRate,
        bitDepth: data.bitDepth,
        maxPanelsPerData: data.maxPanelsPerData,
        dataStartDir: data.dataStartDir,
        showArrows: data.showArrows,
        redundancy: data.redundancy,
        processorRedundancy: data.processorRedundancy,
        structureType: data.structureType,
        useBumpers: data.useBumpers,
        use4WayBumpers: data.use4WayBumpers,
        addCB5HalfRow: data.addCB5HalfRow,
        connectionMethod: data.connectionMethod,
        trimHeight: data.trimHeight,
        wallToFloor: data.wallToFloor,
        distroToWall: data.distroToWall,
        processorToWall: data.processorToWall,
        fohToProcessor: data.fohToProcessor,
        canvasX: data.canvasX,
        canvasY: data.canvasY,
        canvasSize: data.canvasSize,
        customCanvasWidth: data.customCanvasWidth,
        customCanvasHeight: data.customCanvasHeight,
        snapMode: data.snapMode,
        arrowKeyIncrement: data.arrowKeyIncrement,
        canvasExportFormat: data.canvasExportFormat,
        showTopBumper: data.showTopBumper,
        showBottomBumper: data.showBottomBumper,
        topBumper1wColumn: data.topBumper1wColumn,
        bottomBumper1wColumn: data.bottomBumper1wColumn,
        bumpers: Array.isArray(data.bumpers) ? data.bumpers : [],
        deletedPanels: deletedPanelsArray,
        customCircuitAssignments: circuitAssignmentsArray,
        customDataLineAssignments: dataLineAssignmentsArray
      },
      calculatedData: screen.calculatedData || {}
    };
  });
  
  // Gather all configuration
  const config = {
    version: '2.0',
    timestamp: new Date().toISOString(),
    name: configName,
    currentScreenId: currentScreenId,
    screenIdCounter: screenIdCounter,
    screens: screensData,
    // Global settings
    displayLengthUnit: displayLengthUnit,
    displayWeightUnit: displayWeightUnit
  };
  
  // Convert to JSON and download
  const json = JSON.stringify(config, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `${configName.replace(/\s+/g, '_')}.ledconfig`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  
  alert(`Configuration "${configName}" saved successfully!`);
}

function loadConfiguration(event) {
  const file = event.target.files[0];
  if(!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);
      
      // Verify version
      if(!config.version) {
        throw new Error('Invalid configuration file');
      }
      
      // Check if this is a v2.0 multi-screen config
      if(config.version === '2.0' && config.screens) {
        // Load multi-screen configuration
        
        // Clear existing screens UI
        const tabsContainer = document.getElementById('screenTabsContainer');
        if(tabsContainer) {
          tabsContainer.innerHTML = '';
        }
        
        // Reset screens object
        screens = {};
        
        // Restore screens data
        Object.keys(config.screens).forEach(screenId => {
          const savedScreen = config.screens[screenId];
          
          // Safely restore deletedPanels
          let deletedPanelsSet = new Set();
          if(Array.isArray(savedScreen.data.deletedPanels)) {
            deletedPanelsSet = new Set(savedScreen.data.deletedPanels);
          }
          
          // Safely restore customCircuitAssignments
          let circuitAssignmentsMap = new Map();
          if(Array.isArray(savedScreen.data.customCircuitAssignments)) {
            circuitAssignmentsMap = new Map(savedScreen.data.customCircuitAssignments);
          }
          
          // Safely restore customDataLineAssignments
          let dataLineAssignmentsMap = new Map();
          if(Array.isArray(savedScreen.data.customDataLineAssignments)) {
            dataLineAssignmentsMap = new Map(savedScreen.data.customDataLineAssignments);
          }
          
          // Get screen index for default colors
          const screenIndex = Object.keys(screens).length;
          const defaultColor = screenColors[screenIndex] || '#808080';
          const defaultColor2 = screenColors2[screenIndex] || '#606060';
          
          screens[screenId] = {
            name: savedScreen.name,
            color: savedScreen.color || defaultColor,
            color2: savedScreen.color2 || defaultColor2,
            visible: savedScreen.visible !== false,
            data: {
              ...savedScreen.data,
              deletedPanels: deletedPanelsSet,
              customCircuitAssignments: circuitAssignmentsMap,
              customDataLineAssignments: dataLineAssignmentsMap
            },
            calculatedData: savedScreen.calculatedData || {}
          };
        });
        
        // Restore counters
        screenIdCounter = config.screenIdCounter || Object.keys(screens).length;
        currentScreenId = config.currentScreenId || 'screen_1';
        
        // Restore global settings
        displayLengthUnit = config.displayLengthUnit || 'ft';
        displayWeightUnit = config.displayWeightUnit || 'lbs';
        
        // Update unit buttons
        const isImperial = displayLengthUnit === 'ft';
        document.getElementById('unitImperial')?.classList.toggle('active', isImperial);
        document.getElementById('unitMetric')?.classList.toggle('active', !isImperial);
        
        // Rebuild screen tabs using the proper render function
        renderScreenTabs();
        
        // Load current screen data into form
        loadScreenData(currentScreenId);
        
        // Clear histories
        undoHistory = [];
        redoHistory = [];
        canvasMoveHistory = [];
        canvasMoveHistoryIndex = -1;
        selectedPanels.clear();
        
        // Recalculate
        calculate();
        
        alert(`Configuration "${config.name}" loaded successfully! (${Object.keys(screens).length} screens)`);
      } else {
        // Legacy v1.0 single-screen config - load into current screen
        document.getElementById('panelType').value = config.panelType || 'BP2_V2';
        document.getElementById('processor').value = config.processor || 'Brompton_SX40';
        document.getElementById('powerType').value = config.powerType || 'max';
        document.getElementById('panelsWide').value = config.panelsWide || '';
        document.getElementById('panelsHigh').value = config.panelsHigh || '';
        document.getElementById('wallWidth').value = config.wallWidth || '';
        document.getElementById('wallHeight').value = config.wallHeight || '';
        
        // Restore unit settings
        displayLengthUnit = config.lengthUnit || config.units || 'ft';
        displayWeightUnit = config.weightUnit || 'lbs';
        const isImperialLegacy = displayLengthUnit === 'ft';
        document.getElementById('unitImperial')?.classList.toggle('active', isImperialLegacy);
        document.getElementById('unitMetric')?.classList.toggle('active', !isImperialLegacy);
        
        document.getElementById('voltage').value = config.voltage || '208';
        document.getElementById('breaker').value = config.breaker || '20';
        document.getElementById('phase').value = config.phase || '3';
        document.getElementById('maxPanelsPerCircuit').value = config.maxPanelsPerCircuit || '';
        document.getElementById('maxPanelsPerData').value = config.maxPanelsPerData || '';
        document.getElementById('dataStartDir').value = config.dataStartDir || 'top';
        showArrowsEnabled = config.showArrows !== undefined ? config.showArrows : true;
        document.getElementById('frameRate').value = config.frameRate || '60';
        document.getElementById('bitDepth').value = config.bitDepth || '8';
        redundancyEnabled = config.redundancy || false;
        cb5HalfRowEnabled = config.addCB5HalfRow || false;
        document.getElementById('canvasSize').value = config.canvasSize || '4K_UHD';
        document.getElementById('customCanvasWidth').value = config.customCanvasWidth || '';
        document.getElementById('customCanvasHeight').value = config.customCanvasHeight || '';
        document.getElementById('canvasX').value = config.canvasX || '0';
        document.getElementById('canvasY').value = config.canvasY || '0';
        snapModeEnabled = config.snapMode !== undefined ? config.snapMode : true;
        document.getElementById('arrowKeyIncrement').value = config.arrowKeyIncrement || '10';
        document.getElementById('canvasExportFormat').value = config.canvasExportFormat || 'png';
        
        // Restore deleted panels and custom assignments
        deletedPanels = new Set(config.deletedPanels || []);
        customCircuitAssignments = new Map(config.customCircuitAssignments || []);
        customDataLineAssignments = new Map(config.customDataLineAssignments || []);
        
        // Restore bumper state
        showTopBumper = config.showTopBumper || false;
        showBottomBumper = config.showBottomBumper || false;
        topBumper1wColumn = config.topBumper1wColumn !== undefined ? config.topBumper1wColumn : -1;
        bottomBumper1wColumn = config.bottomBumper1wColumn !== undefined ? config.bottomBumper1wColumn : -1;
        
        // Update bumper button states
        const topBtn = document.getElementById('topBumperBtn');
        const bottomBtn = document.getElementById('bottomBumperBtn');
        if(topBtn) topBtn.textContent = showTopBumper ? 'Top Bumper: ON' : 'Top Bumper: OFF';
        if(bottomBtn) bottomBtn.textContent = showBottomBumper ? 'Bottom Bumper: ON' : 'Bottom Bumper: OFF';
        
        // Trigger visibility updates
        const panelTypeSelect = document.getElementById('panelType');
        if(panelTypeSelect) {
          panelTypeSelect.dispatchEvent(new Event('change'));
        }
        
        const canvasSizeSelect = document.getElementById('canvasSize');
        if(canvasSizeSelect) {
          canvasSizeSelect.dispatchEvent(new Event('change'));
        }
        
        // Clear histories
        undoHistory = [];
        redoHistory = [];
        canvasMoveHistory = [];
        canvasMoveHistoryIndex = -1;
        selectedPanels.clear();
        
        // Recalculate everything
        syncFromPanels();
        updateSuggestedDataLimit();
        calculate();
        
        alert(`Configuration "${config.name}" loaded successfully! (Legacy format)`);
      }
      
      // Reset file input
      event.target.value = '';
    } catch(err) {
      alert('Error loading configuration: ' + err.message);
      console.error('Load error:', err);
    }
  };
  reader.readAsText(file);
}

document.addEventListener('DOMContentLoaded', function() {
  console.log('DOMContentLoaded fired - v55.7 Multi-Screen');
  
  // Global click handler to dismiss context menus
  document.addEventListener('click', function(e) {
    if(contextMenuVisible && !e.target.closest('#bumperContextMenu')) {
      hideContextMenu();
    }
  });
  
  try {
    const btnPDF = document.getElementById('btnExportPDF');
    const btnExp = document.getElementById('btnExportCanvas');
    
    // Auto-calculate on any input change
    const autoCalculateInputs = [
      'addCB5HalfRow',
      'panelsWide', 'panelsHigh', 'wallWidth', 'wallHeight',
      'processor', 'frameRate', 'bitDepth', 'maxPanelsPerData', 'dataStartDir',
      'voltage', 'breaker', 'phase', 'powerType', 'maxPanelsPerCircuit',
      'installationType', 'use4WayBumpers', 'bumperDistribution',
      'plate2wayWeight', 'plate4wayWeight'
    ];
    
    // Add change listeners to all inputs
    autoCalculateInputs.forEach(id => {
      const element = document.getElementById(id);
      if(element) {
        element.addEventListener('change', () => {
          calculate();
        });
        // Also listen for input events on number fields for real-time updates
        if(element.type === 'number') {
          element.addEventListener('input', () => {
            calculate();
          });
        }
      }
    });
    
    // Listen for connection method radio changes
    const connectionRadios = document.querySelectorAll('input[name="connectionMethod"]');
    connectionRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        calculate();
      });
    });
    
    // Listen for dimension mode changes
    const dimModeRadios = document.querySelectorAll('input[name="dimensionMode"]');
    dimModeRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        calculate();
      });
    });
    
    // Listen for power-related field changes to update circuit limit placeholder
    const powerRelatedFields = ['voltage', 'breaker', 'powerType'];
    powerRelatedFields.forEach(id => {
      const element = document.getElementById(id);
      if(element) {
        element.addEventListener('change', () => {
          updateSuggestedCircuitLimit();
        });
        // Also listen for input events on number fields for real-time updates
        if(element.type === 'number') {
          element.addEventListener('input', () => {
            updateSuggestedCircuitLimit();
          });
        }
      }
    });
    
    // Listen for data-related field changes to update data limit placeholder
    const dataRelatedFields = ['frameRate', 'bitDepth', 'processor'];
    dataRelatedFields.forEach(id => {
      const element = document.getElementById(id);
      if(element) {
        element.addEventListener('change', () => {
          updateSuggestedDataLimit();
        });
        // Also listen for input events on number fields for real-time updates
        if(element.type === 'number') {
          element.addEventListener('input', () => {
            updateSuggestedDataLimit();
          });
        }
      }
    });
    
    if(btnPDF) btnPDF.addEventListener('click', function(e) {
      e.preventDefault();
      exportPDF();
    });
    
    if(btnExp) btnExp.addEventListener('click', function(e) {
      e.preventDefault();
      exportCanvas();
    });
    
    setupLive();
    
    const dimModePanels = document.getElementById('dimModePanels');
    const dimModeSize = document.getElementById('dimModeSize');
    
    if(dimModePanels) {
      dimModePanels.addEventListener('change', function() {
        if(this.checked) {
          document.getElementById('panelCountInputs').style.display = 'block';
          document.getElementById('wallSizeInputs').style.display = 'none';
        }
      });
    }
    
    if(dimModeSize) {
      dimModeSize.addEventListener('change', function() {
        if(this.checked) {
          document.getElementById('panelCountInputs').style.display = 'none';
          document.getElementById('wallSizeInputs').style.display = 'block';
        }
      });
    }
    
    const canvasSizeSelect = document.getElementById('canvasSize');
    if(canvasSizeSelect) {
      canvasSizeSelect.addEventListener('change', function() {
        const customInputs = document.getElementById('customCanvasInputs');
        if(this.value === 'custom') {
          customInputs.style.display = 'block';
        } else {
          customInputs.style.display = 'none';
        }
        // Update export filename placeholder
        updateExportFilenamePlaceholder();
      });
    }
    
    // Function to update export filename placeholder
    function updateExportFilenamePlaceholder() {
      const filenameInput = document.getElementById('canvasExportFilename');
      const canvasSizeSelect = document.getElementById('canvasSize');
      if(filenameInput && canvasSizeSelect) {
        let sizeLabel = canvasSizeSelect.options[canvasSizeSelect.selectedIndex].text;
        if(canvasSizeSelect.value === 'custom') {
          const customW = document.getElementById('customCanvasWidth').value || '0';
          const customH = document.getElementById('customCanvasHeight').value || '0';
          sizeLabel = `${customW}x${customH}`;
        }
        filenameInput.placeholder = `LED_Wall_Canvas_${sizeLabel.replace(/\s+/g, '_').replace(/[()]/g, '')}`;
      }
    }
    
    // Also update placeholder when custom dimensions change
    const customWidthInput = document.getElementById('customCanvasWidth');
    const customHeightInput = document.getElementById('customCanvasHeight');
    if(customWidthInput) {
      customWidthInput.addEventListener('input', updateExportFilenamePlaceholder);
    }
    if(customHeightInput) {
      customHeightInput.addEventListener('input', updateExportFilenamePlaceholder);
    }
    
    // Initial placeholder update
    updateExportFilenamePlaceholder();
    
    // Show/hide CB5 half panel toggle based on panel type
    const panelTypeSelect = document.getElementById('panelType');
    const cb5HalfPanelToggle = document.getElementById('cb5HalfPanelToggle');
    
    function updateCB5HalfPanelVisibility() {
      if(panelTypeSelect && cb5HalfPanelToggle) {
        if(panelTypeSelect.value === 'CB5_MKII') {
          cb5HalfPanelToggle.style.display = 'block';
        } else {
          cb5HalfPanelToggle.style.display = 'none';
          // Reset checkbox when hidden
          const checkbox = document.getElementById('addCB5HalfRow');
          if(checkbox) checkbox.checked = false;
        }
      }
    }
    
    if(panelTypeSelect) {
      // IMPORTANT: Check for __ADD_CUSTOM__ FIRST before other handlers
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') {
          openCustomPanelModal();
          // Reset to previous value or first option
          const options = this.querySelectorAll('option:not([value="__ADD_CUSTOM__"])');
          if(options.length > 0) {
            this.value = options[0].value;
          }
          return; // Stop propagation
        }
      });
      
      // Reset everything when panel type changes (but not during screen loading)
      panelTypeSelect.addEventListener('change', function() {
        console.log('Panel type change triggered, isLoadingScreenData:', isLoadingScreenData);
        if (!isLoadingScreenData && this.value !== '__ADD_CUSTOM__') {
          console.log('Calling resetCalculator...');
          resetCalculator();
          console.log('resetCalculator completed');
        }
      });
      
      panelTypeSelect.addEventListener('change', updateCB5HalfPanelVisibility);
      updateCB5HalfPanelVisibility(); // Initial check
      
      // Update max panels per circuit/data placeholders when panel type changes
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        console.log('Updating circuit/data limits...');
        // Update circuit limit placeholder (calculated from power settings)
        updateSuggestedCircuitLimit();
        // Update data limit placeholder (uses panel-specific limit)
        updateSuggestedDataLimit();
        console.log('Circuit/data limits updated');
      });
      
      // Also update 4-way bumper visibility
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        const fourWayOption = document.getElementById('fourWayBumperOption');
        const isCB5 = this.value === 'CB5_MKII' || this.value === 'CB5_MKII_HALF';
        if(fourWayOption) {
          fourWayOption.style.display = isCB5 && useBumpers ? 'block' : 'none';
          if(!isCB5) {
            // Reset 4-way bumpers state when switching away from CB5
            use4WayBumpersEnabled = false;
            const btn = document.getElementById('use4WayBumpersBtn');
            if(btn) btn.classList.remove('active');
          }
        }
      });
      
      // Update connecting plates section visibility
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        updateConnectingPlatesVisibility(this.value);
      });
      
      // Update bumpers on/off based on panel type
      panelTypeSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') return;
        updateBumpersForPanelType(this.value);
      });
      
      // Initial update for connecting plates
      updateConnectingPlatesVisibility(panelTypeSelect.value);
      
      // Initial update for bumpers based on panel type
      updateBumpersForPanelType(panelTypeSelect.value);
    }
    
    // Connection method radio buttons listener (reusing existing connectionRadios)
    // Already declared above, so we can just add another listener to the same elements
    document.querySelectorAll('input[name="connectionMethod"]').forEach(radio => {
      radio.addEventListener('change', function() {
        // Connection method changed - just recalculate
        calculate();
      });
    });
    
    // Bumper distribution mode toggle
    const bumperDistSelect = document.getElementById('bumperDistribution');
    if(bumperDistSelect) {
      bumperDistSelect.addEventListener('change', function() {
        const autoControls = document.getElementById('autoBumperControls');
        const manualControls = document.getElementById('manualBumperControls');
        
        if(this.value === 'auto') {
          if(autoControls) autoControls.style.display = 'block';
          if(manualControls) manualControls.style.display = 'none';
        } else {
          if(autoControls) autoControls.style.display = 'none';
          if(manualControls) manualControls.style.display = 'block';
        }
      });
    }
    
    // Structure type change - automatically set bumpers based on hanging/ground
    const structureTypeSelect = document.getElementById('structureType');
    if(structureTypeSelect) {
      structureTypeSelect.addEventListener('change', function() {
        updateBumpersBasedOnStructureType();
      });
      // Initialize on load
      updateBumpersBasedOnStructureType();
    }
    
    // Listen to panel dimension changes to update weight display and reinitialize bumpers
    const panelsWideInput = document.getElementById('panelsWide');
    const panelsHighInput = document.getElementById('panelsHigh');
    if(panelsWideInput) {
      panelsWideInput.addEventListener('input', function() {
        initializeBumpers(); // Reinitialize when width changes
        updateWeightDisplay();
      });
    }
    if(panelsHighInput) {
      panelsHighInput.addEventListener('input', function() {
        initializeBumpers(); // Reinitialize when height changes
        updateWeightDisplay();
      });
    }
    
    syncFromPanels();
    updateSuggestedDataLimit();
    showSpecWarningIfNeeded();
    updateUndoRedoButtons(); // Initialize button states
    
    // Initialize custom panels and processors dropdowns
    updatePanelDropdowns();
    updateProcessorDropdowns();
    
    // Add event listener for processor dropdown
    const processorSelect = document.getElementById('processor');
    if(processorSelect) {
      processorSelect.addEventListener('change', function() {
        if(this.value === '__ADD_CUSTOM__') {
          openCustomProcessorModal();
          // Reset to previous value or first option
          const options = this.querySelectorAll('option:not([value="__ADD_CUSTOM__"])');
          if(options.length > 0) {
            this.value = options[0].value;
          }
        }
      });
    }
    
    // Add keyboard listeners for panel selection
    document.addEventListener('keydown', function(e) {
      // Check if we're focused on an input field
      const activeElement = document.activeElement;
      const isInputFocused = activeElement && (
        activeElement.tagName === 'INPUT' || 
        activeElement.tagName === 'TEXTAREA' || 
        activeElement.tagName === 'SELECT'
      );
      
      if(e.key === 'Delete' || e.key === 'Backspace') {
        // Only delete panels if NOT focused on an input field
        if(selectedPanels.size > 0 && !isInputFocused) {
          e.preventDefault();
          deleteSelectedPanels();
        }
      }
      
      // Escape to clear selection
      if(e.key === 'Escape') {
        selectedPanels.clear();
        if(currentCanvas) generateLayout('standard');
      }
      
      // Ctrl+Z for Undo
      if((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }
      
      // Ctrl+Y for Redo (also Ctrl+Shift+Z as alternative)
      if((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
      }
    });
    
    // Clear selection when clicking outside canvas views
    document.addEventListener('click', function(e) {
      // Only process if we have selected panels
      if(selectedPanels.size === 0) return;
      
      // Check if click target IS a canvas element
      const canvases = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasView'];
      const clickedCanvas = canvases.some(id => {
        const canvas = document.getElementById(id);
        return canvas && e.target === canvas;
      });
      
      // If not clicking directly on a canvas, clear selection and redraw
      if(!clickedCanvas) {
        selectedPanels.clear();
        // Redraw the current layout if it exists
        const standardCanvas = document.getElementById('standardCanvas');
        if(standardCanvas && standardCanvas.width > 0) {
          generateLayout('standard');
        }
      }
    });
    
    // Initialize canvas undo/redo button states
    updateCanvasUndoRedoButtons();
    
    // Perform initial calculation on page load
    setTimeout(() => {
      calculate();
    }, 100);
    
    // Initialize v29 multi-screen system
    initializeScreenSystem();
    
    // Load the initial screen (screen_1) data into the UI
    loadScreenData('screen_1');
    
    // Set initial placeholders based on the actual default panel type
    updateSuggestedCircuitLimit();
    updateSuggestedDataLimit();
    
    // Update canvas view to ensure correct positioning
    setTimeout(() => {
      showCanvasView();
    }, 150);
    
    // Initialize canvas wheel zoom
    initCanvasWheelZoom();
    initCanvasPanning();

    console.log('Initialization complete - v55.6 Multi-Screen');
  } catch(err) {
    console.error('Initialization error:', err);
    alert('Error initializing calculator: ' + err.message);
  }
});



// ==================== V29 MULTI-SCREEN SYSTEM (ENHANCED) ====================

// Screen management
let screens = {};
let currentScreenId = 'screen_1';
let screenIdCounter = 1;
let isLoadingScreenData = false; // Flag to prevent resetCalculator during screen loading

// Screen colors (50% brightness)
// Screen 1 = gray, Screen 2 = red/gray, Screen 3 = green/gray, Screen 4 = blue/gray, Screen 5 = yellow/gray
// Screen 6 = cyan/gray, Screen 7 = magenta/gray, Screen 8 = orange/gray, Screen 9 = aqua/gray, Screen 10 = purple/gray
// Screen colors (primary color for each screen)
// Screen 1 uses standard layout colors (magenta/cyan), screens 2-10 alternate with gray
const screenColors = [
  '#800080', // Screen 1 - Magenta (50% brightness)
  '#804040', // Screen 2 - Red/Gray
  '#408040', // Screen 3 - Green/Gray
  '#404080', // Screen 4 - Blue/Gray
  '#808040', // Screen 5 - Yellow/Gray
  '#408080', // Screen 6 - Cyan/Gray
  '#804080', // Screen 7 - Magenta/Gray
  '#C06030', // Screen 8 - Orange/Gray (slightly brighter for visibility)
  '#40A0A0', // Screen 9 - Aqua/Gray (brighter cyan variant)
  '#604080'  // Screen 10 - Purple/Gray
];

// Secondary colors for alternating pattern (paired with screenColors)
const screenColors2 = [
  '#008080', // Screen 1 - Cyan (50% brightness)
  '#808080', // Screen 2 - Gray
  '#808080', // Screen 3 - Gray
  '#808080', // Screen 4 - Gray
  '#808080', // Screen 5 - Gray
  '#808080', // Screen 6 - Gray
  '#808080', // Screen 7 - Gray
  '#808080', // Screen 8 - Gray
  '#808080', // Screen 9 - Gray
  '#808080'  // Screen 10 - Gray
];

// Helper function to darken a hex color
function darkenColor(hex, percent) {
  const num = parseInt(hex.replace('#', ''), 16);
  const r = Math.max(0, (num >> 16) - Math.round(255 * percent / 100));
  const g = Math.max(0, ((num >> 8) & 0x00FF) - Math.round(255 * percent / 100));
  const b = Math.max(0, (num & 0x0000FF) - Math.round(255 * percent / 100));
  return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
}

function getDefaultScreenData() {
  return {
    // Dimensions
    panelsWide: 0,
    panelsHigh: 0,
    wallWidth: '',
    wallHeight: '',
    units: 'ft',
    dimensionMode: 'panels',
    
    // Panel Type
    panelType: 'BP2_V2',
    addCB5HalfRow: false,
    connectionMethod: 'airframes', // 'airframes' or 'plates'
    
    // Optional display name (separate from tab name)
    screenDisplayName: '',
    
    // Power
    voltage: 208,
    breaker: 20,
    phase: '3',
    derate: false,
    powerType: 'max',
    maxPanelsPerCircuit: '',
    
    // Data
    processor: 'Brompton_SX40',
    frameRate: 60,
    bitDepth: 8,
    maxPanelsPerData: '',
    dataStartDir: 'top',
    showArrows: true,
    redundancy: true,
    processorRedundancy: false,
    
    // Structure
    structureType: 'hanging',
    useBumpers: true,
    use4WayBumpers: false,
    
    // Cabling
    trimHeight: 20,
    wallToFloor: 5,
    distroToWall: 10,
    processorToWall: 15,
    fohToProcessor: 50,
    
    // Canvas
    canvasX: 0,
    canvasY: 0,
    canvasSize: '4K_UHD',
    customCanvasWidth: '',
    customCanvasHeight: '',
    snapMode: false,
    
    // Per-screen state (previously global)
    bumpers: [],
    nextBumperId: 1,
    deletedPanels: new Set(),
    selectedPanels: new Set(),
    customCircuitAssignments: new Map(),
    customDataLineAssignments: new Map(),
    undoHistory: [],
    redoHistory: []
  };
}

function initializeScreenSystem() {
  screens['screen_1'] = {
    id: 'screen_1',
    name: 'Screen 1',
    color: screenColors[0],
    color2: screenColors2[0],
    visible: true,
    data: getDefaultScreenData()
  };
  
  renderScreenTabs();
  updateCanvasScreenToggles();
}

function renderScreenTabs() {
  const container = document.getElementById('screenTabsContainer');
  if(!container) return;
  
  let html = '<div class="screen-tabs">';
  // Sort screen IDs numerically (screen_1, screen_2, ..., screen_10, screen_11)
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numA - numB;
  });
  
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    const isActive = screenId === currentScreenId;
    html += `
      <div class="screen-tab ${isActive ? 'active' : ''}" 
           onclick="switchToScreen('${screenId}')">
        <span class="screen-tab-name">${screen.name}</span>
        <button class="screen-tab-edit" onclick="event.stopPropagation(); openScreenRenameModal('${screenId}')" title="Edit screen">âœŽ</button>
        ${screenIds.length > 1 ? `<button class="screen-tab-close" onclick="event.stopPropagation(); deleteScreen('${screenId}')" title="Delete screen">Ã—</button>` : ''}
      </div>
    `;
  });
  
  // Always show Add Screen button (no limit)
  html += `<div class="screen-tab-add" onclick="addNewScreen()" title="Add new screen">+</div>`;
  
  html += '</div>';
  container.innerHTML = html;
}

function switchToScreen(screenId) {
  console.log('=== SWITCHING TO SCREEN ===');
  console.log('Target screen ID:', screenId);
  console.log('Current screen ID before switch:', currentScreenId);
  
  if(!screens[screenId]) {
    console.error('Screen not found:', screenId);
    return;
  }
  
  // Save current screen data
  console.log('Saving current screen data...');
  saveCurrentScreenData();
  
  // Switch to new screen
  currentScreenId = screenId;
  console.log('Current screen ID after switch:', currentScreenId);
  
  // Reset canvas viewport pan and zoom for fresh view of new screen
  canvasZoomLevel = 1.0;
  canvasPanX = 0;
  canvasPanY = 0;
  updateCanvasViewport();
  
  // Load new screen data
  console.log('Loading new screen data...');
  loadScreenData(screenId);
  
  // Update UI
  console.log('Rendering screen tabs...');
  renderScreenTabs();
  
  // Recalculate for new screen
  console.log('Calling calculate()...');
  calculate();
  console.log('=== SCREEN SWITCH COMPLETE ===');
}

function saveCurrentScreenData() {
  const screen = screens[currentScreenId];
  if(!screen) return;
  
  const data = screen.data;
  
  // Dimensions
  data.panelsWide = parseInt(document.getElementById('panelsWide').value) || 0;
  data.panelsHigh = parseInt(document.getElementById('panelsHigh').value) || 0;
  data.wallWidth = document.getElementById('wallWidth').value;
  data.wallHeight = document.getElementById('wallHeight').value;
  data.lengthUnit = displayLengthUnit;
  data.weightUnit = displayWeightUnit;
  data.dimensionMode = document.querySelector('input[name="dimensionMode"]:checked')?.value || 'panels';
  
  // Panel Type
  data.panelType = document.getElementById('panelType').value;
  
  // Power
  data.voltage = parseInt(document.getElementById('voltage').value) || 208;
  data.breaker = parseInt(document.getElementById('breaker').value) || 20;
  data.phase = document.getElementById('phase').value;
  data.powerType = document.getElementById('powerType').value;
  data.maxPanelsPerCircuit = document.getElementById('maxPanelsPerCircuit').value;
  
  // Data
  data.processor = document.getElementById('processor').value;
  data.frameRate = parseInt(document.getElementById('frameRate').value) || 60;
  data.bitDepth = parseInt(document.getElementById('bitDepth').value) || 8;
  data.maxPanelsPerData = document.getElementById('maxPanelsPerData').value;
  data.dataStartDir = document.getElementById('dataStartDir').value;
  data.showArrows = showArrowsEnabled;
  data.redundancy = redundancyEnabled;
  data.processorRedundancy = processorRedundancyEnabled;
  
  // Structure
  data.structureType = document.getElementById('structureType').value;
  data.useBumpers = useBumpers; // Save bumper toggle state
  data.use4WayBumpers = use4WayBumpersEnabled; // Save 4-way bumpers state
  
  // CB5-specific options - use the global toggle state
  data.addCB5HalfRow = cb5HalfRowEnabled;
  
  const connectionMethod = document.querySelector('input[name="connectionMethod"]:checked');
  if(connectionMethod) data.connectionMethod = connectionMethod.value;
  
  // Cabling
  const trimHeight = document.getElementById('trimHeight');
  const wallToFloor = document.getElementById('wallToFloor');
  const distroToWall = document.getElementById('distroToWall');
  const processorToWall = document.getElementById('processorToWall');
  const fohToProcessor = document.getElementById('fohToProcessor');
  
  if(trimHeight) data.trimHeight = parseFloat(trimHeight.value) || 20;
  if(wallToFloor) data.wallToFloor = parseFloat(wallToFloor.value) || 5;
  if(distroToWall) data.distroToWall = parseFloat(distroToWall.value) || 10;
  if(processorToWall) data.processorToWall = parseFloat(processorToWall.value) || 15;
  if(fohToProcessor) data.fohToProcessor = parseFloat(fohToProcessor.value) || 50;
  
  // Canvas
  console.log(`Saving screen data for ${currentScreenId}: canvasOffsetX=${canvasOffsetX}, canvasOffsetY=${canvasOffsetY}`);
  data.canvasX = canvasOffsetX;
  data.canvasY = canvasOffsetY;
  console.log(`After save: data.canvasX=${data.canvasX}, data.canvasY=${data.canvasY}`);
  data.canvasSize = document.getElementById('canvasSize').value;
  data.customCanvasWidth = document.getElementById('customCanvasWidth').value;
  data.customCanvasHeight = document.getElementById('customCanvasHeight').value;
  const snapMode = document.getElementById('snapMode');
  if(snapMode) data.snapMode = snapMode.checked;
  
  // Per-screen state - save current global state to screen data
  data.bumpers = JSON.parse(JSON.stringify(bumpers)); // Deep copy array
  data.nextBumperId = nextBumperId;
  data.bumpersInitialized = true; // Mark that bumpers have been saved (even if empty from deletions)
  data.deletedPanels = new Set(deletedPanels); // Copy Set
  data.selectedPanels = new Set(selectedPanels); // Copy Set
  data.customCircuitAssignments = new Map(customCircuitAssignments); // Copy Map
  data.customDataLineAssignments = new Map(customDataLineAssignments); // Copy Map
  
  // Deep copy undo/redo history
  data.undoHistory = undoHistory.map(state => ({
    deletedPanels: new Set(state.deletedPanels),
    selectedPanels: new Set(state.selectedPanels),
    customCircuitAssignments: new Map(state.customCircuitAssignments),
    customDataLineAssignments: new Map(state.customDataLineAssignments)
  }));
  data.redoHistory = redoHistory.map(state => ({
    deletedPanels: new Set(state.deletedPanels),
    selectedPanels: new Set(state.selectedPanels),
    customCircuitAssignments: new Map(state.customCircuitAssignments),
    customDataLineAssignments: new Map(state.customDataLineAssignments)
  }));
}

function loadScreenData(screenId) {
  const screen = screens[screenId];
  if(!screen) return;
  
  // Set flag to prevent resetCalculator from running during load
  isLoadingScreenData = true;
  
  const data = screen.data;
  
  console.log(`Loading screen data for ${screenId}, canvasX: ${data.canvasX}, canvasY: ${data.canvasY}`);
  
  // Dimensions
  document.getElementById('panelsWide').value = data.panelsWide || '';
  document.getElementById('panelsHigh').value = data.panelsHigh || '';
  document.getElementById('wallWidth').value = data.wallWidth || '';
  document.getElementById('wallHeight').value = data.wallHeight || '';
  
  // Restore unit settings if saved with screen
  if(data.lengthUnit) {
    displayLengthUnit = data.lengthUnit;
  }
  if(data.weightUnit) {
    displayWeightUnit = data.weightUnit;
  }
  // Update unit buttons
  const isImperialScreen = displayLengthUnit === 'ft';
  document.getElementById('unitImperial')?.classList.toggle('active', isImperialScreen);
  document.getElementById('unitMetric')?.classList.toggle('active', !isImperialScreen);
  
  // Set dimension mode
  const modeRadio = document.querySelector(`input[name="dimensionMode"][value="${data.dimensionMode}"]`);
  if(modeRadio) modeRadio.checked = true;
  
  // Show/hide appropriate inputs
  document.getElementById('panelCountInputs').style.display = data.dimensionMode === 'panels' ? 'block' : 'none';
  document.getElementById('wallSizeInputs').style.display = data.dimensionMode === 'size' ? 'block' : 'none';
  
  // Panel Type
  document.getElementById('panelType').value = data.panelType || 'BP2_V2';
  
  // Power
  document.getElementById('voltage').value = data.voltage || 208;
  document.getElementById('breaker').value = data.breaker || 20;
  document.getElementById('phase').value = data.phase || '3';
  document.getElementById('powerType').value = data.powerType || 'max';
  document.getElementById('maxPanelsPerCircuit').value = data.maxPanelsPerCircuit || '';
  
  // Data
  document.getElementById('processor').value = data.processor || 'Brompton_SX40';
  document.getElementById('frameRate').value = data.frameRate || 60;
  document.getElementById('bitDepth').value = data.bitDepth || 8;
  document.getElementById('maxPanelsPerData').value = data.maxPanelsPerData || '';
  document.getElementById('dataStartDir').value = data.dataStartDir || 'top';
  showArrowsEnabled = data.showArrows !== false;
  redundancyEnabled = data.redundancy !== false; // Default to true if undefined
  processorRedundancyEnabled = data.processorRedundancy || false;
  
  // Update redundancy button visual state
  const redundancyBtn = document.getElementById('redundancyBtn');
  if(redundancyBtn) {
    redundancyBtn.classList.toggle('active', redundancyEnabled);
  }
  
  // Update processor redundancy button visual state
  const processorRedundancyBtn = document.getElementById('processorRedundancyBtn');
  if(processorRedundancyBtn) {
    processorRedundancyBtn.classList.toggle('active', processorRedundancyEnabled);
  }
  
  // Update show arrows button visual state
  const showArrowsBtn = document.getElementById('showArrowsBtn');
  if(showArrowsBtn) {
    showArrowsBtn.classList.toggle('active', showArrowsEnabled);
  }
  
  // Structure
  document.getElementById('structureType').value = data.structureType || 'hanging';
  
  // Restore bumpers toggle state
  // Check if useBumpers is explicitly set in data, otherwise check panel default
  if(data.useBumpers !== undefined) {
    useBumpers = data.useBumpers;
  } else {
    // Check if panel type has bumpers disabled by default
    const allPanels = getAllPanels();
    const panel = allPanels[data.panelType];
    useBumpers = !(panel && panel.uses_bumpers === false);
  }
  document.getElementById('useBumpersBtn').classList.toggle('active', useBumpers);
  
  // Show/hide bumper controls based on state
  const bumperControls = document.getElementById('bumperControls');
  const fourWayOption = document.getElementById('fourWayBumperOption');
  if(bumperControls) bumperControls.style.display = useBumpers ? '' : 'none';
  if(!useBumpers && fourWayOption) fourWayOption.style.display = 'none';
  
  // Restore 4-way bumpers state
  use4WayBumpersEnabled = data.use4WayBumpers || false;
  const use4WayBtn = document.getElementById('use4WayBumpersBtn');
  if(use4WayBtn) use4WayBtn.classList.toggle('active', use4WayBumpersEnabled);
  
  // Cabling
  const trimHeight = document.getElementById('trimHeight');
  const wallToFloor = document.getElementById('wallToFloor');
  const distroToWall = document.getElementById('distroToWall');
  const processorToWall = document.getElementById('processorToWall');
  const fohToProcessor = document.getElementById('fohToProcessor');
  
  if(trimHeight) trimHeight.value = data.trimHeight || 20;
  if(wallToFloor) wallToFloor.value = data.wallToFloor || 5;
  if(distroToWall) distroToWall.value = data.distroToWall || 10;
  if(processorToWall) processorToWall.value = data.processorToWall || 15;
  if(fohToProcessor) fohToProcessor.value = data.fohToProcessor || 50;
  
  // Canvas - FORCE to proper values
  const loadedX = (typeof data.canvasX === 'number') ? data.canvasX : 0;
  const loadedY = (typeof data.canvasY === 'number') ? data.canvasY : 0;
  
  // Set global variables
  canvasOffsetX = loadedX;
  canvasOffsetY = loadedY;
  
  // Update input fields
  document.getElementById('canvasX').value = loadedX;
  document.getElementById('canvasY').value = loadedY;
  
  // ALSO update the screen data to ensure it's correct
  data.canvasX = loadedX;
  data.canvasY = loadedY;
  
  console.log(`After loading: global canvasOffsetX=${canvasOffsetX}, canvasOffsetY=${canvasOffsetY}`);
  console.log(`After loading: data.canvasX=${data.canvasX}, data.canvasY=${data.canvasY}`);
  
  document.getElementById('canvasSize').value = data.canvasSize || '4K_UHD';
  document.getElementById('customCanvasWidth').value = data.customCanvasWidth || '';
  document.getElementById('customCanvasHeight').value = data.customCanvasHeight || '';
  const snapMode = document.getElementById('snapMode');
  if(snapMode) snapMode.checked = data.snapMode || false;
  
  // Trigger panel type change to update 4-way bumper visibility
  const panelType = data.panelType || 'CB5_MKII';
  const isCB5 = panelType === 'CB5_MKII' || panelType === 'CB5_MKII_HALF';
  if(fourWayOption) {
    fourWayOption.style.display = isCB5 && useBumpers ? 'block' : 'none';
  }
  
  // Update placeholders to show panel-specific defaults
  // Circuit limit is calculated dynamically based on power settings
  // Data limit uses panel-specific maximum
  const p = panels[panelType];
  if(p) {
    // Update max panels per data placeholder (panel-specific)
    const dataInput = document.getElementById('maxPanelsPerData');
    if(dataInput && p.max_panels_per_data) {
      dataInput.placeholder = p.max_panels_per_data.toString();
    }
  }
  // Update circuit limit after a short delay to ensure power settings are loaded
  setTimeout(() => {
    updateSuggestedCircuitLimit();
  }, 0);
  
  // Per-screen state - restore from screen data to global variables
  bumpers = data.bumpers ? JSON.parse(JSON.stringify(data.bumpers)) : [];
  nextBumperId = data.nextBumperId || 1;
  deletedPanels = data.deletedPanels ? new Set(data.deletedPanels) : new Set();
  selectedPanels = data.selectedPanels ? new Set(data.selectedPanels) : new Set();
  customCircuitAssignments = data.customCircuitAssignments ? new Map(data.customCircuitAssignments) : new Map();
  customDataLineAssignments = data.customDataLineAssignments ? new Map(data.customDataLineAssignments) : new Map();
  
  // Restore undo/redo history
  undoHistory = data.undoHistory ? data.undoHistory.map(state => ({
    deletedPanels: new Set(state.deletedPanels),
    selectedPanels: new Set(state.selectedPanels),
    customCircuitAssignments: new Map(state.customCircuitAssignments),
    customDataLineAssignments: new Map(state.customDataLineAssignments)
  })) : [];
  redoHistory = data.redoHistory ? data.redoHistory.map(state => ({
    deletedPanels: new Set(state.deletedPanels),
    selectedPanels: new Set(state.selectedPanels),
    customCircuitAssignments: new Map(state.customCircuitAssignments),
    customDataLineAssignments: new Map(state.customDataLineAssignments)
  })) : [];
  
  // Update undo/redo button states
  updateUndoRedoButtons();
  
  // Clear all canvases when switching screens
  const canvases = ['standardCanvas', 'structureCanvas', 'powerCanvas', 'dataCanvas', 'canvasViewCanvas'];
  canvases.forEach(canvasId => {
    const canvas = document.getElementById(canvasId);
    if(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  });
  
  // Clear results display
  const resultsEl = document.getElementById('results');
  if(resultsEl) resultsEl.innerText = '';
  
  // Update CB5 half panel toggle visibility (panelType and isCB5 already declared above)
  const cb5HalfPanelToggle = document.getElementById('cb5HalfPanelToggle');
  if(cb5HalfPanelToggle) {
    cb5HalfPanelToggle.style.display = (panelType === 'CB5_MKII') ? 'block' : 'none';
  }
  
  // Update connecting plates visibility
  updateConnectingPlatesVisibility(panelType);
  
  // Restore addCB5HalfRow checkbox state if saved
  const addCB5HalfRow = document.getElementById('addCB5HalfRow');
  if(addCB5HalfRow) {
    addCB5HalfRow.checked = data.addCB5HalfRow || false;
  }
  
  // Restore connection method if saved
  if(data.connectionMethod) {
    const connectionRadio = document.querySelector(`input[name="connectionMethod"][value="${data.connectionMethod}"]`);
    if(connectionRadio) connectionRadio.checked = true;
  }
  
  // Reset bumper globals based on structure type - this ensures structure view shows correct bumpers
  const structureType = data.structureType || 'hanging';
  if(structureType === 'hanging') {
    showTopBumper = true;
    showBottomBumper = false;
  } else { // ground
    showTopBumper = false;
    showBottomBumper = true;
  }
  
  // Only initialize bumpers if they haven't been customized/saved yet for this screen
  // If bumpersInitialized is true, the bumpers array (even if empty) reflects user's choices
  if(!data.bumpersInitialized && (showTopBumper || showBottomBumper) && data.panelsWide > 0) {
    initializeBumpers();
  }
  
  // Clear flag after all data is loaded
  isLoadingScreenData = false;
}

// Generate a distinct color for screens beyond the predefined 10
function generateCustomScreenColor(screenNumber) {
  // Use HSL color space for better color distribution
  // Start after the 10 predefined colors, cycle through hues
  const baseHue = ((screenNumber - 11) * 137) % 360; // Golden angle for good distribution
  const saturation = 40; // 40% saturation for muted colors
  const lightness = 50;  // 50% lightness
  
  return `hsl(${baseHue}, ${saturation}%, ${lightness}%)`;
}

function addNewScreen() {
  console.log('=== ADDING NEW SCREEN ===');
  
  // Save current screen data first (including any name changes)
  console.log('Saving current screen before adding new screen...');
  saveCurrentScreenData();
  
  screenIdCounter++;
  const newScreenId = `screen_${screenIdCounter}`;
  const screenNumber = Object.keys(screens).length + 1;
  
  // Use predefined colors for first 10 screens, generate custom colors for the rest
  let color, color2;
  if(screenNumber <= screenColors.length) {
    color = screenColors[screenNumber - 1];
    color2 = screenColors2[screenNumber - 1];
  } else {
    color = generateCustomScreenColor(screenNumber);
    color2 = darkenColor(color, 30);
  }
  
  console.log('New screen ID:', newScreenId);
  console.log('Screen number:', screenNumber);
  console.log('Screen color:', color);
  
  screens[newScreenId] = {
    id: newScreenId,
    name: `Screen ${screenNumber}`,
    color: color,
    color2: color2,
    visible: true,
    data: getDefaultScreenData()
  };
  
  console.log('New screen created:', screens[newScreenId]);
  console.log('All screens:', Object.keys(screens));
  
  renderScreenTabs();
  updateCanvasScreenToggles();
  
  // Switch to the new screen
  console.log('Switching to new screen...');
  switchToScreen(newScreenId);
}

function deleteScreen(screenId) {
  if(Object.keys(screens).length === 1) {
    alert('Cannot delete the last screen');
    return;
  }
  
  if(!confirm(`Delete ${screens[screenId].name}?`)) return;
  
  delete screens[screenId];
  
  if(currentScreenId === screenId) {
    currentScreenId = Object.keys(screens)[0];
    loadScreenData(currentScreenId);
  }
  
  renderScreenTabs();
  updateCanvasScreenToggles();
  calculate();
}

let screenToRename = null;

function openScreenRenameModal(screenId) {
  screenToRename = screenId;
  const screen = screens[screenId];
  document.getElementById('screenRenameInput').value = screen.name;
  
  // Set primary color picker value
  const colorInput = document.getElementById('screenColorInput');
  const colorPreview = document.getElementById('screenColorPreview');
  colorInput.value = screen.color;
  colorPreview.textContent = screen.color;
  colorPreview.style.background = screen.color;
  
  // Set secondary color picker value
  const color2Input = document.getElementById('screenColor2Input');
  const color2Preview = document.getElementById('screenColor2Preview');
  const color2Value = screen.color2 || darkenColor(screen.color, 30);
  color2Input.value = color2Value;
  color2Preview.textContent = color2Value;
  color2Preview.style.background = color2Value;
  
  // Update preview when primary color changes
  colorInput.oninput = function() {
    colorPreview.textContent = this.value;
    colorPreview.style.background = this.value;
  };
  
  // Update preview when secondary color changes
  color2Input.oninput = function() {
    color2Preview.textContent = this.value;
    color2Preview.style.background = this.value;
  };
  
  document.getElementById('screenRenameModal').classList.add('active');
}

function closeScreenRenameModal() {
  document.getElementById('screenRenameModal').classList.remove('active');
  screenToRename = null;
}

function saveScreenRename() {
  const newName = document.getElementById('screenRenameInput').value.trim();
  if(!newName) {
    alert('Please enter a screen name');
    return;
  }
  
  if(screenToRename && screens[screenToRename]) {
    screens[screenToRename].name = newName;
    screens[screenToRename].color = document.getElementById('screenColorInput').value;
    screens[screenToRename].color2 = document.getElementById('screenColor2Input').value;
    renderScreenTabs();
    updateCanvasScreenToggles();
    // Update all views to show the new name/color
    generateLayout('standard');
    generateStructureLayout();
    generateLayout('power');
    generateLayout('data');
    showCanvasView();
  }
  
  closeScreenRenameModal();
}

function updateCanvasScreenToggles() {
  const container = document.getElementById('canvasScreenToggles');
  if(!container) return;
  
  let html = '<div class="section-title" style="margin-top: 16px;">Visible Screens</div>';
  
  // Sort screen IDs numerically
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numA - numB;
  });
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    const showCoords = screen.showCoordinates !== false;
    const showPixels = screen.showPixelDimensions !== false;
    
    html += `
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; padding: 4px 6px; background: #333; border-radius: 4px;">
        <label class="inline-label" style="margin-bottom: 0; display: flex; align-items: center; flex: 1;">
          <input type="checkbox" ${screen.visible ? 'checked' : ''} 
                 onchange="toggleScreenVisibility('${screenId}', this.checked)">
          <span style="margin-left: 6px; display: inline-flex; align-items: center;">
            <span style="display: inline-block; width: 12px; height: 12px; background: ${screen.color}; margin-right: 6px; border: 1px solid #666;"></span>
            ${screen.name}
          </span>
        </label>
        <div style="display: flex; gap: 4px;">
          <button type="button" class="toggle-btn ${showCoords ? 'active' : ''}" 
                  style="padding: 2px 6px; font-size: 10px;" 
                  onclick="toggleScreenCoordinates('${screenId}')">X/Y</button>
          <button type="button" class="toggle-btn ${showPixels ? 'active' : ''}" 
                  style="padding: 2px 6px; font-size: 10px;" 
                  onclick="toggleScreenPixelDimensions('${screenId}')">Pixels</button>
        </div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

function toggleScreenVisibility(screenId, visible) {
  if(screens[screenId]) {
    screens[screenId].visible = visible;
    // Redraw canvas view to show/hide the screen
    showCanvasView();
  }
}

function toggleScreenCoordinates(screenId) {
  if(screens[screenId]) {
    // Toggle - default is true (shown), so undefined or true becomes false, false becomes true
    screens[screenId].showCoordinates = screens[screenId].showCoordinates === false ? true : false;
    updateCanvasScreenToggles();
    showCanvasView();
  }
}

function toggleScreenPixelDimensions(screenId) {
  if(screens[screenId]) {
    // Toggle - default is true (shown), so undefined or true becomes false, false becomes true
    screens[screenId].showPixelDimensions = screens[screenId].showPixelDimensions === false ? true : false;
    updateCanvasScreenToggles();
    showCanvasView();
  }
}

function resetCurrentScreenOnPanelChange() {
  const screen = screens[currentScreenId];
  if(!screen) return;
  
  // Only reset dimensions and canvas position, keep other settings
  screen.data.panelsWide = 0;
  screen.data.panelsHigh = 0;
  screen.data.wallWidth = '';
  screen.data.wallHeight = '';
  screen.data.canvasX = 0;
  screen.data.canvasY = 0;
  
  document.getElementById('panelsWide').value = '';
  document.getElementById('panelsHigh').value = '';
  document.getElementById('wallWidth').value = '';
  document.getElementById('wallHeight').value = '';
  canvasOffsetX = 0;
  canvasOffsetY = 0;
}

function generateGearList() {
  const gearListContainer = document.getElementById('gearListContainer');
  const gearListContent = document.getElementById('gearListContent');
  
  if(!gearListContainer || !gearListContent) return;
  
  // Sort screen IDs numerically
  const screenIds = Object.keys(screens).sort((a, b) => {
    const numA = parseInt(a.split('_')[1]);
    const numB = parseInt(b.split('_')[1]);
    return numA - numB;
  });
  let html = '<div style="font-size: 14px;">';
  
  screenIds.forEach(screenId => {
    const screen = screens[screenId];
    const W = screen.data.panelsWide;
    const H = screen.data.panelsHigh;
    
    if(W === 0 || H === 0) return;
    
    const panelType = document.getElementById('panelType').value;
    const allPanels = {...panels, ...customPanels};
    const p = allPanels[panelType];
    if(!p) return;
    
    html += `<div style="margin-bottom: 24px; padding: 16px; background: #2a2a2a; border-radius: 6px; border-left: 4px solid ${screen.color};">`;
    html += `<h3 style="color: #fff; margin-bottom: 12px; font-size: 16px;">${screen.name}</h3>`;
    html += `<div><strong>Panels:</strong> ${W * H} Ã— ${p.brand} ${p.name}</div>`;
    html += `<div><strong>Dimensions:</strong> ${(W * p.width_m).toFixed(2)}m Ã— ${(H * p.height_m).toFixed(2)}m</div>`;
    html += `<div><strong>Resolution:</strong> ${W * p.res_x} Ã— ${H * p.res_y} px</div>`;
    html += `</div>`;
  });
  
  const trimHeight = parseFloat(document.getElementById('trimHeight').value) || 20;
  const wallToFloor = parseFloat(document.getElementById('wallToFloor').value) || 5;
  const distroToWall = parseFloat(document.getElementById('distroToWall').value) || 10;
  const processorToWall = parseFloat(document.getElementById('processorToWall').value) || 15;
  const fohToProcessor = parseFloat(document.getElementById('fohToProcessor').value) || 50;
  
  html += `<div style="margin-top: 24px; padding: 16px; background: #3a2a2a; border-radius: 6px; border: 2px solid #9a4a4a;">`;
  html += `<h3 style="color: #c27676; margin-bottom: 12px; font-size: 16px;">Cable Requirements</h3>`;
  html += `<div><strong>Trim Height:</strong> ${trimHeight} ft</div>`;
  html += `<div><strong>Wall to Floor:</strong> ${wallToFloor} ft</div>`;
  html += `<div><strong>Distro to Wall Top:</strong> ${distroToWall} ft</div>`;
  html += `<div><strong>Processor to Wall:</strong> ${processorToWall} ft</div>`;
  html += `<div><strong>FOH to Processor:</strong> ${fohToProcessor} ft</div>`;
  html += `</div>`;
  
  html += '</div>';
  
  gearListContent.innerHTML = html;
  gearListContainer.style.display = 'block';
}

</script>

<!-- Button labels verified: Config, Specs, Layouts, Canvas, Gear -->
<!-- Bottom Navigation - Comic Style -->
<nav class="bottom-nav">
  <button class="nav-item active" data-view="config" onclick="switchMobileView('config')">
    <span class="nav-item-label">Config</span>
  </button>
  <button class="nav-item" data-view="specs" onclick="switchMobileView('specs')">
    <span class="nav-item-label">Specs</span>
  </button>
  <button class="nav-item" data-view="layouts" onclick="switchMobileView('layouts')">
    <span class="nav-item-label">Layouts</span>
  </button>
  <button class="nav-item" data-view="canvas" onclick="switchMobileView('canvas')">
    <span class="nav-item-label">Canvas</span>
  </button>
  <button class="nav-item" data-view="gear" onclick="switchMobileView('gear')">
    <span class="nav-item-label">Gear</span>
  </button>
</nav>

<script>
// ==================== MOBILE-SPECIFIC JAVASCRIPT ====================

// Mobile Menu Functions
function toggleMobileMenu() {
  const overlay = document.getElementById('mobileMenuOverlay');
  overlay.classList.toggle('active');
  document.body.style.overflow = overlay.classList.contains('active') ? 'hidden' : '';
}

function closeMobileMenu() {
  const overlay = document.getElementById('mobileMenuOverlay');
  overlay.classList.remove('active');
  document.body.style.overflow = '';
}

// Mobile View Switching
let currentMobileView = 'config';
let currentMobileLayout = 'standard'; // Track which layout is showing in layouts view

function switchMobileView(view) {
  currentMobileView = view;

  // Update nav items
  document.querySelectorAll('.nav-item').forEach(item => {
    item.classList.toggle('active', item.dataset.view === view);
  });

  // Get all containers
  const mainContainer = document.querySelector('.main-container');
  const resultsEl = document.getElementById('results');
  const specWarningEl = document.getElementById('specWarning');
  const screenTabsContainer = document.getElementById('screenTabsContainer');
  const layoutsTogglesContainer = document.getElementById('layoutsTogglesContainer');
  const canvasContainer = document.getElementById('canvasContainer');
  const gearListContainer = document.getElementById('gearListContainer');

  // Layout containers
  const standardContainer = document.getElementById('standardContainer');
  const powerContainer = document.getElementById('powerContainer');
  const dataContainer = document.getElementById('dataContainer');
  const structureContainer = document.getElementById('structureContainer');

  // Hide all first
  if(mainContainer) mainContainer.style.display = 'none';
  if(resultsEl) resultsEl.style.display = 'none';
  if(specWarningEl) specWarningEl.style.display = 'none';
  if(screenTabsContainer) screenTabsContainer.style.display = 'none';
  if(layoutsTogglesContainer) layoutsTogglesContainer.style.display = 'none';
  if(standardContainer) standardContainer.style.display = 'none';
  if(powerContainer) powerContainer.style.display = 'none';
  if(dataContainer) dataContainer.style.display = 'none';
  if(structureContainer) structureContainer.style.display = 'none';
  if(canvasContainer) canvasContainer.style.display = 'none';
  if(gearListContainer) gearListContainer.style.display = 'none';

  switch(view) {
    case 'config':
      // Show configuration form
      if(mainContainer) mainContainer.style.display = 'block';
      if(screenTabsContainer) screenTabsContainer.style.display = 'flex';
      break;

    case 'specs':
      // Show results/specifications
      if(resultsEl) resultsEl.style.display = 'block';
      if(specWarningEl) specWarningEl.style.display = 'block';
      if(screenTabsContainer) screenTabsContainer.style.display = 'flex';
      break;

    case 'layouts':
      // Show layout toggle bar and current layout
      if(layoutsTogglesContainer) layoutsTogglesContainer.style.display = 'block';
      if(screenTabsContainer) screenTabsContainer.style.display = 'flex';
      // Show the currently selected layout
      showMobileLayout(currentMobileLayout);
      break;

    case 'canvas':
      // Show canvas view
      if(canvasContainer) canvasContainer.style.display = 'block';
      if(screenTabsContainer) screenTabsContainer.style.display = 'flex';
      break;

    case 'gear':
      // Show gear list
      if(gearListContainer) {
        gearListContainer.style.display = 'block';
        generateGearList(); // Refresh gear list when switching to it
      }
      break;
  }

  // Trigger recalculation to ensure canvases render
  if(typeof calculate === 'function') {
    calculate();
  }
}

// Switch between layouts within the Layouts view
function showMobileLayout(layout) {
  currentMobileLayout = layout;

  // Update toggle buttons
  document.querySelectorAll('.layouts-toggle-container .toggle-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  const activeBtn = document.getElementById('layoutToggle' + layout.charAt(0).toUpperCase() + layout.slice(1));
  if(activeBtn) activeBtn.classList.add('active');

  // Hide all layout containers
  const standardContainer = document.getElementById('standardContainer');
  const powerContainer = document.getElementById('powerContainer');
  const dataContainer = document.getElementById('dataContainer');
  const structureContainer = document.getElementById('structureContainer');

  if(standardContainer) standardContainer.style.display = 'none';
  if(powerContainer) powerContainer.style.display = 'none';
  if(dataContainer) dataContainer.style.display = 'none';
  if(structureContainer) structureContainer.style.display = 'none';

  // Show the selected layout
  switch(layout) {
    case 'standard':
      if(standardContainer) standardContainer.style.display = 'block';
      break;
    case 'power':
      if(powerContainer) powerContainer.style.display = 'block';
      break;
    case 'data':
      if(dataContainer) dataContainer.style.display = 'block';
      break;
    case 'structure':
      if(structureContainer) structureContainer.style.display = 'block';
      break;
  }

  // Regenerate the layout
  if(typeof generateLayout === 'function') {
    generateLayout(layout);
  }
}

// PWA Install Prompt
let deferredPrompt;

window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  // Show install button
  const installBtn = document.getElementById('installPwaBtn');
  if(installBtn) installBtn.style.display = 'block';
});

function installPwa() {
  if(deferredPrompt) {
    deferredPrompt.prompt();
    deferredPrompt.userChoice.then((choiceResult) => {
      if(choiceResult.outcome === 'accepted') {
        console.log('User accepted PWA install');
      }
      deferredPrompt = null;
      const installBtn = document.getElementById('installPwaBtn');
      if(installBtn) installBtn.style.display = 'none';
    });
  }
}

// Service Worker Registration (inline)
if('serviceWorker' in navigator) {
  // Create a simple service worker for offline capability
  const swCode = `
    const CACHE_NAME = 'led-calc-mobile-v1';
    const urlsToCache = [self.location.href];

    self.addEventListener('install', event => {
      event.waitUntil(
        caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
      );
    });

    self.addEventListener('fetch', event => {
      event.respondWith(
        caches.match(event.request).then(response => {
          return response || fetch(event.request);
        })
      );
    });
  `;

  const blob = new Blob([swCode], {type: 'application/javascript'});
  const swUrl = URL.createObjectURL(blob);

  navigator.serviceWorker.register(swUrl).then(registration => {
    console.log('SW registered:', registration.scope);
  }).catch(error => {
    console.log('SW registration failed:', error);
  });
}

// Collapsible Sections - runs after page fully loads
function initMobileUI() {
  console.log('Initializing mobile UI...');

  // Add section-content wrapper to all section boxes that don't have one
  document.querySelectorAll('.section-box').forEach(box => {
    const title = box.querySelector('.section-title');
    if(title && !box.querySelector('.section-content')) {
      // Wrap non-title children in section-content
      const children = Array.from(box.children).filter(child => !child.classList.contains('section-title'));
      if(children.length > 0) {
        const content = document.createElement('div');
        content.className = 'section-content';
        children.forEach(child => content.appendChild(child));
        box.appendChild(content);
      }
    }

    // Add click/touch handler for collapsing
    if(title) {
      title.addEventListener('click', function(e) {
        e.stopPropagation();
        box.classList.toggle('collapsed');
      });
    }
  });

  // Initialize on config view
  switchMobileView('config');

  // Make sure calculate runs
  if(typeof calculate === 'function') {
    setTimeout(calculate, 100);
  }

  console.log('Mobile UI initialized');
}

// Run initialization when DOM is ready
if(document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initMobileUI);
} else {
  // DOM already loaded, run now
  initMobileUI();
}

// Touch gesture support for canvases
let touchStartX = 0;
let touchStartY = 0;
let touchStartDistance = 0;
let initialZoom = 1;

function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// Add touch handlers to canvases
function initializeTouchCanvas(canvasId) {
  const canvas = document.getElementById(canvasId);
  if(!canvas) return;

  canvas.addEventListener('touchstart', function(e) {
    if(e.touches.length === 2) {
      // Pinch start
      touchStartDistance = getTouchDistance(e.touches);
      initialZoom = canvasZoomLevel || 1;
      e.preventDefault();
    } else if(e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  }, {passive: false});

  canvas.addEventListener('touchmove', function(e) {
    if(e.touches.length === 2 && touchStartDistance > 0) {
      // Pinch zoom
      const currentDistance = getTouchDistance(e.touches);
      const scale = currentDistance / touchStartDistance;
      const newZoom = Math.min(3, Math.max(0.5, initialZoom * scale));

      if(typeof setCanvasZoom === 'function') {
        setCanvasZoom(newZoom * 100);
      }
      e.preventDefault();
    }
  }, {passive: false});

  canvas.addEventListener('touchend', function(e) {
    touchStartDistance = 0;
  });
}

// Initialize touch on all canvases after load
window.addEventListener('load', function() {
  ['standardCanvas', 'powerCanvas', 'dataCanvas', 'structureCanvas', 'canvasView'].forEach(initializeTouchCanvas);
});

// Long-press for context menu (replaces right-click)
let longPressTimer = null;
let longPressTriggered = false;
let longPressTouchStart = {x: 0, y: 0};

function setupMobileLongPress() {
  console.log('Setting up mobile long-press handlers...');

  // Standard Canvas - long press for panel context menu
  const standardCanvas = document.getElementById('standardCanvas');
  if(standardCanvas) {
    standardCanvas.addEventListener('touchstart', function(e) {
      if(e.touches.length !== 1) return;

      longPressTriggered = false;
      longPressTouchStart.x = e.touches[0].clientX;
      longPressTouchStart.y = e.touches[0].clientY;

      longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        vibrate(50);

        // Get panel at touch position
        const panel = getPanelAtPosition(standardCanvas, longPressTouchStart.x, longPressTouchStart.y);
        if(panel) {
          // Select the panel if not already selected
          if(!selectedPanels.has(panel.key)) {
            selectedPanels.clear();
            selectedPanels.add(panel.key);
            generateLayout('standard');
          }
          // Show context menu
          showContextMenu(longPressTouchStart.x, longPressTouchStart.y);
        }
      }, 600);
    }, {passive: true});

    standardCanvas.addEventListener('touchmove', function(e) {
      if(longPressTimer) {
        const dx = Math.abs(e.touches[0].clientX - longPressTouchStart.x);
        const dy = Math.abs(e.touches[0].clientY - longPressTouchStart.y);
        if(dx > 10 || dy > 10) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
      }
    }, {passive: true});

    standardCanvas.addEventListener('touchend', function(e) {
      if(longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      // Prevent click if long press was triggered
      if(longPressTriggered) {
        e.preventDefault();
        longPressTriggered = false;
      }
    });

    console.log('Standard canvas long-press enabled');
  }

  // Structure Canvas - long press for bumper context menu
  const structureCanvas = document.getElementById('structureCanvas');
  if(structureCanvas) {
    structureCanvas.addEventListener('touchstart', function(e) {
      if(e.touches.length !== 1) return;

      longPressTriggered = false;
      longPressTouchStart.x = e.touches[0].clientX;
      longPressTouchStart.y = e.touches[0].clientY;

      longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        vibrate(50);

        if(!manualBumperMode) {
          // Auto-enable manual mode on long press
          toggleManualBumperMode();
        }

        // Get bumper at touch position
        const bumper = getBumperAtMouse(structureCanvas, longPressTouchStart.x, longPressTouchStart.y);
        if(bumper) {
          // Select the bumper
          if(!selectedBumpers.has(bumper.id)) {
            selectedBumpers.clear();
            selectedBumpers.add(bumper.id);
            updateStructureSelectionInfo();
            generateStructureLayout();
          }
          // Show bumper context menu
          showBumperContextMenu(bumper, longPressTouchStart.x, longPressTouchStart.y);
        } else {
          // Check if in bumper area for adding
          const rect = structureCanvas.getBoundingClientRect();
          const y = (longPressTouchStart.y - rect.top) * (structureCanvas.height / rect.height);
          const x = (longPressTouchStart.x - rect.left) * (structureCanvas.width / rect.width);

          const pw = parseInt(document.getElementById('panelsWide').value) || 0;
          const ph = parseInt(document.getElementById('panelsHigh').value) || 0;
          const size = 50;
          const bumperHeight = 40;

          const column = Math.floor(x / size);

          if(showTopBumper && y < bumperHeight && column >= 0 && column < pw) {
            showEmptyAreaContextMenu('top', column, longPressTouchStart.x, longPressTouchStart.y);
          } else if(showBottomBumper) {
            const bottomStart = (showTopBumper ? bumperHeight : 0) + (ph * size);
            if(y >= bottomStart && column >= 0 && column < pw) {
              showEmptyAreaContextMenu('bottom', column, longPressTouchStart.x, longPressTouchStart.y);
            }
          }
        }
      }, 600);
    }, {passive: true});

    structureCanvas.addEventListener('touchmove', function(e) {
      if(longPressTimer) {
        const dx = Math.abs(e.touches[0].clientX - longPressTouchStart.x);
        const dy = Math.abs(e.touches[0].clientY - longPressTouchStart.y);
        if(dx > 10 || dy > 10) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
      }
    }, {passive: true});

    structureCanvas.addEventListener('touchend', function(e) {
      if(longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      if(longPressTriggered) {
        e.preventDefault();
        longPressTriggered = false;
      }
    });

    console.log('Structure canvas long-press enabled');
  }
}

// Haptic feedback helper
function vibrate(pattern = 10) {
  if('vibrate' in navigator) {
    navigator.vibrate(pattern);
  }
}

// Initialize long-press after page loads
window.addEventListener('load', function() {
  setTimeout(setupMobileLongPress, 500);
});

console.log('Mobile v1 JavaScript loaded');
</script>

</body>
</html>
